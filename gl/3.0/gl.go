// ** file automatically generated by glgen -- do not edit manually **

package GL

// #cgo CXXFLAGS: -std=c++0x -pedantic-errors -Wall -fno-strict-aliasing
// #cgo LDFLAGS: -lstdc++
// #cgo pkg-config: Qt5Core Qt5OpenGL
//
// #include "funcs.h"
//
// void free(void*);
//
import "C"

import (
	"fmt"
	"reflect"
	"unsafe"

	"gopkg.in/qml.v1/gl/glbase"
)

// API returns a value that offers methods matching the OpenGL version 3.0 API.
//
// The returned API must not be used after the provided OpenGL context becomes invalid.
func API(context glbase.Contexter) *GL {
	gl := &GL{}
	gl.funcs = C.gl3_0_funcs()
	if gl.funcs == nil {
		panic(fmt.Errorf("OpenGL version 3.0 is not available"))
	}
	return gl
}

// GL implements the OpenGL version 3.0 API. Values of this
// type must be created via the API function, and it must not be used after
// the associated OpenGL context becomes invalid.
type GL struct {
	funcs unsafe.Pointer
}

const (
	FALSE = 0
	TRUE  = 1
	NONE  = 0

	BYTE           = 0x1400
	UNSIGNED_BYTE  = 0x1401
	SHORT          = 0x1402
	UNSIGNED_SHORT = 0x1403
	INT            = 0x1404
	UNSIGNED_INT   = 0x1405
	FLOAT          = 0x1406
	N2_BYTES       = 0x1407
	N3_BYTES       = 0x1408
	N4_BYTES       = 0x1409
	DOUBLE         = 0x140A
	HALF_FLOAT     = 0x140B

	ACCUM  = 0x0100
	LOAD   = 0x0101
	RETURN = 0x0102
	MULT   = 0x0103
	ADD    = 0x0104

	ACCUM_BUFFER_BIT    = 0x00000200
	ALL_ATTRIB_BITS     = 0xFFFFFFFF
	COLOR_BUFFER_BIT    = 0x00004000
	CURRENT_BIT         = 0x00000001
	DEPTH_BUFFER_BIT    = 0x00000100
	ENABLE_BIT          = 0x00002000
	EVAL_BIT            = 0x00010000
	FOG_BIT             = 0x00000080
	HINT_BIT            = 0x00008000
	LIGHTING_BIT        = 0x00000040
	LINE_BIT            = 0x00000004
	LIST_BIT            = 0x00020000
	MULTISAMPLE_BIT     = 0x20000000
	PIXEL_MODE_BIT      = 0x00000020
	POINT_BIT           = 0x00000002
	POLYGON_BIT         = 0x00000008
	POLYGON_STIPPLE_BIT = 0x00000010
	SCISSOR_BIT         = 0x00080000
	STENCIL_BUFFER_BIT  = 0x00000400
	TEXTURE_BIT         = 0x00040000
	TRANSFORM_BIT       = 0x00001000
	VIEWPORT_BIT        = 0x00000800

	ALWAYS   = 0x0207
	EQUAL    = 0x0202
	GEQUAL   = 0x0206
	GREATER  = 0x0204
	LEQUAL   = 0x0203
	LESS     = 0x0201
	NEVER    = 0x0200
	NOTEQUAL = 0x0205

	LOGIC_OP = 0x0BF1

	DST_ALPHA           = 0x0304
	ONE                 = 1
	ONE_MINUS_DST_ALPHA = 0x0305
	ONE_MINUS_SRC_ALPHA = 0x0303
	ONE_MINUS_SRC_COLOR = 0x0301
	SRC_ALPHA           = 0x0302
	SRC_COLOR           = 0x0300
	ZERO                = 0

	DST_COLOR           = 0x0306
	ONE_MINUS_DST_COLOR = 0x0307
	SRC_ALPHA_SATURATE  = 0x0308

	CLIENT_ALL_ATTRIB_BITS  = 0xFFFFFFFF
	CLIENT_PIXEL_STORE_BIT  = 0x00000001
	CLIENT_VERTEX_ARRAY_BIT = 0x00000002

	CLIP_DISTANCE0 = 0x3000
	CLIP_DISTANCE1 = 0x3001
	CLIP_DISTANCE2 = 0x3002
	CLIP_DISTANCE3 = 0x3003
	CLIP_DISTANCE4 = 0x3004
	CLIP_DISTANCE5 = 0x3005
	CLIP_DISTANCE6 = 0x3006
	CLIP_DISTANCE7 = 0x3007
	CLIP_PLANE0    = 0x3000
	CLIP_PLANE1    = 0x3001
	CLIP_PLANE2    = 0x3002
	CLIP_PLANE3    = 0x3003
	CLIP_PLANE4    = 0x3004
	CLIP_PLANE5    = 0x3005

	BACK           = 0x0405
	FRONT          = 0x0404
	FRONT_AND_BACK = 0x0408

	AMBIENT             = 0x1200
	AMBIENT_AND_DIFFUSE = 0x1602
	DIFFUSE             = 0x1201
	EMISSION            = 0x1600
	SPECULAR            = 0x1202

	CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT = 0x00000001

	AUX0        = 0x0409
	AUX1        = 0x040A
	AUX2        = 0x040B
	AUX3        = 0x040C
	BACK_LEFT   = 0x0402
	BACK_RIGHT  = 0x0403
	FRONT_LEFT  = 0x0400
	FRONT_RIGHT = 0x0401
	LEFT        = 0x0406
	RIGHT       = 0x0407

	ALPHA_TEST           = 0x0BC0
	AUTO_NORMAL          = 0x0D80
	BLEND                = 0x0BE2
	COLOR_ARRAY          = 0x8076
	COLOR_LOGIC_OP       = 0x0BF2
	COLOR_MATERIAL       = 0x0B57
	CULL_FACE            = 0x0B44
	DEPTH_TEST           = 0x0B71
	DITHER               = 0x0BD0
	EDGE_FLAG_ARRAY      = 0x8079
	FOG                  = 0x0B60
	INDEX_ARRAY          = 0x8077
	INDEX_LOGIC_OP       = 0x0BF1
	LIGHT0               = 0x4000
	LIGHT1               = 0x4001
	LIGHT2               = 0x4002
	LIGHT3               = 0x4003
	LIGHT4               = 0x4004
	LIGHT5               = 0x4005
	LIGHT6               = 0x4006
	LIGHT7               = 0x4007
	LIGHTING             = 0x0B50
	LINE_SMOOTH          = 0x0B20
	LINE_STIPPLE         = 0x0B24
	MAP1_COLOR_4         = 0x0D90
	MAP1_INDEX           = 0x0D91
	MAP1_NORMAL          = 0x0D92
	MAP1_TEXTURE_COORD_1 = 0x0D93
	MAP1_TEXTURE_COORD_2 = 0x0D94
	MAP1_TEXTURE_COORD_3 = 0x0D95
	MAP1_TEXTURE_COORD_4 = 0x0D96
	MAP1_VERTEX_3        = 0x0D97
	MAP1_VERTEX_4        = 0x0D98
	MAP2_COLOR_4         = 0x0DB0
	MAP2_INDEX           = 0x0DB1
	MAP2_NORMAL          = 0x0DB2
	MAP2_TEXTURE_COORD_1 = 0x0DB3
	MAP2_TEXTURE_COORD_2 = 0x0DB4
	MAP2_TEXTURE_COORD_3 = 0x0DB5
	MAP2_TEXTURE_COORD_4 = 0x0DB6
	MAP2_VERTEX_3        = 0x0DB7
	MAP2_VERTEX_4        = 0x0DB8
	NORMALIZE            = 0x0BA1
	NORMAL_ARRAY         = 0x8075
	POINT_SMOOTH         = 0x0B10
	POLYGON_OFFSET_FILL  = 0x8037
	POLYGON_OFFSET_LINE  = 0x2A02
	POLYGON_OFFSET_POINT = 0x2A01
	POLYGON_SMOOTH       = 0x0B41
	POLYGON_STIPPLE      = 0x0B42
	SCISSOR_TEST         = 0x0C11
	STENCIL_TEST         = 0x0B90
	TEXTURE_1D           = 0x0DE0
	TEXTURE_2D           = 0x0DE1
	TEXTURE_COORD_ARRAY  = 0x8078
	TEXTURE_GEN_Q        = 0x0C63
	TEXTURE_GEN_R        = 0x0C62
	TEXTURE_GEN_S        = 0x0C60
	TEXTURE_GEN_T        = 0x0C61
	VERTEX_ARRAY         = 0x8074

	INVALID_ENUM                  = 0x0500
	INVALID_FRAMEBUFFER_OPERATION = 0x0506
	INVALID_OPERATION             = 0x0502
	INVALID_VALUE                 = 0x0501
	NO_ERROR                      = 0
	OUT_OF_MEMORY                 = 0x0505
	STACK_OVERFLOW                = 0x0503
	STACK_UNDERFLOW               = 0x0504

	N2D               = 0x0600
	N3D               = 0x0601
	N3D_COLOR         = 0x0602
	N3D_COLOR_TEXTURE = 0x0603
	N4D_COLOR_TEXTURE = 0x0604

	BITMAP_TOKEN       = 0x0704
	COPY_PIXEL_TOKEN   = 0x0706
	DRAW_PIXEL_TOKEN   = 0x0705
	LINE_RESET_TOKEN   = 0x0707
	LINE_TOKEN         = 0x0702
	PASS_THROUGH_TOKEN = 0x0700
	POINT_TOKEN        = 0x0701
	POLYGON_TOKEN      = 0x0703

	EXP    = 0x0800
	EXP2   = 0x0801
	LINEAR = 0x2601

	FOG_COLOR   = 0x0B66
	FOG_DENSITY = 0x0B62
	FOG_END     = 0x0B64
	FOG_INDEX   = 0x0B61
	FOG_MODE    = 0x0B65
	FOG_START   = 0x0B63

	CCW = 0x0901
	CW  = 0x0900

	COEFF  = 0x0A00
	DOMAIN = 0x0A02
	ORDER  = 0x0A01

	PIXEL_MAP_A_TO_A = 0x0C79
	PIXEL_MAP_B_TO_B = 0x0C78
	PIXEL_MAP_G_TO_G = 0x0C77
	PIXEL_MAP_I_TO_A = 0x0C75
	PIXEL_MAP_I_TO_B = 0x0C74
	PIXEL_MAP_I_TO_G = 0x0C73
	PIXEL_MAP_I_TO_I = 0x0C70
	PIXEL_MAP_I_TO_R = 0x0C72
	PIXEL_MAP_R_TO_R = 0x0C76
	PIXEL_MAP_S_TO_S = 0x0C71

	ACCUM_ALPHA_BITS              = 0x0D5B
	ACCUM_BLUE_BITS               = 0x0D5A
	ACCUM_CLEAR_VALUE             = 0x0B80
	ACCUM_GREEN_BITS              = 0x0D59
	ACCUM_RED_BITS                = 0x0D58
	ALIASED_LINE_WIDTH_RANGE      = 0x846E
	ALIASED_POINT_SIZE_RANGE      = 0x846D
	ALPHA_BIAS                    = 0x0D1D
	ALPHA_BITS                    = 0x0D55
	ALPHA_SCALE                   = 0x0D1C
	ALPHA_TEST_FUNC               = 0x0BC1
	ALPHA_TEST_REF                = 0x0BC2
	ATTRIB_STACK_DEPTH            = 0x0BB0
	AUX_BUFFERS                   = 0x0C00
	BLEND_DST                     = 0x0BE0
	BLEND_SRC                     = 0x0BE1
	BLUE_BIAS                     = 0x0D1B
	BLUE_BITS                     = 0x0D54
	BLUE_SCALE                    = 0x0D1A
	CLIENT_ATTRIB_STACK_DEPTH     = 0x0BB1
	COLOR_ARRAY_SIZE              = 0x8081
	COLOR_ARRAY_STRIDE            = 0x8083
	COLOR_ARRAY_TYPE              = 0x8082
	COLOR_CLEAR_VALUE             = 0x0C22
	COLOR_MATERIAL_FACE           = 0x0B55
	COLOR_MATERIAL_PARAMETER      = 0x0B56
	COLOR_WRITEMASK               = 0x0C23
	CULL_FACE_MODE                = 0x0B45
	CURRENT_COLOR                 = 0x0B00
	CURRENT_INDEX                 = 0x0B01
	CURRENT_NORMAL                = 0x0B02
	CURRENT_RASTER_COLOR          = 0x0B04
	CURRENT_RASTER_DISTANCE       = 0x0B09
	CURRENT_RASTER_INDEX          = 0x0B05
	CURRENT_RASTER_POSITION       = 0x0B07
	CURRENT_RASTER_POSITION_VALID = 0x0B08
	CURRENT_RASTER_TEXTURE_COORDS = 0x0B06
	CURRENT_TEXTURE_COORDS        = 0x0B03
	DEPTH_BIAS                    = 0x0D1F
	DEPTH_BITS                    = 0x0D56
	DEPTH_CLEAR_VALUE             = 0x0B73
	DEPTH_FUNC                    = 0x0B74
	DEPTH_RANGE                   = 0x0B70
	DEPTH_SCALE                   = 0x0D1E
	DEPTH_WRITEMASK               = 0x0B72
	DOUBLEBUFFER                  = 0x0C32
	DRAW_BUFFER                   = 0x0C01
	EDGE_FLAG                     = 0x0B43
	EDGE_FLAG_ARRAY_STRIDE        = 0x808C
	FEEDBACK_BUFFER_SIZE          = 0x0DF1
	FEEDBACK_BUFFER_TYPE          = 0x0DF2
	FOG_HINT                      = 0x0C54
	FRONT_FACE                    = 0x0B46
	GREEN_BIAS                    = 0x0D19
	GREEN_BITS                    = 0x0D53
	GREEN_SCALE                   = 0x0D18
	INDEX_ARRAY_STRIDE            = 0x8086
	INDEX_ARRAY_TYPE              = 0x8085
	INDEX_BITS                    = 0x0D51
	INDEX_CLEAR_VALUE             = 0x0C20
	INDEX_MODE                    = 0x0C30
	INDEX_OFFSET                  = 0x0D13
	INDEX_SHIFT                   = 0x0D12
	INDEX_WRITEMASK               = 0x0C21
	LIGHT_MODEL_AMBIENT           = 0x0B53
	LIGHT_MODEL_COLOR_CONTROL     = 0x81F8
	LIGHT_MODEL_LOCAL_VIEWER      = 0x0B51
	LIGHT_MODEL_TWO_SIDE          = 0x0B52
	LINE_SMOOTH_HINT              = 0x0C52
	LINE_STIPPLE_PATTERN          = 0x0B25
	LINE_STIPPLE_REPEAT           = 0x0B26
	LINE_WIDTH                    = 0x0B21
	LINE_WIDTH_GRANULARITY        = 0x0B23
	LINE_WIDTH_RANGE              = 0x0B22
	LIST_BASE                     = 0x0B32
	LIST_INDEX                    = 0x0B33
	LIST_MODE                     = 0x0B30
	LOGIC_OP_MODE                 = 0x0BF0
	MAP1_GRID_DOMAIN              = 0x0DD0
	MAP1_GRID_SEGMENTS            = 0x0DD1
	MAP2_GRID_DOMAIN              = 0x0DD2
	MAP2_GRID_SEGMENTS            = 0x0DD3
	MAP_COLOR                     = 0x0D10
	MAP_STENCIL                   = 0x0D11
	MATRIX_MODE                   = 0x0BA0
	MAX_ATTRIB_STACK_DEPTH        = 0x0D35
	MAX_CLIENT_ATTRIB_STACK_DEPTH = 0x0D3B
	MAX_CLIP_DISTANCES            = 0x0D32
	MAX_CLIP_PLANES               = 0x0D32
	MAX_EVAL_ORDER                = 0x0D30
	MAX_LIGHTS                    = 0x0D31
	MAX_LIST_NESTING              = 0x0B31
	MAX_MODELVIEW_STACK_DEPTH     = 0x0D36
	MAX_NAME_STACK_DEPTH          = 0x0D37
	MAX_PIXEL_MAP_TABLE           = 0x0D34
	MAX_PROJECTION_STACK_DEPTH    = 0x0D38
	MAX_TEXTURE_SIZE              = 0x0D33
	MAX_TEXTURE_STACK_DEPTH       = 0x0D39
	MAX_VIEWPORT_DIMS             = 0x0D3A
	MODELVIEW_MATRIX              = 0x0BA6
	MODELVIEW_STACK_DEPTH         = 0x0BA3
	NAME_STACK_DEPTH              = 0x0D70
	NORMAL_ARRAY_STRIDE           = 0x807F
	NORMAL_ARRAY_TYPE             = 0x807E
	PACK_ALIGNMENT                = 0x0D05
	PACK_LSB_FIRST                = 0x0D01
	PACK_ROW_LENGTH               = 0x0D02
	PACK_SKIP_PIXELS              = 0x0D04
	PACK_SKIP_ROWS                = 0x0D03
	PACK_SWAP_BYTES               = 0x0D00
	PERSPECTIVE_CORRECTION_HINT   = 0x0C50
	PIXEL_MAP_A_TO_A_SIZE         = 0x0CB9
	PIXEL_MAP_B_TO_B_SIZE         = 0x0CB8
	PIXEL_MAP_G_TO_G_SIZE         = 0x0CB7
	PIXEL_MAP_I_TO_A_SIZE         = 0x0CB5
	PIXEL_MAP_I_TO_B_SIZE         = 0x0CB4
	PIXEL_MAP_I_TO_G_SIZE         = 0x0CB3
	PIXEL_MAP_I_TO_I_SIZE         = 0x0CB0
	PIXEL_MAP_I_TO_R_SIZE         = 0x0CB2
	PIXEL_MAP_R_TO_R_SIZE         = 0x0CB6
	PIXEL_MAP_S_TO_S_SIZE         = 0x0CB1
	POINT_SIZE                    = 0x0B11
	POINT_SIZE_GRANULARITY        = 0x0B13
	POINT_SIZE_RANGE              = 0x0B12
	POINT_SMOOTH_HINT             = 0x0C51
	POLYGON_MODE                  = 0x0B40
	POLYGON_OFFSET_FACTOR         = 0x8038
	POLYGON_OFFSET_UNITS          = 0x2A00
	POLYGON_SMOOTH_HINT           = 0x0C53
	PROJECTION_MATRIX             = 0x0BA7
	PROJECTION_STACK_DEPTH        = 0x0BA4
	READ_BUFFER                   = 0x0C02
	RED_BIAS                      = 0x0D15
	RED_BITS                      = 0x0D52
	RED_SCALE                     = 0x0D14
	RENDER_MODE                   = 0x0C40
	RGBA_MODE                     = 0x0C31
	SCISSOR_BOX                   = 0x0C10
	SELECTION_BUFFER_SIZE         = 0x0DF4
	SHADE_MODEL                   = 0x0B54
	SMOOTH_LINE_WIDTH_GRANULARITY = 0x0B23
	SMOOTH_LINE_WIDTH_RANGE       = 0x0B22
	SMOOTH_POINT_SIZE_GRANULARITY = 0x0B13
	SMOOTH_POINT_SIZE_RANGE       = 0x0B12
	STENCIL_BITS                  = 0x0D57
	STENCIL_CLEAR_VALUE           = 0x0B91
	STENCIL_FAIL                  = 0x0B94
	STENCIL_FUNC                  = 0x0B92
	STENCIL_PASS_DEPTH_FAIL       = 0x0B95
	STENCIL_PASS_DEPTH_PASS       = 0x0B96
	STENCIL_REF                   = 0x0B97
	STENCIL_VALUE_MASK            = 0x0B93
	STENCIL_WRITEMASK             = 0x0B98
	STEREO                        = 0x0C33
	SUBPIXEL_BITS                 = 0x0D50
	TEXTURE_BINDING_1D            = 0x8068
	TEXTURE_BINDING_2D            = 0x8069
	TEXTURE_BINDING_3D            = 0x806A
	TEXTURE_COORD_ARRAY_SIZE      = 0x8088
	TEXTURE_COORD_ARRAY_STRIDE    = 0x808A
	TEXTURE_COORD_ARRAY_TYPE      = 0x8089
	TEXTURE_MATRIX                = 0x0BA8
	TEXTURE_STACK_DEPTH           = 0x0BA5
	UNPACK_ALIGNMENT              = 0x0CF5
	UNPACK_LSB_FIRST              = 0x0CF1
	UNPACK_ROW_LENGTH             = 0x0CF2
	UNPACK_SKIP_PIXELS            = 0x0CF4
	UNPACK_SKIP_ROWS              = 0x0CF3
	UNPACK_SWAP_BYTES             = 0x0CF0
	VERTEX_ARRAY_SIZE             = 0x807A
	VERTEX_ARRAY_STRIDE           = 0x807C
	VERTEX_ARRAY_TYPE             = 0x807B
	VIEWPORT                      = 0x0BA2
	ZOOM_X                        = 0x0D16
	ZOOM_Y                        = 0x0D17

	COLOR_ARRAY_POINTER         = 0x8090
	EDGE_FLAG_ARRAY_POINTER     = 0x8093
	FEEDBACK_BUFFER_POINTER     = 0x0DF0
	INDEX_ARRAY_POINTER         = 0x8091
	NORMAL_ARRAY_POINTER        = 0x808F
	SELECTION_BUFFER_POINTER    = 0x0DF3
	TEXTURE_COORD_ARRAY_POINTER = 0x8092
	VERTEX_ARRAY_POINTER        = 0x808E

	TEXTURE_ALPHA_SIZE      = 0x805F
	TEXTURE_BLUE_SIZE       = 0x805E
	TEXTURE_BORDER          = 0x1005
	TEXTURE_BORDER_COLOR    = 0x1004
	TEXTURE_COMPONENTS      = 0x1003
	TEXTURE_GREEN_SIZE      = 0x805D
	TEXTURE_HEIGHT          = 0x1001
	TEXTURE_INTENSITY_SIZE  = 0x8061
	TEXTURE_INTERNAL_FORMAT = 0x1003
	TEXTURE_LUMINANCE_SIZE  = 0x8060
	TEXTURE_MAG_FILTER      = 0x2800
	TEXTURE_MIN_FILTER      = 0x2801
	TEXTURE_PRIORITY        = 0x8066
	TEXTURE_RED_SIZE        = 0x805C
	TEXTURE_RESIDENT        = 0x8067
	TEXTURE_WIDTH           = 0x1000
	TEXTURE_WRAP_S          = 0x2802
	TEXTURE_WRAP_T          = 0x2803

	DONT_CARE = 0x1100
	FASTEST   = 0x1101
	NICEST    = 0x1102

	FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8B8B
	GENERATE_MIPMAP_HINT            = 0x8192
	TEXTURE_COMPRESSION_HINT        = 0x84EF

	C3F_V3F         = 0x2A24
	C4F_N3F_V3F     = 0x2A26
	C4UB_V2F        = 0x2A22
	C4UB_V3F        = 0x2A23
	N3F_V3F         = 0x2A25
	T2F_C3F_V3F     = 0x2A2A
	T2F_C4F_N3F_V3F = 0x2A2C
	T2F_C4UB_V3F    = 0x2A29
	T2F_N3F_V3F     = 0x2A2B
	T2F_V3F         = 0x2A27
	T4F_C4F_N3F_V4F = 0x2A2D
	T4F_V4F         = 0x2A28
	V2F             = 0x2A20
	V3F             = 0x2A21

	MODULATE = 0x2100
	REPLACE  = 0x1E01

	SEPARATE_SPECULAR_COLOR = 0x81FA
	SINGLE_COLOR            = 0x81F9

	CONSTANT_ATTENUATION  = 0x1207
	LINEAR_ATTENUATION    = 0x1208
	POSITION              = 0x1203
	QUADRATIC_ATTENUATION = 0x1209
	SPOT_CUTOFF           = 0x1206
	SPOT_DIRECTION        = 0x1204
	SPOT_EXPONENT         = 0x1205

	COMPILE             = 0x1300
	COMPILE_AND_EXECUTE = 0x1301

	AND           = 0x1501
	AND_INVERTED  = 0x1504
	AND_REVERSE   = 0x1502
	CLEAR         = 0x1500
	COPY          = 0x1503
	COPY_INVERTED = 0x150C
	EQUIV         = 0x1509
	INVERT        = 0x150A
	NAND          = 0x150E
	NOOP          = 0x1505
	NOR           = 0x1508
	OR            = 0x1507
	OR_INVERTED   = 0x150D
	OR_REVERSE    = 0x150B
	SET           = 0x150F
	XOR           = 0x1506

	MAP_FLUSH_EXPLICIT_BIT    = 0x0010
	MAP_INVALIDATE_BUFFER_BIT = 0x0008
	MAP_INVALIDATE_RANGE_BIT  = 0x0004
	MAP_READ_BIT              = 0x0001
	MAP_UNSYNCHRONIZED_BIT    = 0x0020
	MAP_WRITE_BIT             = 0x0002

	COLOR_INDEXES = 0x1603
	SHININESS     = 0x1601

	MODELVIEW  = 0x1700
	PROJECTION = 0x1701
	TEXTURE    = 0x1702

	LINE  = 0x1B01
	POINT = 0x1B00

	FILL = 0x1B02

	COLOR   = 0x1800
	DEPTH   = 0x1801
	STENCIL = 0x1802

	ALPHA           = 0x1906
	BLUE            = 0x1905
	COLOR_INDEX     = 0x1900
	DEPTH_COMPONENT = 0x1902
	GREEN           = 0x1904
	LUMINANCE       = 0x1909
	LUMINANCE_ALPHA = 0x190A
	RED             = 0x1903
	RGB             = 0x1907
	RGBA            = 0x1908
	STENCIL_INDEX   = 0x1901

	ALPHA12             = 0x803D
	ALPHA16             = 0x803E
	ALPHA4              = 0x803B
	ALPHA8              = 0x803C
	INTENSITY           = 0x8049
	INTENSITY12         = 0x804C
	INTENSITY16         = 0x804D
	INTENSITY4          = 0x804A
	INTENSITY8          = 0x804B
	LUMINANCE12         = 0x8041
	LUMINANCE12_ALPHA12 = 0x8047
	LUMINANCE12_ALPHA4  = 0x8046
	LUMINANCE16         = 0x8042
	LUMINANCE16_ALPHA16 = 0x8048
	LUMINANCE4          = 0x803F
	LUMINANCE4_ALPHA4   = 0x8043
	LUMINANCE6_ALPHA2   = 0x8044
	LUMINANCE8          = 0x8040
	LUMINANCE8_ALPHA8   = 0x8045
	R3_G3_B2            = 0x2A10
	RGB10               = 0x8052
	RGB10_A2            = 0x8059
	RGB12               = 0x8053
	RGB16               = 0x8054
	RGB4                = 0x804F
	RGB5                = 0x8050
	RGB5_A1             = 0x8057
	RGB8                = 0x8051
	RGBA12              = 0x805A
	RGBA16              = 0x805B
	RGBA2               = 0x8055
	RGBA4               = 0x8056
	RGBA8               = 0x8058

	PACK_IMAGE_HEIGHT   = 0x806C
	PACK_SKIP_IMAGES    = 0x806B
	UNPACK_IMAGE_HEIGHT = 0x806E
	UNPACK_SKIP_IMAGES  = 0x806D

	BITMAP                  = 0x1A00
	UNSIGNED_BYTE_3_3_2     = 0x8032
	UNSIGNED_INT_10_10_10_2 = 0x8036
	UNSIGNED_INT_8_8_8_8    = 0x8035
	UNSIGNED_SHORT_4_4_4_4  = 0x8033
	UNSIGNED_SHORT_5_5_5_1  = 0x8034

	POINT_DISTANCE_ATTENUATION = 0x8129
	POINT_FADE_THRESHOLD_SIZE  = 0x8128
	POINT_SIZE_MAX             = 0x8127
	POINT_SIZE_MIN             = 0x8126

	LINES          = 0x0001
	LINE_LOOP      = 0x0002
	LINE_STRIP     = 0x0003
	POINTS         = 0x0000
	POLYGON        = 0x0009
	QUADS          = 0x0007
	QUAD_STRIP     = 0x0008
	TRIANGLES      = 0x0004
	TRIANGLE_FAN   = 0x0006
	TRIANGLE_STRIP = 0x0005

	FEEDBACK = 0x1C01
	RENDER   = 0x1C00
	SELECT   = 0x1C02

	FLAT   = 0x1D00
	SMOOTH = 0x1D01

	DECR = 0x1E03
	INCR = 0x1E02
	KEEP = 0x1E00

	EXTENSIONS = 0x1F03
	RENDERER   = 0x1F01
	VENDOR     = 0x1F00
	VERSION    = 0x1F02

	S = 0x2000
	T = 0x2001
	R = 0x2002
	Q = 0x2003

	DECAL = 0x2101

	TEXTURE_ENV_COLOR = 0x2201
	TEXTURE_ENV_MODE  = 0x2200

	TEXTURE_ENV = 0x2300

	EYE_LINEAR    = 0x2400
	OBJECT_LINEAR = 0x2401
	SPHERE_MAP    = 0x2402

	EYE_PLANE        = 0x2502
	OBJECT_PLANE     = 0x2501
	TEXTURE_GEN_MODE = 0x2500

	NEAREST = 0x2600

	LINEAR_MIPMAP_LINEAR   = 0x2703
	LINEAR_MIPMAP_NEAREST  = 0x2701
	NEAREST_MIPMAP_LINEAR  = 0x2702
	NEAREST_MIPMAP_NEAREST = 0x2700

	GENERATE_MIPMAP = 0x8191
	TEXTURE_WRAP_R  = 0x8072

	PROXY_TEXTURE_1D   = 0x8063
	PROXY_TEXTURE_2D   = 0x8064
	PROXY_TEXTURE_3D   = 0x8070
	TEXTURE_3D         = 0x806F
	TEXTURE_BASE_LEVEL = 0x813C
	TEXTURE_MAX_LEVEL  = 0x813D
	TEXTURE_MAX_LOD    = 0x813B
	TEXTURE_MIN_LOD    = 0x813A

	CLAMP           = 0x2900
	CLAMP_TO_BORDER = 0x812D
	CLAMP_TO_EDGE   = 0x812F
	REPEAT          = 0x2901

	CONSTANT_COLOR                                = 0x8001
	ONE_MINUS_CONSTANT_COLOR                      = 0x8002
	CONSTANT_ALPHA                                = 0x8003
	ONE_MINUS_CONSTANT_ALPHA                      = 0x8004
	FUNC_ADD                                      = 0x8006
	MIN                                           = 0x8007
	MAX                                           = 0x8008
	BLEND_EQUATION_RGB                            = 0x8009
	FUNC_SUBTRACT                                 = 0x800A
	FUNC_REVERSE_SUBTRACT                         = 0x800B
	RESCALE_NORMAL                                = 0x803A
	TEXTURE_DEPTH                                 = 0x8071
	MAX_3D_TEXTURE_SIZE                           = 0x8073
	MULTISAMPLE                                   = 0x809D
	SAMPLE_ALPHA_TO_COVERAGE                      = 0x809E
	SAMPLE_ALPHA_TO_ONE                           = 0x809F
	SAMPLE_COVERAGE                               = 0x80A0
	SAMPLE_BUFFERS                                = 0x80A8
	SAMPLES                                       = 0x80A9
	SAMPLE_COVERAGE_VALUE                         = 0x80AA
	SAMPLE_COVERAGE_INVERT                        = 0x80AB
	BLEND_DST_RGB                                 = 0x80C8
	BLEND_SRC_RGB                                 = 0x80C9
	BLEND_DST_ALPHA                               = 0x80CA
	BLEND_SRC_ALPHA                               = 0x80CB
	BGR                                           = 0x80E0
	BGRA                                          = 0x80E1
	MAX_ELEMENTS_VERTICES                         = 0x80E8
	MAX_ELEMENTS_INDICES                          = 0x80E9
	DEPTH_COMPONENT16                             = 0x81A5
	DEPTH_COMPONENT24                             = 0x81A6
	DEPTH_COMPONENT32                             = 0x81A7
	FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING         = 0x8210
	FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE         = 0x8211
	FRAMEBUFFER_ATTACHMENT_RED_SIZE               = 0x8212
	FRAMEBUFFER_ATTACHMENT_GREEN_SIZE             = 0x8213
	FRAMEBUFFER_ATTACHMENT_BLUE_SIZE              = 0x8214
	FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE             = 0x8215
	FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE             = 0x8216
	FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE           = 0x8217
	FRAMEBUFFER_DEFAULT                           = 0x8218
	FRAMEBUFFER_UNDEFINED                         = 0x8219
	DEPTH_STENCIL_ATTACHMENT                      = 0x821A
	MAJOR_VERSION                                 = 0x821B
	MINOR_VERSION                                 = 0x821C
	NUM_EXTENSIONS                                = 0x821D
	CONTEXT_FLAGS                                 = 0x821E
	COMPRESSED_RED                                = 0x8225
	COMPRESSED_RG                                 = 0x8226
	RG                                            = 0x8227
	RG_INTEGER                                    = 0x8228
	R8                                            = 0x8229
	R16                                           = 0x822A
	RG8                                           = 0x822B
	RG16                                          = 0x822C
	R16F                                          = 0x822D
	R32F                                          = 0x822E
	RG16F                                         = 0x822F
	RG32F                                         = 0x8230
	R8I                                           = 0x8231
	R8UI                                          = 0x8232
	R16I                                          = 0x8233
	R16UI                                         = 0x8234
	R32I                                          = 0x8235
	R32UI                                         = 0x8236
	RG8I                                          = 0x8237
	RG8UI                                         = 0x8238
	RG16I                                         = 0x8239
	RG16UI                                        = 0x823A
	RG32I                                         = 0x823B
	RG32UI                                        = 0x823C
	UNSIGNED_BYTE_2_3_3_REV                       = 0x8362
	UNSIGNED_SHORT_5_6_5                          = 0x8363
	UNSIGNED_SHORT_5_6_5_REV                      = 0x8364
	UNSIGNED_SHORT_4_4_4_4_REV                    = 0x8365
	UNSIGNED_SHORT_1_5_5_5_REV                    = 0x8366
	UNSIGNED_INT_8_8_8_8_REV                      = 0x8367
	UNSIGNED_INT_2_10_10_10_REV                   = 0x8368
	MIRRORED_REPEAT                               = 0x8370
	FOG_COORDINATE_SOURCE                         = 0x8450
	FOG_COORD_SRC                                 = 0x8450
	FOG_COORDINATE                                = 0x8451
	FOG_COORD                                     = 0x8451
	FRAGMENT_DEPTH                                = 0x8452
	CURRENT_FOG_COORDINATE                        = 0x8453
	CURRENT_FOG_COORD                             = 0x8453
	FOG_COORDINATE_ARRAY_TYPE                     = 0x8454
	FOG_COORD_ARRAY_TYPE                          = 0x8454
	FOG_COORDINATE_ARRAY_STRIDE                   = 0x8455
	FOG_COORD_ARRAY_STRIDE                        = 0x8455
	FOG_COORDINATE_ARRAY_POINTER                  = 0x8456
	FOG_COORD_ARRAY_POINTER                       = 0x8456
	FOG_COORDINATE_ARRAY                          = 0x8457
	FOG_COORD_ARRAY                               = 0x8457
	COLOR_SUM                                     = 0x8458
	CURRENT_SECONDARY_COLOR                       = 0x8459
	SECONDARY_COLOR_ARRAY_SIZE                    = 0x845A
	SECONDARY_COLOR_ARRAY_TYPE                    = 0x845B
	SECONDARY_COLOR_ARRAY_STRIDE                  = 0x845C
	SECONDARY_COLOR_ARRAY_POINTER                 = 0x845D
	SECONDARY_COLOR_ARRAY                         = 0x845E
	CURRENT_RASTER_SECONDARY_COLOR                = 0x845F
	TEXTURE0                                      = 0x84C0
	TEXTURE1                                      = 0x84C1
	TEXTURE2                                      = 0x84C2
	TEXTURE3                                      = 0x84C3
	TEXTURE4                                      = 0x84C4
	TEXTURE5                                      = 0x84C5
	TEXTURE6                                      = 0x84C6
	TEXTURE7                                      = 0x84C7
	TEXTURE8                                      = 0x84C8
	TEXTURE9                                      = 0x84C9
	TEXTURE10                                     = 0x84CA
	TEXTURE11                                     = 0x84CB
	TEXTURE12                                     = 0x84CC
	TEXTURE13                                     = 0x84CD
	TEXTURE14                                     = 0x84CE
	TEXTURE15                                     = 0x84CF
	TEXTURE16                                     = 0x84D0
	TEXTURE17                                     = 0x84D1
	TEXTURE18                                     = 0x84D2
	TEXTURE19                                     = 0x84D3
	TEXTURE20                                     = 0x84D4
	TEXTURE21                                     = 0x84D5
	TEXTURE22                                     = 0x84D6
	TEXTURE23                                     = 0x84D7
	TEXTURE24                                     = 0x84D8
	TEXTURE25                                     = 0x84D9
	TEXTURE26                                     = 0x84DA
	TEXTURE27                                     = 0x84DB
	TEXTURE28                                     = 0x84DC
	TEXTURE29                                     = 0x84DD
	TEXTURE30                                     = 0x84DE
	TEXTURE31                                     = 0x84DF
	ACTIVE_TEXTURE                                = 0x84E0
	CLIENT_ACTIVE_TEXTURE                         = 0x84E1
	MAX_TEXTURE_UNITS                             = 0x84E2
	TRANSPOSE_MODELVIEW_MATRIX                    = 0x84E3
	TRANSPOSE_PROJECTION_MATRIX                   = 0x84E4
	TRANSPOSE_TEXTURE_MATRIX                      = 0x84E5
	TRANSPOSE_COLOR_MATRIX                        = 0x84E6
	SUBTRACT                                      = 0x84E7
	MAX_RENDERBUFFER_SIZE                         = 0x84E8
	COMPRESSED_ALPHA                              = 0x84E9
	COMPRESSED_LUMINANCE                          = 0x84EA
	COMPRESSED_LUMINANCE_ALPHA                    = 0x84EB
	COMPRESSED_INTENSITY                          = 0x84EC
	COMPRESSED_RGB                                = 0x84ED
	COMPRESSED_RGBA                               = 0x84EE
	DEPTH_STENCIL                                 = 0x84F9
	UNSIGNED_INT_24_8                             = 0x84FA
	MAX_TEXTURE_LOD_BIAS                          = 0x84FD
	TEXTURE_FILTER_CONTROL                        = 0x8500
	TEXTURE_LOD_BIAS                              = 0x8501
	INCR_WRAP                                     = 0x8507
	DECR_WRAP                                     = 0x8508
	NORMAL_MAP                                    = 0x8511
	REFLECTION_MAP                                = 0x8512
	TEXTURE_CUBE_MAP                              = 0x8513
	TEXTURE_BINDING_CUBE_MAP                      = 0x8514
	TEXTURE_CUBE_MAP_POSITIVE_X                   = 0x8515
	TEXTURE_CUBE_MAP_NEGATIVE_X                   = 0x8516
	TEXTURE_CUBE_MAP_POSITIVE_Y                   = 0x8517
	TEXTURE_CUBE_MAP_NEGATIVE_Y                   = 0x8518
	TEXTURE_CUBE_MAP_POSITIVE_Z                   = 0x8519
	TEXTURE_CUBE_MAP_NEGATIVE_Z                   = 0x851A
	PROXY_TEXTURE_CUBE_MAP                        = 0x851B
	MAX_CUBE_MAP_TEXTURE_SIZE                     = 0x851C
	COMBINE                                       = 0x8570
	COMBINE_RGB                                   = 0x8571
	COMBINE_ALPHA                                 = 0x8572
	RGB_SCALE                                     = 0x8573
	ADD_SIGNED                                    = 0x8574
	INTERPOLATE                                   = 0x8575
	CONSTANT                                      = 0x8576
	PRIMARY_COLOR                                 = 0x8577
	PREVIOUS                                      = 0x8578
	SOURCE0_RGB                                   = 0x8580
	SRC0_RGB                                      = 0x8580
	SOURCE1_RGB                                   = 0x8581
	SRC1_RGB                                      = 0x8581
	SOURCE2_RGB                                   = 0x8582
	SRC2_RGB                                      = 0x8582
	SOURCE0_ALPHA                                 = 0x8588
	SRC0_ALPHA                                    = 0x8588
	SOURCE1_ALPHA                                 = 0x8589
	SRC1_ALPHA                                    = 0x8589
	SOURCE2_ALPHA                                 = 0x858A
	SRC2_ALPHA                                    = 0x858A
	OPERAND0_RGB                                  = 0x8590
	OPERAND1_RGB                                  = 0x8591
	OPERAND2_RGB                                  = 0x8592
	OPERAND0_ALPHA                                = 0x8598
	OPERAND1_ALPHA                                = 0x8599
	OPERAND2_ALPHA                                = 0x859A
	VERTEX_ARRAY_BINDING                          = 0x85B5
	VERTEX_ATTRIB_ARRAY_ENABLED                   = 0x8622
	VERTEX_ATTRIB_ARRAY_SIZE                      = 0x8623
	VERTEX_ATTRIB_ARRAY_STRIDE                    = 0x8624
	VERTEX_ATTRIB_ARRAY_TYPE                      = 0x8625
	CURRENT_VERTEX_ATTRIB                         = 0x8626
	VERTEX_PROGRAM_POINT_SIZE                     = 0x8642
	VERTEX_PROGRAM_TWO_SIDE                       = 0x8643
	VERTEX_ATTRIB_ARRAY_POINTER                   = 0x8645
	TEXTURE_COMPRESSED_IMAGE_SIZE                 = 0x86A0
	TEXTURE_COMPRESSED                            = 0x86A1
	NUM_COMPRESSED_TEXTURE_FORMATS                = 0x86A2
	COMPRESSED_TEXTURE_FORMATS                    = 0x86A3
	DOT3_RGB                                      = 0x86AE
	DOT3_RGBA                                     = 0x86AF
	BUFFER_SIZE                                   = 0x8764
	BUFFER_USAGE                                  = 0x8765
	STENCIL_BACK_FUNC                             = 0x8800
	STENCIL_BACK_FAIL                             = 0x8801
	STENCIL_BACK_PASS_DEPTH_FAIL                  = 0x8802
	STENCIL_BACK_PASS_DEPTH_PASS                  = 0x8803
	RGBA32F                                       = 0x8814
	RGB32F                                        = 0x8815
	RGBA16F                                       = 0x881A
	RGB16F                                        = 0x881B
	MAX_DRAW_BUFFERS                              = 0x8824
	DRAW_BUFFER0                                  = 0x8825
	DRAW_BUFFER1                                  = 0x8826
	DRAW_BUFFER2                                  = 0x8827
	DRAW_BUFFER3                                  = 0x8828
	DRAW_BUFFER4                                  = 0x8829
	DRAW_BUFFER5                                  = 0x882A
	DRAW_BUFFER6                                  = 0x882B
	DRAW_BUFFER7                                  = 0x882C
	DRAW_BUFFER8                                  = 0x882D
	DRAW_BUFFER9                                  = 0x882E
	DRAW_BUFFER10                                 = 0x882F
	DRAW_BUFFER11                                 = 0x8830
	DRAW_BUFFER12                                 = 0x8831
	DRAW_BUFFER13                                 = 0x8832
	DRAW_BUFFER14                                 = 0x8833
	DRAW_BUFFER15                                 = 0x8834
	BLEND_EQUATION_ALPHA                          = 0x883D
	TEXTURE_DEPTH_SIZE                            = 0x884A
	DEPTH_TEXTURE_MODE                            = 0x884B
	TEXTURE_COMPARE_MODE                          = 0x884C
	TEXTURE_COMPARE_FUNC                          = 0x884D
	COMPARE_R_TO_TEXTURE                          = 0x884E
	COMPARE_REF_TO_TEXTURE                        = 0x884E
	POINT_SPRITE                                  = 0x8861
	COORD_REPLACE                                 = 0x8862
	QUERY_COUNTER_BITS                            = 0x8864
	CURRENT_QUERY                                 = 0x8865
	QUERY_RESULT                                  = 0x8866
	QUERY_RESULT_AVAILABLE                        = 0x8867
	MAX_VERTEX_ATTRIBS                            = 0x8869
	VERTEX_ATTRIB_ARRAY_NORMALIZED                = 0x886A
	MAX_TEXTURE_COORDS                            = 0x8871
	MAX_TEXTURE_IMAGE_UNITS                       = 0x8872
	ARRAY_BUFFER                                  = 0x8892
	ELEMENT_ARRAY_BUFFER                          = 0x8893
	ARRAY_BUFFER_BINDING                          = 0x8894
	ELEMENT_ARRAY_BUFFER_BINDING                  = 0x8895
	VERTEX_ARRAY_BUFFER_BINDING                   = 0x8896
	NORMAL_ARRAY_BUFFER_BINDING                   = 0x8897
	COLOR_ARRAY_BUFFER_BINDING                    = 0x8898
	INDEX_ARRAY_BUFFER_BINDING                    = 0x8899
	TEXTURE_COORD_ARRAY_BUFFER_BINDING            = 0x889A
	EDGE_FLAG_ARRAY_BUFFER_BINDING                = 0x889B
	SECONDARY_COLOR_ARRAY_BUFFER_BINDING          = 0x889C
	FOG_COORDINATE_ARRAY_BUFFER_BINDING           = 0x889D
	FOG_COORD_ARRAY_BUFFER_BINDING                = 0x889D
	WEIGHT_ARRAY_BUFFER_BINDING                   = 0x889E
	VERTEX_ATTRIB_ARRAY_BUFFER_BINDING            = 0x889F
	READ_ONLY                                     = 0x88B8
	WRITE_ONLY                                    = 0x88B9
	READ_WRITE                                    = 0x88BA
	BUFFER_ACCESS                                 = 0x88BB
	BUFFER_MAPPED                                 = 0x88BC
	BUFFER_MAP_POINTER                            = 0x88BD
	STREAM_DRAW                                   = 0x88E0
	STREAM_READ                                   = 0x88E1
	STREAM_COPY                                   = 0x88E2
	STATIC_DRAW                                   = 0x88E4
	STATIC_READ                                   = 0x88E5
	STATIC_COPY                                   = 0x88E6
	DYNAMIC_DRAW                                  = 0x88E8
	DYNAMIC_READ                                  = 0x88E9
	DYNAMIC_COPY                                  = 0x88EA
	PIXEL_PACK_BUFFER                             = 0x88EB
	PIXEL_UNPACK_BUFFER                           = 0x88EC
	PIXEL_PACK_BUFFER_BINDING                     = 0x88ED
	PIXEL_UNPACK_BUFFER_BINDING                   = 0x88EF
	DEPTH24_STENCIL8                              = 0x88F0
	TEXTURE_STENCIL_SIZE                          = 0x88F1
	VERTEX_ATTRIB_ARRAY_INTEGER                   = 0x88FD
	MAX_ARRAY_TEXTURE_LAYERS                      = 0x88FF
	MIN_PROGRAM_TEXEL_OFFSET                      = 0x8904
	MAX_PROGRAM_TEXEL_OFFSET                      = 0x8905
	SAMPLES_PASSED                                = 0x8914
	CLAMP_VERTEX_COLOR                            = 0x891A
	CLAMP_FRAGMENT_COLOR                          = 0x891B
	CLAMP_READ_COLOR                              = 0x891C
	FIXED_ONLY                                    = 0x891D
	FRAGMENT_SHADER                               = 0x8B30
	VERTEX_SHADER                                 = 0x8B31
	MAX_FRAGMENT_UNIFORM_COMPONENTS               = 0x8B49
	MAX_VERTEX_UNIFORM_COMPONENTS                 = 0x8B4A
	MAX_VARYING_FLOATS                            = 0x8B4B
	MAX_VARYING_COMPONENTS                        = 0x8B4B
	MAX_VERTEX_TEXTURE_IMAGE_UNITS                = 0x8B4C
	MAX_COMBINED_TEXTURE_IMAGE_UNITS              = 0x8B4D
	SHADER_TYPE                                   = 0x8B4F
	FLOAT_VEC2                                    = 0x8B50
	FLOAT_VEC3                                    = 0x8B51
	FLOAT_VEC4                                    = 0x8B52
	INT_VEC2                                      = 0x8B53
	INT_VEC3                                      = 0x8B54
	INT_VEC4                                      = 0x8B55
	BOOL                                          = 0x8B56
	BOOL_VEC2                                     = 0x8B57
	BOOL_VEC3                                     = 0x8B58
	BOOL_VEC4                                     = 0x8B59
	FLOAT_MAT2                                    = 0x8B5A
	FLOAT_MAT3                                    = 0x8B5B
	FLOAT_MAT4                                    = 0x8B5C
	SAMPLER_1D                                    = 0x8B5D
	SAMPLER_2D                                    = 0x8B5E
	SAMPLER_3D                                    = 0x8B5F
	SAMPLER_CUBE                                  = 0x8B60
	SAMPLER_1D_SHADOW                             = 0x8B61
	SAMPLER_2D_SHADOW                             = 0x8B62
	FLOAT_MAT2x3                                  = 0x8B65
	FLOAT_MAT2x4                                  = 0x8B66
	FLOAT_MAT3x2                                  = 0x8B67
	FLOAT_MAT3x4                                  = 0x8B68
	FLOAT_MAT4x2                                  = 0x8B69
	FLOAT_MAT4x3                                  = 0x8B6A
	DELETE_STATUS                                 = 0x8B80
	COMPILE_STATUS                                = 0x8B81
	LINK_STATUS                                   = 0x8B82
	VALIDATE_STATUS                               = 0x8B83
	INFO_LOG_LENGTH                               = 0x8B84
	ATTACHED_SHADERS                              = 0x8B85
	ACTIVE_UNIFORMS                               = 0x8B86
	ACTIVE_UNIFORM_MAX_LENGTH                     = 0x8B87
	SHADER_SOURCE_LENGTH                          = 0x8B88
	ACTIVE_ATTRIBUTES                             = 0x8B89
	ACTIVE_ATTRIBUTE_MAX_LENGTH                   = 0x8B8A
	SHADING_LANGUAGE_VERSION                      = 0x8B8C
	CURRENT_PROGRAM                               = 0x8B8D
	TEXTURE_RED_TYPE                              = 0x8C10
	TEXTURE_GREEN_TYPE                            = 0x8C11
	TEXTURE_BLUE_TYPE                             = 0x8C12
	TEXTURE_ALPHA_TYPE                            = 0x8C13
	TEXTURE_DEPTH_TYPE                            = 0x8C16
	UNSIGNED_NORMALIZED                           = 0x8C17
	TEXTURE_1D_ARRAY                              = 0x8C18
	PROXY_TEXTURE_1D_ARRAY                        = 0x8C19
	TEXTURE_2D_ARRAY                              = 0x8C1A
	PROXY_TEXTURE_2D_ARRAY                        = 0x8C1B
	TEXTURE_BINDING_1D_ARRAY                      = 0x8C1C
	TEXTURE_BINDING_2D_ARRAY                      = 0x8C1D
	R11F_G11F_B10F                                = 0x8C3A
	UNSIGNED_INT_10F_11F_11F_REV                  = 0x8C3B
	RGB9_E5                                       = 0x8C3D
	UNSIGNED_INT_5_9_9_9_REV                      = 0x8C3E
	TEXTURE_SHARED_SIZE                           = 0x8C3F
	SRGB                                          = 0x8C40
	SRGB8                                         = 0x8C41
	SRGB_ALPHA                                    = 0x8C42
	SRGB8_ALPHA8                                  = 0x8C43
	SLUMINANCE_ALPHA                              = 0x8C44
	SLUMINANCE8_ALPHA8                            = 0x8C45
	SLUMINANCE                                    = 0x8C46
	SLUMINANCE8                                   = 0x8C47
	COMPRESSED_SRGB                               = 0x8C48
	COMPRESSED_SRGB_ALPHA                         = 0x8C49
	COMPRESSED_SLUMINANCE                         = 0x8C4A
	COMPRESSED_SLUMINANCE_ALPHA                   = 0x8C4B
	TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH         = 0x8C76
	TRANSFORM_FEEDBACK_BUFFER_MODE                = 0x8C7F
	MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS    = 0x8C80
	TRANSFORM_FEEDBACK_VARYINGS                   = 0x8C83
	TRANSFORM_FEEDBACK_BUFFER_START               = 0x8C84
	TRANSFORM_FEEDBACK_BUFFER_SIZE                = 0x8C85
	PRIMITIVES_GENERATED                          = 0x8C87
	TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN         = 0x8C88
	RASTERIZER_DISCARD                            = 0x8C89
	MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 0x8C8A
	MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS       = 0x8C8B
	INTERLEAVED_ATTRIBS                           = 0x8C8C
	SEPARATE_ATTRIBS                              = 0x8C8D
	TRANSFORM_FEEDBACK_BUFFER                     = 0x8C8E
	TRANSFORM_FEEDBACK_BUFFER_BINDING             = 0x8C8F
	POINT_SPRITE_COORD_ORIGIN                     = 0x8CA0
	LOWER_LEFT                                    = 0x8CA1
	UPPER_LEFT                                    = 0x8CA2
	STENCIL_BACK_REF                              = 0x8CA3
	STENCIL_BACK_VALUE_MASK                       = 0x8CA4
	STENCIL_BACK_WRITEMASK                        = 0x8CA5
	DRAW_FRAMEBUFFER_BINDING                      = 0x8CA6
	FRAMEBUFFER_BINDING                           = 0x8CA6
	RENDERBUFFER_BINDING                          = 0x8CA7
	READ_FRAMEBUFFER                              = 0x8CA8
	DRAW_FRAMEBUFFER                              = 0x8CA9
	READ_FRAMEBUFFER_BINDING                      = 0x8CAA
	RENDERBUFFER_SAMPLES                          = 0x8CAB
	DEPTH_COMPONENT32F                            = 0x8CAC
	DEPTH32F_STENCIL8                             = 0x8CAD
	FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE            = 0x8CD0
	FRAMEBUFFER_ATTACHMENT_OBJECT_NAME            = 0x8CD1
	FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL          = 0x8CD2
	FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE  = 0x8CD3
	FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER          = 0x8CD4
	FRAMEBUFFER_COMPLETE                          = 0x8CD5
	FRAMEBUFFER_INCOMPLETE_ATTACHMENT             = 0x8CD6
	FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT     = 0x8CD7
	FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER            = 0x8CDB
	FRAMEBUFFER_INCOMPLETE_READ_BUFFER            = 0x8CDC
	FRAMEBUFFER_UNSUPPORTED                       = 0x8CDD
	MAX_COLOR_ATTACHMENTS                         = 0x8CDF
	COLOR_ATTACHMENT0                             = 0x8CE0
	COLOR_ATTACHMENT1                             = 0x8CE1
	COLOR_ATTACHMENT2                             = 0x8CE2
	COLOR_ATTACHMENT3                             = 0x8CE3
	COLOR_ATTACHMENT4                             = 0x8CE4
	COLOR_ATTACHMENT5                             = 0x8CE5
	COLOR_ATTACHMENT6                             = 0x8CE6
	COLOR_ATTACHMENT7                             = 0x8CE7
	COLOR_ATTACHMENT8                             = 0x8CE8
	COLOR_ATTACHMENT9                             = 0x8CE9
	COLOR_ATTACHMENT10                            = 0x8CEA
	COLOR_ATTACHMENT11                            = 0x8CEB
	COLOR_ATTACHMENT12                            = 0x8CEC
	COLOR_ATTACHMENT13                            = 0x8CED
	COLOR_ATTACHMENT14                            = 0x8CEE
	COLOR_ATTACHMENT15                            = 0x8CEF
	DEPTH_ATTACHMENT                              = 0x8D00
	STENCIL_ATTACHMENT                            = 0x8D20
	FRAMEBUFFER                                   = 0x8D40
	RENDERBUFFER                                  = 0x8D41
	RENDERBUFFER_WIDTH                            = 0x8D42
	RENDERBUFFER_HEIGHT                           = 0x8D43
	RENDERBUFFER_INTERNAL_FORMAT                  = 0x8D44
	STENCIL_INDEX1                                = 0x8D46
	STENCIL_INDEX4                                = 0x8D47
	STENCIL_INDEX8                                = 0x8D48
	STENCIL_INDEX16                               = 0x8D49
	RENDERBUFFER_RED_SIZE                         = 0x8D50
	RENDERBUFFER_GREEN_SIZE                       = 0x8D51
	RENDERBUFFER_BLUE_SIZE                        = 0x8D52
	RENDERBUFFER_ALPHA_SIZE                       = 0x8D53
	RENDERBUFFER_DEPTH_SIZE                       = 0x8D54
	RENDERBUFFER_STENCIL_SIZE                     = 0x8D55
	FRAMEBUFFER_INCOMPLETE_MULTISAMPLE            = 0x8D56
	MAX_SAMPLES                                   = 0x8D57
	RGBA32UI                                      = 0x8D70
	RGB32UI                                       = 0x8D71
	RGBA16UI                                      = 0x8D76
	RGB16UI                                       = 0x8D77
	RGBA8UI                                       = 0x8D7C
	RGB8UI                                        = 0x8D7D
	RGBA32I                                       = 0x8D82
	RGB32I                                        = 0x8D83
	RGBA16I                                       = 0x8D88
	RGB16I                                        = 0x8D89
	RGBA8I                                        = 0x8D8E
	RGB8I                                         = 0x8D8F
	RED_INTEGER                                   = 0x8D94
	GREEN_INTEGER                                 = 0x8D95
	BLUE_INTEGER                                  = 0x8D96
	ALPHA_INTEGER                                 = 0x8D97
	RGB_INTEGER                                   = 0x8D98
	RGBA_INTEGER                                  = 0x8D99
	BGR_INTEGER                                   = 0x8D9A
	BGRA_INTEGER                                  = 0x8D9B
	FLOAT_32_UNSIGNED_INT_24_8_REV                = 0x8DAD
	FRAMEBUFFER_SRGB                              = 0x8DB9
	COMPRESSED_RED_RGTC1                          = 0x8DBB
	COMPRESSED_SIGNED_RED_RGTC1                   = 0x8DBC
	COMPRESSED_RG_RGTC2                           = 0x8DBD
	COMPRESSED_SIGNED_RG_RGTC2                    = 0x8DBE
	SAMPLER_1D_ARRAY                              = 0x8DC0
	SAMPLER_2D_ARRAY                              = 0x8DC1
	SAMPLER_1D_ARRAY_SHADOW                       = 0x8DC3
	SAMPLER_2D_ARRAY_SHADOW                       = 0x8DC4
	SAMPLER_CUBE_SHADOW                           = 0x8DC5
	UNSIGNED_INT_VEC2                             = 0x8DC6
	UNSIGNED_INT_VEC3                             = 0x8DC7
	UNSIGNED_INT_VEC4                             = 0x8DC8
	INT_SAMPLER_1D                                = 0x8DC9
	INT_SAMPLER_2D                                = 0x8DCA
	INT_SAMPLER_3D                                = 0x8DCB
	INT_SAMPLER_CUBE                              = 0x8DCC
	INT_SAMPLER_1D_ARRAY                          = 0x8DCE
	INT_SAMPLER_2D_ARRAY                          = 0x8DCF
	UNSIGNED_INT_SAMPLER_1D                       = 0x8DD1
	UNSIGNED_INT_SAMPLER_2D                       = 0x8DD2
	UNSIGNED_INT_SAMPLER_3D                       = 0x8DD3
	UNSIGNED_INT_SAMPLER_CUBE                     = 0x8DD4
	UNSIGNED_INT_SAMPLER_1D_ARRAY                 = 0x8DD6
	UNSIGNED_INT_SAMPLER_2D_ARRAY                 = 0x8DD7
	QUERY_WAIT                                    = 0x8E13
	QUERY_NO_WAIT                                 = 0x8E14
	QUERY_BY_REGION_WAIT                          = 0x8E15
	QUERY_BY_REGION_NO_WAIT                       = 0x8E16
	BUFFER_ACCESS_FLAGS                           = 0x911F
	BUFFER_MAP_LENGTH                             = 0x9120
	BUFFER_MAP_OFFSET                             = 0x9121
)

// https://www.opengl.org/sdk/docs/man3/xhtml/glViewport.xml
func (gl *GL) Viewport(x, y, width, height int) {
	C.gl3_0_glViewport(gl.funcs, C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height))
}

// DepthRange specifies the mapping of depth values from normalized device
// coordinates to window coordinates.
//
// Parameter nearVal specifies the mapping of the near clipping plane to window
// coordinates (defaults to 0), while farVal specifies the mapping of the far
// clipping plane to window coordinates (defaults to 1).
//
// After clipping and division by w, depth coordinates range from -1 to 1,
// corresponding to the near and far clipping planes. DepthRange specifies a
// linear mapping of the normalized depth coordinates in this range to window
// depth coordinates. Regardless of the actual depth buffer implementation,
// window coordinate depth values are treated as though they range from 0 through 1
// (like color components). Thus, the values accepted by DepthRange are both
// clamped to this range before they are accepted.
//
// The default setting of (0, 1) maps the near plane to 0 and the far plane to 1.
// With this mapping, the depth buffer range is fully utilized.
//
// It is not necessary that nearVal be less than farVal. Reverse mappings such as
// nearVal 1, and farVal 0 are acceptable.
//
// GL.INVALID_OPERATION is generated if DepthRange is executed between the
// execution of Begin and the corresponding execution of End.
func (gl *GL) DepthRange(nearVal, farVal float64) {
	C.gl3_0_glDepthRange(gl.funcs, C.GLdouble(nearVal), C.GLdouble(farVal))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glIsEnabled.xml
func (gl *GL) IsEnabled(cap glbase.Enum) bool {
	glresult := C.gl3_0_glIsEnabled(gl.funcs, C.GLenum(cap))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetTexLevelParameteriv.xml
func (gl *GL) GetTexLevelParameteriv(target glbase.Enum, level int, pname glbase.Enum, params []int32) {
	C.gl3_0_glGetTexLevelParameteriv(gl.funcs, C.GLenum(target), C.GLint(level), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetTexLevelParameterfv.xml
func (gl *GL) GetTexLevelParameterfv(target glbase.Enum, level int, pname glbase.Enum, params []float32) {
	C.gl3_0_glGetTexLevelParameterfv(gl.funcs, C.GLenum(target), C.GLint(level), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetTexParameteriv.xml
func (gl *GL) GetTexParameteriv(target, pname glbase.Enum, params []int32) {
	C.gl3_0_glGetTexParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetTexParameterfv.xml
func (gl *GL) GetTexParameterfv(target, pname glbase.Enum, params []float32) {
	C.gl3_0_glGetTexParameterfv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetTexImage.xml
func (gl *GL) GetTexImage(target glbase.Enum, level int, format, gltype glbase.Enum, pixels interface{}) {
	var pixels_ptr unsafe.Pointer
	var pixels_v = reflect.ValueOf(pixels)
	if pixels != nil && pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	if pixels != nil {
		pixels_ptr = unsafe.Pointer(pixels_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glGetTexImage(gl.funcs, C.GLenum(target), C.GLint(level), C.GLenum(format), C.GLenum(gltype), pixels_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetIntegerv.xml
func (gl *GL) GetIntegerv(pname glbase.Enum, params []int32) {
	C.gl3_0_glGetIntegerv(gl.funcs, C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetFloatv.xml
func (gl *GL) GetFloatv(pname glbase.Enum, params []float32) {
	C.gl3_0_glGetFloatv(gl.funcs, C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetError.xml
func (gl *GL) GetError() glbase.Enum {
	glresult := C.gl3_0_glGetError(gl.funcs)
	return glbase.Enum(glresult)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetDoublev.xml
func (gl *GL) GetDoublev(pname glbase.Enum, params []float64) {
	C.gl3_0_glGetDoublev(gl.funcs, C.GLenum(pname), (*C.GLdouble)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetBooleanv.xml
func (gl *GL) GetBooleanv(pname glbase.Enum, params []bool) {
	C.gl3_0_glGetBooleanv(gl.funcs, C.GLenum(pname), (*C.GLboolean)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glReadPixels.xml
func (gl *GL) ReadPixels(x, y, width, height int, format, gltype glbase.Enum, pixels interface{}) {
	var pixels_ptr unsafe.Pointer
	var pixels_v = reflect.ValueOf(pixels)
	if pixels != nil && pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	if pixels != nil {
		pixels_ptr = unsafe.Pointer(pixels_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glReadPixels(gl.funcs, C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height), C.GLenum(format), C.GLenum(gltype), pixels_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glReadBuffer.xml
func (gl *GL) ReadBuffer(mode glbase.Enum) {
	C.gl3_0_glReadBuffer(gl.funcs, C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glPixelStorei.xml
func (gl *GL) PixelStorei(pname glbase.Enum, param int32) {
	C.gl3_0_glPixelStorei(gl.funcs, C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glPixelStoref.xml
func (gl *GL) PixelStoref(pname glbase.Enum, param float32) {
	C.gl3_0_glPixelStoref(gl.funcs, C.GLenum(pname), C.GLfloat(param))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glDepthFunc.xml
func (gl *GL) DepthFunc(glfunc glbase.Enum) {
	C.gl3_0_glDepthFunc(gl.funcs, C.GLenum(glfunc))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glStencilOp.xml
func (gl *GL) StencilOp(fail, zfail, zpass glbase.Enum) {
	C.gl3_0_glStencilOp(gl.funcs, C.GLenum(fail), C.GLenum(zfail), C.GLenum(zpass))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glStencilFunc.xml
func (gl *GL) StencilFunc(glfunc glbase.Enum, ref int32, mask uint32) {
	C.gl3_0_glStencilFunc(gl.funcs, C.GLenum(glfunc), C.GLint(ref), C.GLuint(mask))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glLogicOp.xml
func (gl *GL) LogicOp(opcode glbase.Enum) {
	C.gl3_0_glLogicOp(gl.funcs, C.GLenum(opcode))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glBlendFunc.xml
func (gl *GL) BlendFunc(sfactor, dfactor glbase.Enum) {
	C.gl3_0_glBlendFunc(gl.funcs, C.GLenum(sfactor), C.GLenum(dfactor))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glFlush.xml
func (gl *GL) Flush() {
	C.gl3_0_glFlush(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glFinish.xml
func (gl *GL) Finish() {
	C.gl3_0_glFinish(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glEnable.xml
func (gl *GL) Enable(cap glbase.Enum) {
	C.gl3_0_glEnable(gl.funcs, C.GLenum(cap))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glDisable.xml
func (gl *GL) Disable(cap glbase.Enum) {
	C.gl3_0_glDisable(gl.funcs, C.GLenum(cap))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glDepthMask.xml
func (gl *GL) DepthMask(flag bool) {
	C.gl3_0_glDepthMask(gl.funcs, *(*C.GLboolean)(unsafe.Pointer(&flag)))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColorMask.xml
func (gl *GL) ColorMask(red, green, blue, alpha bool) {
	C.gl3_0_glColorMask(gl.funcs, *(*C.GLboolean)(unsafe.Pointer(&red)), *(*C.GLboolean)(unsafe.Pointer(&green)), *(*C.GLboolean)(unsafe.Pointer(&blue)), *(*C.GLboolean)(unsafe.Pointer(&alpha)))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glStencilMask.xml
func (gl *GL) StencilMask(mask uint32) {
	C.gl3_0_glStencilMask(gl.funcs, C.GLuint(mask))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glClearDepth.xml
func (gl *GL) ClearDepth(depth float64) {
	C.gl3_0_glClearDepth(gl.funcs, C.GLdouble(depth))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glClearStencil.xml
func (gl *GL) ClearStencil(s int32) {
	C.gl3_0_glClearStencil(gl.funcs, C.GLint(s))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glClearColor.xml
func (gl *GL) ClearColor(red, green, blue, alpha float32) {
	C.gl3_0_glClearColor(gl.funcs, C.GLfloat(red), C.GLfloat(green), C.GLfloat(blue), C.GLfloat(alpha))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glClear.xml
func (gl *GL) Clear(mask glbase.Bitfield) {
	C.gl3_0_glClear(gl.funcs, C.GLbitfield(mask))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glDrawBuffer.xml
func (gl *GL) DrawBuffer(mode glbase.Enum) {
	C.gl3_0_glDrawBuffer(gl.funcs, C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexImage2D.xml
func (gl *GL) TexImage2D(target glbase.Enum, level int, internalFormat int32, width, height, border int, format, gltype glbase.Enum, pixels interface{}) {
	var pixels_ptr unsafe.Pointer
	var pixels_v = reflect.ValueOf(pixels)
	if pixels != nil && pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	if pixels != nil {
		pixels_ptr = unsafe.Pointer(pixels_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glTexImage2D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(internalFormat), C.GLsizei(width), C.GLsizei(height), C.GLint(border), C.GLenum(format), C.GLenum(gltype), pixels_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexImage1D.xml
func (gl *GL) TexImage1D(target glbase.Enum, level int, internalFormat int32, width, border int, format, gltype glbase.Enum, pixels interface{}) {
	var pixels_ptr unsafe.Pointer
	var pixels_v = reflect.ValueOf(pixels)
	if pixels != nil && pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	if pixels != nil {
		pixels_ptr = unsafe.Pointer(pixels_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glTexImage1D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(internalFormat), C.GLsizei(width), C.GLint(border), C.GLenum(format), C.GLenum(gltype), pixels_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexParameteriv.xml
func (gl *GL) TexParameteriv(target, pname glbase.Enum, params []int32) {
	C.gl3_0_glTexParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexParameteri.xml
func (gl *GL) TexParameteri(target, pname glbase.Enum, param int32) {
	C.gl3_0_glTexParameteri(gl.funcs, C.GLenum(target), C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexParameterfv.xml
func (gl *GL) TexParameterfv(target, pname glbase.Enum, params []float32) {
	C.gl3_0_glTexParameterfv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexParameterf.xml
func (gl *GL) TexParameterf(target, pname glbase.Enum, param float32) {
	C.gl3_0_glTexParameterf(gl.funcs, C.GLenum(target), C.GLenum(pname), C.GLfloat(param))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glScissor.xml
func (gl *GL) Scissor(x, y, width, height int) {
	C.gl3_0_glScissor(gl.funcs, C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glPolygonMode.xml
func (gl *GL) PolygonMode(face, mode glbase.Enum) {
	C.gl3_0_glPolygonMode(gl.funcs, C.GLenum(face), C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glPointSize.xml
func (gl *GL) PointSize(size float32) {
	C.gl3_0_glPointSize(gl.funcs, C.GLfloat(size))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glLineWidth.xml
func (gl *GL) LineWidth(width float32) {
	C.gl3_0_glLineWidth(gl.funcs, C.GLfloat(width))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glHint.xml
func (gl *GL) Hint(target, mode glbase.Enum) {
	C.gl3_0_glHint(gl.funcs, C.GLenum(target), C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glFrontFace.xml
func (gl *GL) FrontFace(mode glbase.Enum) {
	C.gl3_0_glFrontFace(gl.funcs, C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glCullFace.xml
func (gl *GL) CullFace(mode glbase.Enum) {
	C.gl3_0_glCullFace(gl.funcs, C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glIndexubv.xml
func (gl *GL) Indexubv(c []uint8) {
	C.gl3_0_glIndexubv(gl.funcs, (*C.GLubyte)(unsafe.Pointer(&c[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glIndexub.xml
func (gl *GL) Indexub(c uint8) {
	C.gl3_0_glIndexub(gl.funcs, C.GLubyte(c))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glIsTexture.xml
func (gl *GL) IsTexture(texture glbase.Texture) bool {
	glresult := C.gl3_0_glIsTexture(gl.funcs, C.GLuint(texture))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// GenTextures returns n texture names in textures. There is no guarantee
// that the names form a contiguous set of integers; however, it is
// guaranteed that none of the returned names was in use immediately before
// the call to GenTextures.
//
// The generated textures have no dimensionality; they assume the
// dimensionality of the texture target to which they are first bound (see
// BindTexture).
//
// Texture names returned by a call to GenTextures are not returned by
// subsequent calls, unless they are first deleted with DeleteTextures.
//
// Error GL.INVALID_VALUE is generated if n is negative.
//
// GenTextures is available in GL version 2.0 or greater.
func (gl *GL) GenTextures(n int) []glbase.Texture {
	if n == 0 {
		return nil
	}
	textures := make([]glbase.Texture, n)
	C.gl3_0_glGenTextures(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&textures[0])))
	return textures
}

// DeleteTextures deletes the textures objects whose names are stored
// in the textures slice. After a texture is deleted, it has no contents or
// dimensionality, and its name is free for reuse (for example by
// GenTextures). If a texture that is currently bound is deleted, the binding
// reverts to 0 (the default texture).
//
// DeleteTextures silently ignores 0's and names that do not correspond to
// existing textures.
//
// Error GL.INVALID_VALUE is generated if n is negative.
//
// DeleteTextures is available in GL version 2.0 or greater.
func (gl *GL) DeleteTextures(textures []glbase.Texture) {
	n := len(textures)
	if n == 0 {
		return
	}
	C.gl3_0_glDeleteTextures(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&textures[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glBindTexture.xml
func (gl *GL) BindTexture(target glbase.Enum, texture glbase.Texture) {
	C.gl3_0_glBindTexture(gl.funcs, C.GLenum(target), C.GLuint(texture))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexSubImage2D.xml
func (gl *GL) TexSubImage2D(target glbase.Enum, level, xoffset, yoffset, width, height int, format, gltype glbase.Enum, pixels interface{}) {
	var pixels_ptr unsafe.Pointer
	var pixels_v = reflect.ValueOf(pixels)
	if pixels != nil && pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	if pixels != nil {
		pixels_ptr = unsafe.Pointer(pixels_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glTexSubImage2D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLint(yoffset), C.GLsizei(width), C.GLsizei(height), C.GLenum(format), C.GLenum(gltype), pixels_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexSubImage1D.xml
func (gl *GL) TexSubImage1D(target glbase.Enum, level, xoffset, width int, format, gltype glbase.Enum, pixels interface{}) {
	var pixels_ptr unsafe.Pointer
	var pixels_v = reflect.ValueOf(pixels)
	if pixels != nil && pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	if pixels != nil {
		pixels_ptr = unsafe.Pointer(pixels_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glTexSubImage1D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLsizei(width), C.GLenum(format), C.GLenum(gltype), pixels_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glCopyTexSubImage2D.xml
func (gl *GL) CopyTexSubImage2D(target glbase.Enum, level, xoffset, yoffset, x, y, width, height int) {
	C.gl3_0_glCopyTexSubImage2D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLint(yoffset), C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glCopyTexSubImage1D.xml
func (gl *GL) CopyTexSubImage1D(target glbase.Enum, level, xoffset, x, y, width int) {
	C.gl3_0_glCopyTexSubImage1D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLint(x), C.GLint(y), C.GLsizei(width))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glCopyTexImage2D.xml
func (gl *GL) CopyTexImage2D(target glbase.Enum, level int, internalFormat glbase.Enum, x, y, width, height, border int) {
	C.gl3_0_glCopyTexImage2D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLenum(internalFormat), C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height), C.GLint(border))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glCopyTexImage1D.xml
func (gl *GL) CopyTexImage1D(target glbase.Enum, level int, internalFormat glbase.Enum, x, y, width, border int) {
	C.gl3_0_glCopyTexImage1D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLenum(internalFormat), C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLint(border))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glPolygonOffset.xml
func (gl *GL) PolygonOffset(factor, units float32) {
	C.gl3_0_glPolygonOffset(gl.funcs, C.GLfloat(factor), C.GLfloat(units))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glDrawElements.xml
func (gl *GL) DrawElements(mode glbase.Enum, count int, gltype glbase.Enum, indices interface{}) {
	var indices_ptr unsafe.Pointer
	var indices_v = reflect.ValueOf(indices)
	if indices != nil && indices_v.Kind() != reflect.Slice {
		panic("parameter indices must be a slice")
	}
	if indices != nil {
		indices_ptr = unsafe.Pointer(indices_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glDrawElements(gl.funcs, C.GLenum(mode), C.GLsizei(count), C.GLenum(gltype), indices_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glDrawArrays.xml
func (gl *GL) DrawArrays(mode glbase.Enum, first, count int) {
	C.gl3_0_glDrawArrays(gl.funcs, C.GLenum(mode), C.GLint(first), C.GLsizei(count))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glCopyTexSubImage3D.xml
func (gl *GL) CopyTexSubImage3D(target glbase.Enum, level, xoffset, yoffset int, zoffset int32, x, y, width, height int) {
	C.gl3_0_glCopyTexSubImage3D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLint(yoffset), C.GLint(zoffset), C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexSubImage3D.xml
func (gl *GL) TexSubImage3D(target glbase.Enum, level, xoffset, yoffset int, zoffset int32, width, height int, depth int32, format, gltype glbase.Enum, pixels interface{}) {
	var pixels_ptr unsafe.Pointer
	var pixels_v = reflect.ValueOf(pixels)
	if pixels != nil && pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	if pixels != nil {
		pixels_ptr = unsafe.Pointer(pixels_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glTexSubImage3D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLint(yoffset), C.GLint(zoffset), C.GLsizei(width), C.GLsizei(height), C.GLsizei(depth), C.GLenum(format), C.GLenum(gltype), pixels_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexImage3D.xml
func (gl *GL) TexImage3D(target glbase.Enum, level int, internalFormat int32, width, height int, depth int32, border int, format, gltype glbase.Enum, pixels interface{}) {
	var pixels_ptr unsafe.Pointer
	var pixels_v = reflect.ValueOf(pixels)
	if pixels != nil && pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	if pixels != nil {
		pixels_ptr = unsafe.Pointer(pixels_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glTexImage3D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(internalFormat), C.GLsizei(width), C.GLsizei(height), C.GLsizei(depth), C.GLint(border), C.GLenum(format), C.GLenum(gltype), pixels_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glDrawRangeElements.xml
func (gl *GL) DrawRangeElements(mode glbase.Enum, start, end uint32, count int, gltype glbase.Enum, indices interface{}) {
	var indices_ptr unsafe.Pointer
	var indices_v = reflect.ValueOf(indices)
	if indices != nil && indices_v.Kind() != reflect.Slice {
		panic("parameter indices must be a slice")
	}
	if indices != nil {
		indices_ptr = unsafe.Pointer(indices_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glDrawRangeElements(gl.funcs, C.GLenum(mode), C.GLuint(start), C.GLuint(end), C.GLsizei(count), C.GLenum(gltype), indices_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glBlendEquation.xml
func (gl *GL) BlendEquation(mode glbase.Enum) {
	C.gl3_0_glBlendEquation(gl.funcs, C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glBlendColor.xml
func (gl *GL) BlendColor(red, green, blue, alpha float32) {
	C.gl3_0_glBlendColor(gl.funcs, C.GLfloat(red), C.GLfloat(green), C.GLfloat(blue), C.GLfloat(alpha))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetCompressedTexImage.xml
func (gl *GL) GetCompressedTexImage(target glbase.Enum, level int, img interface{}) {
	var img_ptr unsafe.Pointer
	var img_v = reflect.ValueOf(img)
	if img != nil && img_v.Kind() != reflect.Slice {
		panic("parameter img must be a slice")
	}
	if img != nil {
		img_ptr = unsafe.Pointer(img_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glGetCompressedTexImage(gl.funcs, C.GLenum(target), C.GLint(level), img_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glCompressedTexSubImage1D.xml
func (gl *GL) CompressedTexSubImage1D(target glbase.Enum, level, xoffset, width int, format glbase.Enum, imageSize int, data interface{}) {
	var data_ptr unsafe.Pointer
	var data_v = reflect.ValueOf(data)
	if data != nil && data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	if data != nil {
		data_ptr = unsafe.Pointer(data_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glCompressedTexSubImage1D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLsizei(width), C.GLenum(format), C.GLsizei(imageSize), data_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glCompressedTexSubImage2D.xml
func (gl *GL) CompressedTexSubImage2D(target glbase.Enum, level, xoffset, yoffset, width, height int, format glbase.Enum, imageSize int, data interface{}) {
	var data_ptr unsafe.Pointer
	var data_v = reflect.ValueOf(data)
	if data != nil && data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	if data != nil {
		data_ptr = unsafe.Pointer(data_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glCompressedTexSubImage2D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLint(yoffset), C.GLsizei(width), C.GLsizei(height), C.GLenum(format), C.GLsizei(imageSize), data_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glCompressedTexSubImage3D.xml
func (gl *GL) CompressedTexSubImage3D(target glbase.Enum, level, xoffset, yoffset int, zoffset int32, width, height int, depth int32, format glbase.Enum, imageSize int, data interface{}) {
	var data_ptr unsafe.Pointer
	var data_v = reflect.ValueOf(data)
	if data != nil && data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	if data != nil {
		data_ptr = unsafe.Pointer(data_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glCompressedTexSubImage3D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLint(yoffset), C.GLint(zoffset), C.GLsizei(width), C.GLsizei(height), C.GLsizei(depth), C.GLenum(format), C.GLsizei(imageSize), data_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glCompressedTexImage1D.xml
func (gl *GL) CompressedTexImage1D(target glbase.Enum, level int, internalFormat glbase.Enum, width, border, imageSize int, data interface{}) {
	var data_ptr unsafe.Pointer
	var data_v = reflect.ValueOf(data)
	if data != nil && data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	if data != nil {
		data_ptr = unsafe.Pointer(data_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glCompressedTexImage1D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLenum(internalFormat), C.GLsizei(width), C.GLint(border), C.GLsizei(imageSize), data_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glCompressedTexImage2D.xml
func (gl *GL) CompressedTexImage2D(target glbase.Enum, level int, internalFormat glbase.Enum, width, height, border, imageSize int, data interface{}) {
	var data_ptr unsafe.Pointer
	var data_v = reflect.ValueOf(data)
	if data != nil && data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	if data != nil {
		data_ptr = unsafe.Pointer(data_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glCompressedTexImage2D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLenum(internalFormat), C.GLsizei(width), C.GLsizei(height), C.GLint(border), C.GLsizei(imageSize), data_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glCompressedTexImage3D.xml
func (gl *GL) CompressedTexImage3D(target glbase.Enum, level int, internalFormat glbase.Enum, width, height int, depth int32, border, imageSize int, data interface{}) {
	var data_ptr unsafe.Pointer
	var data_v = reflect.ValueOf(data)
	if data != nil && data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	if data != nil {
		data_ptr = unsafe.Pointer(data_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glCompressedTexImage3D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLenum(internalFormat), C.GLsizei(width), C.GLsizei(height), C.GLsizei(depth), C.GLint(border), C.GLsizei(imageSize), data_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glSampleCoverage.xml
func (gl *GL) SampleCoverage(value float32, invert bool) {
	C.gl3_0_glSampleCoverage(gl.funcs, C.GLfloat(value), *(*C.GLboolean)(unsafe.Pointer(&invert)))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glActiveTexture.xml
func (gl *GL) ActiveTexture(texture glbase.Enum) {
	C.gl3_0_glActiveTexture(gl.funcs, C.GLenum(texture))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glPointParameteriv.xml
func (gl *GL) PointParameteriv(pname glbase.Enum, params []int32) {
	C.gl3_0_glPointParameteriv(gl.funcs, C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glPointParameteri.xml
func (gl *GL) PointParameteri(pname glbase.Enum, param int32) {
	C.gl3_0_glPointParameteri(gl.funcs, C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glPointParameterfv.xml
func (gl *GL) PointParameterfv(pname glbase.Enum, params []float32) {
	C.gl3_0_glPointParameterfv(gl.funcs, C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glPointParameterf.xml
func (gl *GL) PointParameterf(pname glbase.Enum, param float32) {
	C.gl3_0_glPointParameterf(gl.funcs, C.GLenum(pname), C.GLfloat(param))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiDrawArrays.xml
func (gl *GL) MultiDrawArrays(mode glbase.Enum, first, count []int, drawcount int32) {
	C.gl3_0_glMultiDrawArrays(gl.funcs, C.GLenum(mode), (*C.GLint)(unsafe.Pointer(&first[0])), (*C.GLsizei)(unsafe.Pointer(&count[0])), C.GLsizei(drawcount))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glBlendFuncSeparate.xml
func (gl *GL) BlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha glbase.Enum) {
	C.gl3_0_glBlendFuncSeparate(gl.funcs, C.GLenum(sfactorRGB), C.GLenum(dfactorRGB), C.GLenum(sfactorAlpha), C.GLenum(dfactorAlpha))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetBufferParameteriv.xml
func (gl *GL) GetBufferParameteriv(target, pname glbase.Enum, params []int32) {
	C.gl3_0_glGetBufferParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glUnmapBuffer.xml
func (gl *GL) UnmapBuffer(target glbase.Enum) bool {
	glresult := C.gl3_0_glUnmapBuffer(gl.funcs, C.GLenum(target))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetBufferSubData.xml
func (gl *GL) GetBufferSubData(target glbase.Enum, offset, size int, data interface{}) {
	var data_ptr unsafe.Pointer
	var data_v = reflect.ValueOf(data)
	if data != nil && data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	if data != nil {
		data_ptr = unsafe.Pointer(data_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glGetBufferSubData(gl.funcs, C.GLenum(target), C.GLintptr(offset), C.GLsizeiptr(size), data_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glBufferSubData.xml
func (gl *GL) BufferSubData(target glbase.Enum, offset, size int, data interface{}) {
	var data_ptr unsafe.Pointer
	var data_v = reflect.ValueOf(data)
	if data != nil && data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	if data != nil {
		data_ptr = unsafe.Pointer(data_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glBufferSubData(gl.funcs, C.GLenum(target), C.GLintptr(offset), C.GLsizeiptr(size), data_ptr)
}

// BufferData creates a new data store for the buffer object currently
// bound to target. Any pre-existing data store is deleted. The new data
// store is created with the specified size in bytes and usage. If data is
// not nil, it must be a slice that is used to initialize the data store.
// In that case the size parameter is ignored and the store size will match
// the slice data size.
//
// In its initial state, the new data store is not mapped, it has a NULL
// mapped pointer, and its mapped access is GL.READ_WRITE.
//
// The target constant must be one of GL.ARRAY_BUFFER, GL.COPY_READ_BUFFER,
// GL.COPY_WRITE_BUFFER, GL.ELEMENT_ARRAY_BUFFER, GL.PIXEL_PACK_BUFFER,
// GL.PIXEL_UNPACK_BUFFER, GL.TEXTURE_BUFFER, GL.TRANSFORM_FEEDBACK_BUFFER,
// or GL.UNIFORM_BUFFER.
//
// The usage parameter is a hint to the GL implementation as to how a buffer
// object's data store will be accessed. This enables the GL implementation
// to make more intelligent decisions that may significantly impact buffer
// object performance. It does not, however, constrain the actual usage of
// the data store. usage can be broken down into two parts: first, the
// frequency of access (modification and usage), and second, the nature of
// that access.
//
// A usage frequency of STREAM and nature of DRAW is specified via the
// constant GL.STREAM_DRAW, for example.
//
// The usage frequency of access may be one of:
//
//   STREAM
//       The data store contents will be modified once and used at most a few times.
//
//   STATIC
//       The data store contents will be modified once and used many times.
//
//   DYNAMIC
//       The data store contents will be modified repeatedly and used many times.
//
// The usage nature of access may be one of:
//
//   DRAW
//       The data store contents are modified by the application, and used as
//       the source for GL drawing and image specification commands.
//
//   READ
//       The data store contents are modified by reading data from the GL,
//       and used to return that data when queried by the application.
//
//   COPY
//       The data store contents are modified by reading data from the GL,
//       and used as the source for GL drawing and image specification
//       commands.
//
// Clients must align data elements consistent with the requirements of the
// client platform, with an additional base-level requirement that an offset
// within a buffer to a datum comprising N bytes be a multiple of N.
//
// Error GL.INVALID_ENUM is generated if target is not one of the accepted
// buffer targets.  GL.INVALID_ENUM is generated if usage is not
// GL.STREAM_DRAW, GL.STREAM_READ, GL.STREAM_COPY, GL.STATIC_DRAW,
// GL.STATIC_READ, GL.STATIC_COPY, GL.DYNAMIC_DRAW, GL.DYNAMIC_READ, or
// GL.DYNAMIC_COPY.  GL.INVALID_VALUE is generated if size is negative.
// GL.INVALID_OPERATION is generated if the reserved buffer object name 0 is
// bound to target.  GL.OUT_OF_MEMORY is generated if the GL is unable to
// create a data store with the specified size.
func (gl *GL) BufferData(target glbase.Enum, size int, data interface{}, usage glbase.Enum) {
	var data_ptr unsafe.Pointer
	var data_v = reflect.ValueOf(data)
	if data != nil && data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	if data != nil {
		data_ptr = unsafe.Pointer(data_v.Index(0).Addr().Pointer())
	}
	if data != nil {
		size = int(data_v.Type().Size()) * data_v.Len()
	}
	C.gl3_0_glBufferData(gl.funcs, C.GLenum(target), C.GLsizeiptr(size), data_ptr, C.GLenum(usage))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glIsBuffer.xml
func (gl *GL) IsBuffer(buffer glbase.Buffer) bool {
	glresult := C.gl3_0_glIsBuffer(gl.funcs, C.GLuint(buffer))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// GenBuffers returns n buffer object names. There is no guarantee that
// the names form a contiguous set of integers; however, it is guaranteed
// that none of the returned names was in use immediately before the call to
// GenBuffers.
//
// Buffer object names returned by a call to GenBuffers are not returned by
// subsequent calls, unless they are first deleted with DeleteBuffers.
//
// No buffer objects are associated with the returned buffer object names
// until they are first bound by calling BindBuffer.
//
// Error GL.INVALID_VALUE is generated if n is negative. GL.INVALID_OPERATION
// is generated if GenBuffers is executed between the execution of Begin
// and the corresponding execution of End.
//
// GenBuffers is available in GL version 1.5 or greater.
func (gl *GL) GenBuffers(n int) []glbase.Buffer {
	if n == 0 {
		return nil
	}
	buffers := make([]glbase.Buffer, n)
	C.gl3_0_glGenBuffers(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&buffers[0])))
	return buffers
}

// DeleteBuffers deletes the buffer objects whose names are stored in the
// buffers slice.
//
// After a buffer object is deleted, it has no contents, and its name is free
// for reuse (for example by GenBuffers). If a buffer object that is
// currently bound is deleted, the binding reverts to 0 (the absence of any
// buffer object, which reverts to client memory usage).
//
// DeleteBuffers silently ignores 0's and names that do not correspond to
// existing buffer objects.
//
// Error GL.INVALID_VALUE is generated if n is negative. GL.INVALID_OPERATION
// is generated if DeleteBuffers is executed between the execution of Begin
// and the corresponding execution of End.
//
// DeleteBuffers is available in GL version 1.5 or greater.
func (gl *GL) DeleteBuffers(buffers []glbase.Buffer) {
	n := len(buffers)
	if n == 0 {
		return
	}
	C.gl3_0_glDeleteBuffers(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&buffers[0])))
}

// BindBuffer creates or puts in use a named buffer object.
// Calling BindBuffer with target set to GL.ARRAY_BUFFER,
// GL.ELEMENT_ARRAY_BUFFER, GL.PIXEL_PACK_BUFFER or GL.PIXEL_UNPACK_BUFFER
// and buffer set to the name of the new buffer object binds the buffer
// object name to the target. When a buffer object is bound to a target, the
// previous binding for that target is automatically broken.
//
// Buffer object names are unsigned integers. The value zero is reserved, but
// there is no default buffer object for each buffer object target. Instead,
// buffer set to zero effectively unbinds any buffer object previously bound,
// and restores client memory usage for that buffer object target. Buffer
// object names and the corresponding buffer object contents are local to the
// shared display-list space (see XCreateContext) of the current GL rendering
// context; two rendering contexts share buffer object names only if they
// also share display lists.
//
// GenBuffers may be called to generate a set of new buffer object names.
//
// The state of a buffer object immediately after it is first bound is an
// unmapped zero-sized memory buffer with GL.READ_WRITE access and
// GL.STATIC_DRAW usage.
//
// While a non-zero buffer object name is bound, GL operations on the target
// to which it is bound affect the bound buffer object, and queries of the
// target to which it is bound return state from the bound buffer object.
// While buffer object name zero is bound, as in the initial state, attempts
// to modify or query state on the target to which it is bound generates an
// GL.INVALID_OPERATION error.
//
// When vertex array pointer state is changed, for example by a call to
// NormalPointer, the current buffer object binding (GL.ARRAY_BUFFER_BINDING)
// is copied into the corresponding client state for the vertex array type
// being changed, for example GL.NORMAL_ARRAY_BUFFER_BINDING. While a
// non-zero buffer object is bound to the GL.ARRAY_BUFFER target, the vertex
// array pointer parameter that is traditionally interpreted as a pointer to
// client-side memory is instead interpreted as an offset within the buffer
// object measured in basic machine units.
//
// While a non-zero buffer object is bound to the GL.ELEMENT_ARRAY_BUFFER
// target, the indices parameter of DrawElements, DrawRangeElements, or
// MultiDrawElements that is traditionally interpreted as a pointer to
// client-side memory is instead interpreted as an offset within the buffer
// object measured in basic machine units.
//
// While a non-zero buffer object is bound to the GL.PIXEL_PACK_BUFFER
// target, the following commands are affected: GetCompressedTexImage,
// GetConvolutionFilter, GetHistogram, GetMinmax, GetPixelMap,
// GetPolygonStipple, GetSeparableFilter, GetTexImage, and ReadPixels. The
// pointer parameter that is traditionally interpreted as a pointer to
// client-side memory where the pixels are to be packed is instead
// interpreted as an offset within the buffer object measured in basic
// machine units.
//
// While a non-zero buffer object is bound to the GL.PIXEL_UNPACK_BUFFER
// target, the following commands are affected: Bitmap, ColorSubTable,
// ColorTable, CompressedTexImage1D, CompressedTexImage2D,
// CompressedTexImage3D, CompressedTexSubImage1D, CompressedTexSubImage2D,
// CompressedTexSubImage3D, ConvolutionFilter1D, ConvolutionFilter2D,
// DrawPixels, PixelMap, PolygonStipple, SeparableFilter2D, TexImage1D,
// TexImage2D, TexImage3D, TexSubImage1D, TexSubImage2D, and TexSubImage3D.
// The pointer parameter that is traditionally interpreted as a pointer to
// client-side memory from which the pixels are to be unpacked is instead
// interpreted as an offset within the buffer object measured in basic
// machine units.
//
// A buffer object binding created with BindBuffer remains active until a
// different buffer object name is bound to the same target, or until the
// bound buffer object is deleted with DeleteBuffers.
//
// Once created, a named buffer object may be re-bound to any target as often
// as needed. However, the GL implementation may make choices about how to
// optimize the storage of a buffer object based on its initial binding
// target.
//
// Error GL.INVALID_ENUM is generated if target is not one of the allowable
// values.  GL.INVALID_OPERATION is generated if BindBuffer is executed
// between the execution of Begin and the corresponding execution of End.
//
// BindBuffer is available in GL version 1.5 or greater.
func (gl *GL) BindBuffer(target glbase.Enum, buffer glbase.Buffer) {
	C.gl3_0_glBindBuffer(gl.funcs, C.GLenum(target), C.GLuint(buffer))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetQueryObjectuiv.xml
func (gl *GL) GetQueryObjectuiv(id uint32, pname glbase.Enum, params []uint32) {
	C.gl3_0_glGetQueryObjectuiv(gl.funcs, C.GLuint(id), C.GLenum(pname), (*C.GLuint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetQueryObjectiv.xml
func (gl *GL) GetQueryObjectiv(id uint32, pname glbase.Enum, params []int32) {
	C.gl3_0_glGetQueryObjectiv(gl.funcs, C.GLuint(id), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetQueryiv.xml
func (gl *GL) GetQueryiv(target, pname glbase.Enum, params []int32) {
	C.gl3_0_glGetQueryiv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glEndQuery.xml
func (gl *GL) EndQuery(target glbase.Enum) {
	C.gl3_0_glEndQuery(gl.funcs, C.GLenum(target))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glBeginQuery.xml
func (gl *GL) BeginQuery(target glbase.Enum, id uint32) {
	C.gl3_0_glBeginQuery(gl.funcs, C.GLenum(target), C.GLuint(id))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glIsQuery.xml
func (gl *GL) IsQuery(id uint32) bool {
	glresult := C.gl3_0_glIsQuery(gl.funcs, C.GLuint(id))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glDeleteQueries.xml
func (gl *GL) DeleteQueries(n int, ids []uint32) {
	C.gl3_0_glDeleteQueries(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&ids[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGenQueries.xml
func (gl *GL) GenQueries(n int, ids []uint32) {
	C.gl3_0_glGenQueries(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&ids[0])))
}

// VertexAttribPointer specifies the location and data format of the array
// of generic vertex attributes at index to use when rendering. size
// specifies the number of components per attribute and must be 1, 2, 3, or
// 4. type specifies the data type of each component, and stride specifies
// the byte stride from one attribute to the next, allowing vertices and
// attributes to be packed into a single array or stored in separate arrays.
// normalized indicates whether the values stored in an integer format are
// to be mapped to the range [-1,1] (for signed values) or [0,1]
// (for unsigned values) when they are accessed and converted to floating
// point; otherwise, values will be converted to floats directly without
// normalization. offset is a byte offset into the buffer object's data
// store, which must be bound to the GL.ARRAY_BUFFER target with BindBuffer.
//
// The buffer object binding (GL.ARRAY_BUFFER_BINDING) is saved as
// generic vertex attribute array client-side state
// (GL.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING) for the provided index.
//
// To enable and disable a generic vertex attribute array, call
// EnableVertexAttribArray and DisableVertexAttribArray with index. If
// enabled, the generic vertex attribute array is used when DrawArrays or
// DrawElements is called. Each generic vertex attribute array is initially
// disabled.
//
// VertexAttribPointer is typically implemented on the client side.
//
// Error GL.INVALID_ENUM is generated if type is not an accepted value.
// GL.INVALID_VALUE is generated if index is greater than or equal to
// GL.MAX_VERTEX_ATTRIBS. GL.INVALID_VALUE is generated if size is not 1, 2,
// 3, or 4. GL.INVALID_VALUE is generated if stride is negative.
func (gl *GL) VertexAttribPointer(index glbase.Attrib, size int, gltype glbase.Enum, normalized bool, stride int, offset uintptr) {
	offset_ptr := unsafe.Pointer(offset)
	C.gl3_0_glVertexAttribPointer(gl.funcs, C.GLuint(index), C.GLint(size), C.GLenum(gltype), *(*C.GLboolean)(unsafe.Pointer(&normalized)), C.GLsizei(stride), offset_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glValidateProgram.xml
func (gl *GL) ValidateProgram(program glbase.Program) {
	C.gl3_0_glValidateProgram(gl.funcs, C.GLuint(program))
}

// UniformMatrix4fv modifies the value of a uniform variable or a uniform
// variable array. The location of the uniform variable to be modified is
// specified by location, which should be a value returned by GetUniformLocation.
// UniformMatrix4fv operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions UniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to
// modify a matrix or an array of matrices. The numbers in the function name
// are interpreted as the dimensionality of the matrix. The number 2
// indicates a 2x2 matrix (4 values), the number 3 indicates a 3x3 matrix (9
// values), and the number 4 indicates a 4x4 matrix (16 values). Non-square
// matrix dimensionality is explicit, with the first number representing the
// number of columns and the second number representing the number of rows.
// For example, 2x4 indicates a 2x4 matrix with 2 columns and 4 rows (8
// values). The length of the provided slice must be a multiple of the number
// of values per matrix, to update one or more consecutive matrices.
//
// If transpose is false, each matrix is assumed to be supplied in column
// major order. If transpose is true, each matrix is assumed to be supplied
// in row major order.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) UniformMatrix4fv(location glbase.Uniform, transpose bool, value []float32) {
	if len(value) == 0 {
		return
	}
	if len(value)%(4*4) != 0 {
		panic("invalid value length for UniformMatrix4fv")
	}
	count := len(value) / (4 * 4)
	C.gl3_0_glUniformMatrix4fv(gl.funcs, C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// UniformMatrix3fv modifies the value of a uniform variable or a uniform
// variable array. The location of the uniform variable to be modified is
// specified by location, which should be a value returned by GetUniformLocation.
// UniformMatrix3fv operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions UniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to
// modify a matrix or an array of matrices. The numbers in the function name
// are interpreted as the dimensionality of the matrix. The number 2
// indicates a 2x2 matrix (4 values), the number 3 indicates a 3x3 matrix (9
// values), and the number 4 indicates a 4x4 matrix (16 values). Non-square
// matrix dimensionality is explicit, with the first number representing the
// number of columns and the second number representing the number of rows.
// For example, 2x4 indicates a 2x4 matrix with 2 columns and 4 rows (8
// values). The length of the provided slice must be a multiple of the number
// of values per matrix, to update one or more consecutive matrices.
//
// If transpose is false, each matrix is assumed to be supplied in column
// major order. If transpose is true, each matrix is assumed to be supplied
// in row major order.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) UniformMatrix3fv(location glbase.Uniform, transpose bool, value []float32) {
	if len(value) == 0 {
		return
	}
	if len(value)%(3*3) != 0 {
		panic("invalid value length for UniformMatrix3fv")
	}
	count := len(value) / (3 * 3)
	C.gl3_0_glUniformMatrix3fv(gl.funcs, C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// UniformMatrix2fv modifies the value of a uniform variable or a uniform
// variable array. The location of the uniform variable to be modified is
// specified by location, which should be a value returned by GetUniformLocation.
// UniformMatrix2fv operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions UniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to
// modify a matrix or an array of matrices. The numbers in the function name
// are interpreted as the dimensionality of the matrix. The number 2
// indicates a 2x2 matrix (4 values), the number 3 indicates a 3x3 matrix (9
// values), and the number 4 indicates a 4x4 matrix (16 values). Non-square
// matrix dimensionality is explicit, with the first number representing the
// number of columns and the second number representing the number of rows.
// For example, 2x4 indicates a 2x4 matrix with 2 columns and 4 rows (8
// values). The length of the provided slice must be a multiple of the number
// of values per matrix, to update one or more consecutive matrices.
//
// If transpose is false, each matrix is assumed to be supplied in column
// major order. If transpose is true, each matrix is assumed to be supplied
// in row major order.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) UniformMatrix2fv(location glbase.Uniform, transpose bool, value []float32) {
	if len(value) == 0 {
		return
	}
	if len(value)%(2*2) != 0 {
		panic("invalid value length for UniformMatrix2fv")
	}
	count := len(value) / (2 * 2)
	C.gl3_0_glUniformMatrix2fv(gl.funcs, C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// Uniform4iv modifies the value of a uniform variable or a uniform
// variable array. The location of the uniform variable to be modified is
// specified by location, which should be a value returned by GetUniformLocation.
// Uniform4iv operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions Uniform{1|2|3|4}{f|i|ui}v can be used to modify a single
// uniform variable or a uniform variable array. These functions receive a
// slice with the values to be loaded into a uniform variable or a uniform
// variable array. A slice with length 1 should be used if modifying the value
// of a single uniform variable, and a length of 1 or greater can be used to
// modify an entire array or part of an array. When loading n elements
// starting at an arbitrary position m in a uniform variable array, elements
// m + n - 1 in the array will be replaced with the new values. If m + n - 1
// is larger than the size of the uniform variable array, values for all
// array elements beyond the end of the array will be ignored. The number
// specified in the name of the command indicates the number of components
// for each element in value, and it should match the number of components in
// the data type of the specified uniform variable (1 for float, int, bool;
// 2 for vec2, ivec2, bvec2, etc.). The data type specified in the name
// of the command must match the data type for the specified uniform variable
// as described for Uniform{1|2|3|4}{f|i|ui}.
//
// Uniform1i and Uniform1iv are the only two functions that may be used to
// load uniform variables defined as sampler types. Loading samplers with any
// other function will result in a GL.INVALID_OPERATION error.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) Uniform4iv(location glbase.Uniform, value []int32) {
	if len(value) == 0 {
		return
	}
	if len(value)%4 != 0 {
		panic("invalid value length for Uniform4iv")
	}
	count := len(value) / 4
	C.gl3_0_glUniform4iv(gl.funcs, C.GLint(location), C.GLsizei(count), (*C.GLint)(unsafe.Pointer(&value[0])))
}

// Uniform3iv modifies the value of a uniform variable or a uniform
// variable array. The location of the uniform variable to be modified is
// specified by location, which should be a value returned by GetUniformLocation.
// Uniform3iv operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions Uniform{1|2|3|4}{f|i|ui}v can be used to modify a single
// uniform variable or a uniform variable array. These functions receive a
// slice with the values to be loaded into a uniform variable or a uniform
// variable array. A slice with length 1 should be used if modifying the value
// of a single uniform variable, and a length of 1 or greater can be used to
// modify an entire array or part of an array. When loading n elements
// starting at an arbitrary position m in a uniform variable array, elements
// m + n - 1 in the array will be replaced with the new values. If m + n - 1
// is larger than the size of the uniform variable array, values for all
// array elements beyond the end of the array will be ignored. The number
// specified in the name of the command indicates the number of components
// for each element in value, and it should match the number of components in
// the data type of the specified uniform variable (1 for float, int, bool;
// 2 for vec2, ivec2, bvec2, etc.). The data type specified in the name
// of the command must match the data type for the specified uniform variable
// as described for Uniform{1|2|3|4}{f|i|ui}.
//
// Uniform1i and Uniform1iv are the only two functions that may be used to
// load uniform variables defined as sampler types. Loading samplers with any
// other function will result in a GL.INVALID_OPERATION error.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) Uniform3iv(location glbase.Uniform, value []int32) {
	if len(value) == 0 {
		return
	}
	if len(value)%3 != 0 {
		panic("invalid value length for Uniform3iv")
	}
	count := len(value) / 3
	C.gl3_0_glUniform3iv(gl.funcs, C.GLint(location), C.GLsizei(count), (*C.GLint)(unsafe.Pointer(&value[0])))
}

// Uniform2iv modifies the value of a uniform variable or a uniform
// variable array. The location of the uniform variable to be modified is
// specified by location, which should be a value returned by GetUniformLocation.
// Uniform2iv operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions Uniform{1|2|3|4}{f|i|ui}v can be used to modify a single
// uniform variable or a uniform variable array. These functions receive a
// slice with the values to be loaded into a uniform variable or a uniform
// variable array. A slice with length 1 should be used if modifying the value
// of a single uniform variable, and a length of 1 or greater can be used to
// modify an entire array or part of an array. When loading n elements
// starting at an arbitrary position m in a uniform variable array, elements
// m + n - 1 in the array will be replaced with the new values. If m + n - 1
// is larger than the size of the uniform variable array, values for all
// array elements beyond the end of the array will be ignored. The number
// specified in the name of the command indicates the number of components
// for each element in value, and it should match the number of components in
// the data type of the specified uniform variable (1 for float, int, bool;
// 2 for vec2, ivec2, bvec2, etc.). The data type specified in the name
// of the command must match the data type for the specified uniform variable
// as described for Uniform{1|2|3|4}{f|i|ui}.
//
// Uniform1i and Uniform1iv are the only two functions that may be used to
// load uniform variables defined as sampler types. Loading samplers with any
// other function will result in a GL.INVALID_OPERATION error.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) Uniform2iv(location glbase.Uniform, value []int32) {
	if len(value) == 0 {
		return
	}
	if len(value)%2 != 0 {
		panic("invalid value length for Uniform2iv")
	}
	count := len(value) / 2
	C.gl3_0_glUniform2iv(gl.funcs, C.GLint(location), C.GLsizei(count), (*C.GLint)(unsafe.Pointer(&value[0])))
}

// Uniform1iv modifies the value of a uniform variable or a uniform
// variable array. The location of the uniform variable to be modified is
// specified by location, which should be a value returned by GetUniformLocation.
// Uniform1iv operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions Uniform{1|2|3|4}{f|i|ui}v can be used to modify a single
// uniform variable or a uniform variable array. These functions receive a
// slice with the values to be loaded into a uniform variable or a uniform
// variable array. A slice with length 1 should be used if modifying the value
// of a single uniform variable, and a length of 1 or greater can be used to
// modify an entire array or part of an array. When loading n elements
// starting at an arbitrary position m in a uniform variable array, elements
// m + n - 1 in the array will be replaced with the new values. If m + n - 1
// is larger than the size of the uniform variable array, values for all
// array elements beyond the end of the array will be ignored. The number
// specified in the name of the command indicates the number of components
// for each element in value, and it should match the number of components in
// the data type of the specified uniform variable (1 for float, int, bool;
// 2 for vec2, ivec2, bvec2, etc.). The data type specified in the name
// of the command must match the data type for the specified uniform variable
// as described for Uniform{1|2|3|4}{f|i|ui}.
//
// Uniform1i and Uniform1iv are the only two functions that may be used to
// load uniform variables defined as sampler types. Loading samplers with any
// other function will result in a GL.INVALID_OPERATION error.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) Uniform1iv(location glbase.Uniform, value []int32) {
	if len(value) == 0 {
		return
	}
	count := len(value)
	C.gl3_0_glUniform1iv(gl.funcs, C.GLint(location), C.GLsizei(count), (*C.GLint)(unsafe.Pointer(&value[0])))
}

// Uniform4fv modifies the value of a uniform variable or a uniform
// variable array. The location of the uniform variable to be modified is
// specified by location, which should be a value returned by GetUniformLocation.
// Uniform4fv operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions Uniform{1|2|3|4}{f|i|ui}v can be used to modify a single
// uniform variable or a uniform variable array. These functions receive a
// slice with the values to be loaded into a uniform variable or a uniform
// variable array. A slice with length 1 should be used if modifying the value
// of a single uniform variable, and a length of 1 or greater can be used to
// modify an entire array or part of an array. When loading n elements
// starting at an arbitrary position m in a uniform variable array, elements
// m + n - 1 in the array will be replaced with the new values. If m + n - 1
// is larger than the size of the uniform variable array, values for all
// array elements beyond the end of the array will be ignored. The number
// specified in the name of the command indicates the number of components
// for each element in value, and it should match the number of components in
// the data type of the specified uniform variable (1 for float, int, bool;
// 2 for vec2, ivec2, bvec2, etc.). The data type specified in the name
// of the command must match the data type for the specified uniform variable
// as described for Uniform{1|2|3|4}{f|i|ui}.
//
// Uniform1i and Uniform1iv are the only two functions that may be used to
// load uniform variables defined as sampler types. Loading samplers with any
// other function will result in a GL.INVALID_OPERATION error.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) Uniform4fv(location glbase.Uniform, value []float32) {
	if len(value) == 0 {
		return
	}
	if len(value)%4 != 0 {
		panic("invalid value length for Uniform4fv")
	}
	count := len(value) / 4
	C.gl3_0_glUniform4fv(gl.funcs, C.GLint(location), C.GLsizei(count), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// Uniform3fv modifies the value of a uniform variable or a uniform
// variable array. The location of the uniform variable to be modified is
// specified by location, which should be a value returned by GetUniformLocation.
// Uniform3fv operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions Uniform{1|2|3|4}{f|i|ui}v can be used to modify a single
// uniform variable or a uniform variable array. These functions receive a
// slice with the values to be loaded into a uniform variable or a uniform
// variable array. A slice with length 1 should be used if modifying the value
// of a single uniform variable, and a length of 1 or greater can be used to
// modify an entire array or part of an array. When loading n elements
// starting at an arbitrary position m in a uniform variable array, elements
// m + n - 1 in the array will be replaced with the new values. If m + n - 1
// is larger than the size of the uniform variable array, values for all
// array elements beyond the end of the array will be ignored. The number
// specified in the name of the command indicates the number of components
// for each element in value, and it should match the number of components in
// the data type of the specified uniform variable (1 for float, int, bool;
// 2 for vec2, ivec2, bvec2, etc.). The data type specified in the name
// of the command must match the data type for the specified uniform variable
// as described for Uniform{1|2|3|4}{f|i|ui}.
//
// Uniform1i and Uniform1iv are the only two functions that may be used to
// load uniform variables defined as sampler types. Loading samplers with any
// other function will result in a GL.INVALID_OPERATION error.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) Uniform3fv(location glbase.Uniform, value []float32) {
	if len(value) == 0 {
		return
	}
	if len(value)%3 != 0 {
		panic("invalid value length for Uniform3fv")
	}
	count := len(value) / 3
	C.gl3_0_glUniform3fv(gl.funcs, C.GLint(location), C.GLsizei(count), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// Uniform2fv modifies the value of a uniform variable or a uniform
// variable array. The location of the uniform variable to be modified is
// specified by location, which should be a value returned by GetUniformLocation.
// Uniform2fv operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions Uniform{1|2|3|4}{f|i|ui}v can be used to modify a single
// uniform variable or a uniform variable array. These functions receive a
// slice with the values to be loaded into a uniform variable or a uniform
// variable array. A slice with length 1 should be used if modifying the value
// of a single uniform variable, and a length of 1 or greater can be used to
// modify an entire array or part of an array. When loading n elements
// starting at an arbitrary position m in a uniform variable array, elements
// m + n - 1 in the array will be replaced with the new values. If m + n - 1
// is larger than the size of the uniform variable array, values for all
// array elements beyond the end of the array will be ignored. The number
// specified in the name of the command indicates the number of components
// for each element in value, and it should match the number of components in
// the data type of the specified uniform variable (1 for float, int, bool;
// 2 for vec2, ivec2, bvec2, etc.). The data type specified in the name
// of the command must match the data type for the specified uniform variable
// as described for Uniform{1|2|3|4}{f|i|ui}.
//
// Uniform1i and Uniform1iv are the only two functions that may be used to
// load uniform variables defined as sampler types. Loading samplers with any
// other function will result in a GL.INVALID_OPERATION error.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) Uniform2fv(location glbase.Uniform, value []float32) {
	if len(value) == 0 {
		return
	}
	if len(value)%2 != 0 {
		panic("invalid value length for Uniform2fv")
	}
	count := len(value) / 2
	C.gl3_0_glUniform2fv(gl.funcs, C.GLint(location), C.GLsizei(count), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// Uniform1fv modifies the value of a uniform variable or a uniform
// variable array. The location of the uniform variable to be modified is
// specified by location, which should be a value returned by GetUniformLocation.
// Uniform1fv operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions Uniform{1|2|3|4}{f|i|ui}v can be used to modify a single
// uniform variable or a uniform variable array. These functions receive a
// slice with the values to be loaded into a uniform variable or a uniform
// variable array. A slice with length 1 should be used if modifying the value
// of a single uniform variable, and a length of 1 or greater can be used to
// modify an entire array or part of an array. When loading n elements
// starting at an arbitrary position m in a uniform variable array, elements
// m + n - 1 in the array will be replaced with the new values. If m + n - 1
// is larger than the size of the uniform variable array, values for all
// array elements beyond the end of the array will be ignored. The number
// specified in the name of the command indicates the number of components
// for each element in value, and it should match the number of components in
// the data type of the specified uniform variable (1 for float, int, bool;
// 2 for vec2, ivec2, bvec2, etc.). The data type specified in the name
// of the command must match the data type for the specified uniform variable
// as described for Uniform{1|2|3|4}{f|i|ui}.
//
// Uniform1i and Uniform1iv are the only two functions that may be used to
// load uniform variables defined as sampler types. Loading samplers with any
// other function will result in a GL.INVALID_OPERATION error.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) Uniform1fv(location glbase.Uniform, value []float32) {
	if len(value) == 0 {
		return
	}
	count := len(value)
	C.gl3_0_glUniform1fv(gl.funcs, C.GLint(location), C.GLsizei(count), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// Uniform4i modifies the value of a single uniform variable.
// The location of the uniform variable to be modified is specified by
// location, which should be a value returned by GetUniformLocation.
// Uniform4i operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions Uniform{1|2|3|4}{f|i|ui} are used to change the value of the
// uniform variable specified by location using the values passed as
// arguments. The number specified in the function should match the number of
// components in the data type of the specified uniform variable (1 for
// float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
// The suffix f indicates that floating-point values are being passed; the
// suffix i indicates that integer values are being passed; the suffix ui
// indicates that unsigned integer values are being passed, and this type
// should also match the data type of the specified uniform variable. The i
// variants of this function should be used to provide values for uniform
// variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui
// variants of this function should be used to provide values for uniform
// variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of
// these. The f variants should be used to provide values for uniform
// variables of type float, vec2, vec3, vec4, or arrays of these. Either the
// i, ui or f variants may be used to provide values for uniform variables of
// type bool, bvec2, bvec3, bvec4, or arrays of these. The uniform variable
// will be set to false if the input value is 0 or 0.0f, and it will be set
// to true otherwise.
//
// Uniform1i and Uniform1iv are the only two functions that may be used to
// load uniform variables defined as sampler types. Loading samplers with any
// other function will result in a GL.INVALID_OPERATION error.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) Uniform4i(location glbase.Uniform, v0, v1, v2, v3 int32) {
	C.gl3_0_glUniform4i(gl.funcs, C.GLint(location), C.GLint(v0), C.GLint(v1), C.GLint(v2), C.GLint(v3))
}

// Uniform3i modifies the value of a single uniform variable.
// The location of the uniform variable to be modified is specified by
// location, which should be a value returned by GetUniformLocation.
// Uniform3i operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions Uniform{1|2|3|4}{f|i|ui} are used to change the value of the
// uniform variable specified by location using the values passed as
// arguments. The number specified in the function should match the number of
// components in the data type of the specified uniform variable (1 for
// float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
// The suffix f indicates that floating-point values are being passed; the
// suffix i indicates that integer values are being passed; the suffix ui
// indicates that unsigned integer values are being passed, and this type
// should also match the data type of the specified uniform variable. The i
// variants of this function should be used to provide values for uniform
// variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui
// variants of this function should be used to provide values for uniform
// variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of
// these. The f variants should be used to provide values for uniform
// variables of type float, vec2, vec3, vec4, or arrays of these. Either the
// i, ui or f variants may be used to provide values for uniform variables of
// type bool, bvec2, bvec3, bvec4, or arrays of these. The uniform variable
// will be set to false if the input value is 0 or 0.0f, and it will be set
// to true otherwise.
//
// Uniform1i and Uniform1iv are the only two functions that may be used to
// load uniform variables defined as sampler types. Loading samplers with any
// other function will result in a GL.INVALID_OPERATION error.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) Uniform3i(location glbase.Uniform, v0, v1, v2 int32) {
	C.gl3_0_glUniform3i(gl.funcs, C.GLint(location), C.GLint(v0), C.GLint(v1), C.GLint(v2))
}

// Uniform2i modifies the value of a single uniform variable.
// The location of the uniform variable to be modified is specified by
// location, which should be a value returned by GetUniformLocation.
// Uniform2i operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions Uniform{1|2|3|4}{f|i|ui} are used to change the value of the
// uniform variable specified by location using the values passed as
// arguments. The number specified in the function should match the number of
// components in the data type of the specified uniform variable (1 for
// float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
// The suffix f indicates that floating-point values are being passed; the
// suffix i indicates that integer values are being passed; the suffix ui
// indicates that unsigned integer values are being passed, and this type
// should also match the data type of the specified uniform variable. The i
// variants of this function should be used to provide values for uniform
// variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui
// variants of this function should be used to provide values for uniform
// variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of
// these. The f variants should be used to provide values for uniform
// variables of type float, vec2, vec3, vec4, or arrays of these. Either the
// i, ui or f variants may be used to provide values for uniform variables of
// type bool, bvec2, bvec3, bvec4, or arrays of these. The uniform variable
// will be set to false if the input value is 0 or 0.0f, and it will be set
// to true otherwise.
//
// Uniform1i and Uniform1iv are the only two functions that may be used to
// load uniform variables defined as sampler types. Loading samplers with any
// other function will result in a GL.INVALID_OPERATION error.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) Uniform2i(location glbase.Uniform, v0, v1 int32) {
	C.gl3_0_glUniform2i(gl.funcs, C.GLint(location), C.GLint(v0), C.GLint(v1))
}

// Uniform1i modifies the value of a single uniform variable.
// The location of the uniform variable to be modified is specified by
// location, which should be a value returned by GetUniformLocation.
// Uniform1i operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions Uniform{1|2|3|4}{f|i|ui} are used to change the value of the
// uniform variable specified by location using the values passed as
// arguments. The number specified in the function should match the number of
// components in the data type of the specified uniform variable (1 for
// float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
// The suffix f indicates that floating-point values are being passed; the
// suffix i indicates that integer values are being passed; the suffix ui
// indicates that unsigned integer values are being passed, and this type
// should also match the data type of the specified uniform variable. The i
// variants of this function should be used to provide values for uniform
// variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui
// variants of this function should be used to provide values for uniform
// variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of
// these. The f variants should be used to provide values for uniform
// variables of type float, vec2, vec3, vec4, or arrays of these. Either the
// i, ui or f variants may be used to provide values for uniform variables of
// type bool, bvec2, bvec3, bvec4, or arrays of these. The uniform variable
// will be set to false if the input value is 0 or 0.0f, and it will be set
// to true otherwise.
//
// Uniform1i and Uniform1iv are the only two functions that may be used to
// load uniform variables defined as sampler types. Loading samplers with any
// other function will result in a GL.INVALID_OPERATION error.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) Uniform1i(location glbase.Uniform, v0 int32) {
	C.gl3_0_glUniform1i(gl.funcs, C.GLint(location), C.GLint(v0))
}

// Uniform4f modifies the value of a single uniform variable.
// The location of the uniform variable to be modified is specified by
// location, which should be a value returned by GetUniformLocation.
// Uniform4f operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions Uniform{1|2|3|4}{f|i|ui} are used to change the value of the
// uniform variable specified by location using the values passed as
// arguments. The number specified in the function should match the number of
// components in the data type of the specified uniform variable (1 for
// float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
// The suffix f indicates that floating-point values are being passed; the
// suffix i indicates that integer values are being passed; the suffix ui
// indicates that unsigned integer values are being passed, and this type
// should also match the data type of the specified uniform variable. The i
// variants of this function should be used to provide values for uniform
// variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui
// variants of this function should be used to provide values for uniform
// variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of
// these. The f variants should be used to provide values for uniform
// variables of type float, vec2, vec3, vec4, or arrays of these. Either the
// i, ui or f variants may be used to provide values for uniform variables of
// type bool, bvec2, bvec3, bvec4, or arrays of these. The uniform variable
// will be set to false if the input value is 0 or 0.0f, and it will be set
// to true otherwise.
//
// Uniform1i and Uniform1iv are the only two functions that may be used to
// load uniform variables defined as sampler types. Loading samplers with any
// other function will result in a GL.INVALID_OPERATION error.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) Uniform4f(location glbase.Uniform, v0, v1, v2, v3 float32) {
	C.gl3_0_glUniform4f(gl.funcs, C.GLint(location), C.GLfloat(v0), C.GLfloat(v1), C.GLfloat(v2), C.GLfloat(v3))
}

// Uniform3f modifies the value of a single uniform variable.
// The location of the uniform variable to be modified is specified by
// location, which should be a value returned by GetUniformLocation.
// Uniform3f operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions Uniform{1|2|3|4}{f|i|ui} are used to change the value of the
// uniform variable specified by location using the values passed as
// arguments. The number specified in the function should match the number of
// components in the data type of the specified uniform variable (1 for
// float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
// The suffix f indicates that floating-point values are being passed; the
// suffix i indicates that integer values are being passed; the suffix ui
// indicates that unsigned integer values are being passed, and this type
// should also match the data type of the specified uniform variable. The i
// variants of this function should be used to provide values for uniform
// variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui
// variants of this function should be used to provide values for uniform
// variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of
// these. The f variants should be used to provide values for uniform
// variables of type float, vec2, vec3, vec4, or arrays of these. Either the
// i, ui or f variants may be used to provide values for uniform variables of
// type bool, bvec2, bvec3, bvec4, or arrays of these. The uniform variable
// will be set to false if the input value is 0 or 0.0f, and it will be set
// to true otherwise.
//
// Uniform1i and Uniform1iv are the only two functions that may be used to
// load uniform variables defined as sampler types. Loading samplers with any
// other function will result in a GL.INVALID_OPERATION error.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) Uniform3f(location glbase.Uniform, v0, v1, v2 float32) {
	C.gl3_0_glUniform3f(gl.funcs, C.GLint(location), C.GLfloat(v0), C.GLfloat(v1), C.GLfloat(v2))
}

// Uniform2f modifies the value of a single uniform variable.
// The location of the uniform variable to be modified is specified by
// location, which should be a value returned by GetUniformLocation.
// Uniform2f operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions Uniform{1|2|3|4}{f|i|ui} are used to change the value of the
// uniform variable specified by location using the values passed as
// arguments. The number specified in the function should match the number of
// components in the data type of the specified uniform variable (1 for
// float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
// The suffix f indicates that floating-point values are being passed; the
// suffix i indicates that integer values are being passed; the suffix ui
// indicates that unsigned integer values are being passed, and this type
// should also match the data type of the specified uniform variable. The i
// variants of this function should be used to provide values for uniform
// variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui
// variants of this function should be used to provide values for uniform
// variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of
// these. The f variants should be used to provide values for uniform
// variables of type float, vec2, vec3, vec4, or arrays of these. Either the
// i, ui or f variants may be used to provide values for uniform variables of
// type bool, bvec2, bvec3, bvec4, or arrays of these. The uniform variable
// will be set to false if the input value is 0 or 0.0f, and it will be set
// to true otherwise.
//
// Uniform1i and Uniform1iv are the only two functions that may be used to
// load uniform variables defined as sampler types. Loading samplers with any
// other function will result in a GL.INVALID_OPERATION error.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) Uniform2f(location glbase.Uniform, v0, v1 float32) {
	C.gl3_0_glUniform2f(gl.funcs, C.GLint(location), C.GLfloat(v0), C.GLfloat(v1))
}

// Uniform1f modifies the value of a single uniform variable.
// The location of the uniform variable to be modified is specified by
// location, which should be a value returned by GetUniformLocation.
// Uniform1f operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions Uniform{1|2|3|4}{f|i|ui} are used to change the value of the
// uniform variable specified by location using the values passed as
// arguments. The number specified in the function should match the number of
// components in the data type of the specified uniform variable (1 for
// float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
// The suffix f indicates that floating-point values are being passed; the
// suffix i indicates that integer values are being passed; the suffix ui
// indicates that unsigned integer values are being passed, and this type
// should also match the data type of the specified uniform variable. The i
// variants of this function should be used to provide values for uniform
// variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui
// variants of this function should be used to provide values for uniform
// variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of
// these. The f variants should be used to provide values for uniform
// variables of type float, vec2, vec3, vec4, or arrays of these. Either the
// i, ui or f variants may be used to provide values for uniform variables of
// type bool, bvec2, bvec3, bvec4, or arrays of these. The uniform variable
// will be set to false if the input value is 0 or 0.0f, and it will be set
// to true otherwise.
//
// Uniform1i and Uniform1iv are the only two functions that may be used to
// load uniform variables defined as sampler types. Loading samplers with any
// other function will result in a GL.INVALID_OPERATION error.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) Uniform1f(location glbase.Uniform, v0 float32) {
	C.gl3_0_glUniform1f(gl.funcs, C.GLint(location), C.GLfloat(v0))
}

// UseProgram installs the program object specified by program as part of
// current rendering state. One or more executables are created in a program
// object by successfully attaching shader objects to it with AttachShader,
// successfully compiling the shader objects with CompileShader, and
// successfully linking the program object with LinkProgram.
//
// A program object will contain an executable that will run on the vertex
// processor if it contains one or more shader objects of type
// GL.VERTEX_SHADER that have been successfully compiled and linked.
// Similarly, a program object will contain an executable that will run on
// the fragment processor if it contains one or more shader objects of type
// GL.FRAGMENT_SHADER that have been successfully compiled and linked.
//
// Successfully installing an executable on a programmable processor will
// cause the corresponding fixed functionality of OpenGL to be disabled.
// Specifically, if an executable is installed on the vertex processor, the
// OpenGL fixed functionality will be disabled as follows.
//
//   - The modelview matrix is not applied to vertex coordinates.
//
//   - The projection matrix is not applied to vertex coordinates.
//
//   - The texture matrices are not applied to texture coordinates.
//
//   - Normals are not transformed to eye coordinates.
//
//   - Normals are not rescaled or normalized.
//
//   - Normalization of GL.AUTO_NORMAL evaluated normals is not performed.
//
//   - Texture coordinates are not generated automatically.
//
//   - Per-vertex lighting is not performed.
//
//   - Color material computations are not performed.
//
//   - Color index lighting is not performed.
//
//   - This list also applies when setting the current raster position.
//
// The executable that is installed on the vertex processor is expected to
// implement any or all of the desired functionality from the preceding list.
// Similarly, if an executable is installed on the fragment processor, the
// OpenGL fixed functionality will be disabled as follows.
//
//   - Texture environment and texture functions are not applied.
//
//   - Texture application is not applied.
//
//   - Color sum is not applied.
//
//   - Fog is not applied.
//
// Again, the fragment shader that is installed is expected to implement any
// or all of the desired functionality from the preceding list.
//
// While a program object is in use, applications are free to modify attached
// shader objects, compile attached shader objects, attach additional shader
// objects, and detach or delete shader objects. None of these operations
// will affect the executables that are part of the current state. However,
// relinking the program object that is currently in use will install the
// program object as part of the current rendering state if the link
// operation was successful (see LinkProgram). If the program object
// currently in use is relinked unsuccessfully, its link status will be set
// to GL.FALSE, but the executables and associated state will remain part of
// the current state until a subsequent call to UseProgram removes it from
// use. After it is removed from use, it cannot be made part of current state
// until it has been successfully relinked.
//
// If program contains shader objects of type GL.VERTEX_SHADER but it does
// not contain shader objects of type GL.FRAGMENT_SHADER, an executable will
// be installed on the vertex processor, but fixed functionality will be used
// for fragment processing. Similarly, if program contains shader objects of
// type GL.FRAGMENT_SHADER but it does not contain shader objects of type
// GL.VERTEX_SHADER, an executable will be installed on the fragment
// processor, but fixed functionality will be used for vertex processing. If
// program is 0, the programmable processors will be disabled, and fixed
// functionality will be used for both vertex and fragment processing.
//
// While a program object is in use, the state that controls the disabled
// fixed functionality may also be updated using the normal OpenGL calls.
//
// Like display lists and texture objects, the name space for program objects
// may be shared across a set of contexts, as long as the server sides of the
// contexts share the same address space. If the name space is shared across
// contexts, any attached objects and the data associated with those attached
// objects are shared as well.
//
// Applications are responsible for providing the synchronization across API
// calls when objects are accessed from different execution threads.
//
// Error GL.INVALID_VALUE is generated if program is neither 0 nor a value
// generated by OpenGL.  GL.INVALID_OPERATION is generated if program is not
// a program object.  GL.INVALID_OPERATION is generated if program could not
// be made part of current state.  GL.INVALID_OPERATION is generated if
// UseProgram is executed between the execution of Begin and the
// corresponding execution of End.
//
// UseProgram is available in GL version 2.0 or greater.
func (gl *GL) UseProgram(program glbase.Program) {
	C.gl3_0_glUseProgram(gl.funcs, C.GLuint(program))
}

// ShaderSource sets the source code in shader to the provided source code. Any source
// code previously stored in the shader object is completely replaced.
//
// Error GL.INVALID_VALUE is generated if shader is not a value generated by
// OpenGL. GL.INVALID_OPERATION is generated if shader is not a shader
// object. GL.INVALID_VALUE is generated if count is less than 0.
// GL.INVALID_OPERATION is generated if ShaderSource is executed between the
// execution of Begin and the corresponding execution of End.
//
// ShaderSource is available in GL version 2.0 or greater.
func (gl *GL) ShaderSource(shader glbase.Shader, source ...string) {
	count := len(source)
	length := make([]int32, count)
	source_c := make([]unsafe.Pointer, count)
	for i, src := range source {
		length[i] = int32(len(src))
		if len(src) > 0 {
			source_c[i] = *(*unsafe.Pointer)(unsafe.Pointer(&src))
		} else {
			source_c[i] = unsafe.Pointer(uintptr(0))
		}
	}
	C.gl3_0_glShaderSource(gl.funcs, C.GLuint(shader), C.GLsizei(count), (**C.GLchar)(unsafe.Pointer(&source_c[0])), (*C.GLint)(unsafe.Pointer(&length[0])))
}

// LinkProgram links the program object specified by program. If any shader
// objects of type GL.VERTEX_SHADER are attached to program, they will be
// used to create an executable that will run on the programmable vertex
// processor. If any shader objects of type GL.FRAGMENT_SHADER are attached
// to program, they will be used to create an executable that will run on the
// programmable fragment processor.
//
// The status of the link operation will be stored as part of the program
// object's state. This value will be set to GL.TRUE if the program object
// was linked without errors and is ready for use, and GL.FALSE otherwise. It
// can be queried by calling GetProgramiv with arguments program and
// GL.LINK_STATUS.
//
// As a result of a successful link operation, all active user-defined
// uniform variables belonging to program will be initialized to 0, and each
// of the program object's active uniform variables will be assigned a
// location that can be queried by calling GetUniformLocation. Also, any
// active user-defined attribute variables that have not been bound to a
// generic vertex attribute index will be bound to one at this time.
//
// Linking of a program object can fail for a number of reasons as specified
// in the OpenGL Shading Language Specification. The following lists some of
// the conditions that will cause a link error.
//
//   - The number of active attribute variables supported by the
//     implementation has been exceeded.
//
//   - The storage limit for uniform variables has been exceeded.
//
//   - The number of active uniform variables supported by the implementation
//     has been exceeded.
//
//   - The main function is missing for the vertex shader or the fragment
//     shader.
//
//   - A varying variable actually used in the fragment shader is not
//     declared in the same way (or is not declared at all) in the vertex
//     shader.
//
//   - A reference to a function or variable name is unresolved.
//
//   - A shared global is declared with two different types or two different
//     initial values.
//
//   - One or more of the attached shader objects has not been successfully
//     compiled.
//
//   - Binding a generic attribute matrix caused some rows of the matrix to
//     fall outside the allowed maximum of GL.MAX_VERTEX_ATTRIBS.
//
//   - Not enough contiguous vertex attribute slots could be found to bind
//     attribute matrices.
//
// When a program object has been successfully linked, the program object can
// be made part of current state by calling UseProgram. Whether or not the
// link operation was successful, the program object's information log will
// be overwritten. The information log can be retrieved by calling
// GetProgramInfoLog.
//
// LinkProgram will also install the generated executables as part of the
// current rendering state if the link operation was successful and the
// specified program object is already currently in use as a result of a
// previous call to UseProgram. If the program object currently in use is
// relinked unsuccessfully, its link status will be set to GL.FALSE , but the
// executables and associated state will remain part of the current state
// until a subsequent call to UseProgram removes it from use. After it is
// removed from use, it cannot be made part of current state until it has
// been successfully relinked.
//
// If program contains shader objects of type GL.VERTEX_SHADER but does not
// contain shader objects of type GL.FRAGMENT_SHADER, the vertex shader will
// be linked against the implicit interface for fixed functionality fragment
// processing. Similarly, if program contains shader objects of type
// GL.FRAGMENT_SHADER but it does not contain shader objects of type
// GL.VERTEX_SHADER, the fragment shader will be linked against the implicit
// interface for fixed functionality vertex processing.
//
// The program object's information log is updated and the program is
// generated at the time of the link operation. After the link operation,
// applications are free to modify attached shader objects, compile attached
// shader objects, detach shader objects, delete shader objects, and attach
// additional shader objects. None of these operations affects the
// information log or the program that is part of the program object.
//
// If the link operation is unsuccessful, any information about a previous
// link operation on program is lost (a failed link does not restore the
// old state of program). Certain information can still be retrieved
// from program even after an unsuccessful link operation. See for instance
// GetActiveAttrib and GetActiveUniform.
//
// Error GL.INVALID_VALUE is generated if program is not a value generated by
// OpenGL. GL.INVALID_OPERATION is generated if program is not a program
// object. GL.INVALID_OPERATION is generated if LinkProgram is executed
// between the execution of Begin and the corresponding execution of End.
//
// LinkProgram is available in GL version 2.0 or greater.
func (gl *GL) LinkProgram(program glbase.Program) {
	C.gl3_0_glLinkProgram(gl.funcs, C.GLuint(program))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glIsShader.xml
func (gl *GL) IsShader(shader glbase.Shader) bool {
	glresult := C.gl3_0_glIsShader(gl.funcs, C.GLuint(shader))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glIsProgram.xml
func (gl *GL) IsProgram(program glbase.Program) bool {
	glresult := C.gl3_0_glIsProgram(gl.funcs, C.GLuint(program))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// GetVertexAttribiv returns in params the value of a generic vertex attribute
// parameter. The generic vertex attribute to be queried is specified by
// index, and the parameter to be queried is specified by pname.
//
// The accepted parameter names are as follows:
//
//   GL.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING
//       params returns a single value, the name of the buffer object
//       currently bound to the binding point corresponding to generic vertex
//       attribute array index. If no buffer object is bound, 0 is returned.
//       The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_ENABLED
//       params returns a single value that is non-zero (true) if the vertex
//       attribute array for index is enabled and 0 (false) if it is
//       disabled. The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_SIZE
//       params returns a single value, the size of the vertex attribute
//       array for index. The size is the number of values for each element
//       of the vertex attribute array, and it will be 1, 2, 3, or 4. The
//       initial value is 4.
//
//   GL.VERTEX_ATTRIB_ARRAY_STRIDE
//       params returns a single value, the array stride for (number of bytes
//       between successive elements in) the vertex attribute array for
//       index. A value of 0 indicates that the array elements are stored
//       sequentially in memory. The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_TYPE
//       params returns a single value, a symbolic constant indicating the
//       array type for the vertex attribute array for index. Possible values
//       are GL.BYTE, GL.UNSIGNED_BYTE, GL.SHORT, GL.UNSIGNED_SHORT, GL.INT,
//       GL.UNSIGNED_INT, GL.FLOAT, and GL.DOUBLE. The initial value is
//       GL.FLOAT.
//
//   GL.VERTEX_ATTRIB_ARRAY_NORMALIZED
//       params returns a single value that is non-zero (true) if fixed-point
//       data types for the vertex attribute array indicated by index are
//       normalized when they are converted to floating point, and 0 (false)
//       otherwise. The initial value is 0.
//
//   GL.CURRENT_VERTEX_ATTRIB
//       params returns four values that represent the current value for the
//       generic vertex attribute specified by index. Generic vertex
//       attribute 0 is unique in that it has no current state, so an error
//       will be generated if index is 0. The initial value for all other
//       generic vertex attributes is (0,0,0,1).
//
// All of the parameters except GL.CURRENT_VERTEX_ATTRIB represent
// client-side state.
//
// Error GL.INVALID_VALUE is generated if index is greater than or equal to
// GL.MAX_VERTEX_ATTRIBS. GL.INVALID_ENUM is generated if pname is not an
// accepted value.  GL.INVALID_OPERATION is generated if index is 0 and pname
// is GL.CURRENT_VERTEX_ATTRIB.
//
// GetVertexAttribiv is available in GL version 2.0 or greater.
func (gl *GL) GetVertexAttribiv(index glbase.Attrib, pname glbase.Enum, params []int32) {
	var params_c [4]int32
	C.gl3_0_glGetVertexAttribiv(gl.funcs, C.GLuint(index), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params_c[0])))
	copy(params, params_c[:])
}

// GetVertexAttribfv returns in params the value of a generic vertex attribute
// parameter. The generic vertex attribute to be queried is specified by
// index, and the parameter to be queried is specified by pname.
//
// The accepted parameter names are as follows:
//
//   GL.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING
//       params returns a single value, the name of the buffer object
//       currently bound to the binding point corresponding to generic vertex
//       attribute array index. If no buffer object is bound, 0 is returned.
//       The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_ENABLED
//       params returns a single value that is non-zero (true) if the vertex
//       attribute array for index is enabled and 0 (false) if it is
//       disabled. The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_SIZE
//       params returns a single value, the size of the vertex attribute
//       array for index. The size is the number of values for each element
//       of the vertex attribute array, and it will be 1, 2, 3, or 4. The
//       initial value is 4.
//
//   GL.VERTEX_ATTRIB_ARRAY_STRIDE
//       params returns a single value, the array stride for (number of bytes
//       between successive elements in) the vertex attribute array for
//       index. A value of 0 indicates that the array elements are stored
//       sequentially in memory. The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_TYPE
//       params returns a single value, a symbolic constant indicating the
//       array type for the vertex attribute array for index. Possible values
//       are GL.BYTE, GL.UNSIGNED_BYTE, GL.SHORT, GL.UNSIGNED_SHORT, GL.INT,
//       GL.UNSIGNED_INT, GL.FLOAT, and GL.DOUBLE. The initial value is
//       GL.FLOAT.
//
//   GL.VERTEX_ATTRIB_ARRAY_NORMALIZED
//       params returns a single value that is non-zero (true) if fixed-point
//       data types for the vertex attribute array indicated by index are
//       normalized when they are converted to floating point, and 0 (false)
//       otherwise. The initial value is 0.
//
//   GL.CURRENT_VERTEX_ATTRIB
//       params returns four values that represent the current value for the
//       generic vertex attribute specified by index. Generic vertex
//       attribute 0 is unique in that it has no current state, so an error
//       will be generated if index is 0. The initial value for all other
//       generic vertex attributes is (0,0,0,1).
//
// All of the parameters except GL.CURRENT_VERTEX_ATTRIB represent
// client-side state.
//
// Error GL.INVALID_VALUE is generated if index is greater than or equal to
// GL.MAX_VERTEX_ATTRIBS. GL.INVALID_ENUM is generated if pname is not an
// accepted value.  GL.INVALID_OPERATION is generated if index is 0 and pname
// is GL.CURRENT_VERTEX_ATTRIB.
//
// GetVertexAttribfv is available in GL version 2.0 or greater.
func (gl *GL) GetVertexAttribfv(index glbase.Attrib, pname glbase.Enum, params []float32) {
	var params_c [4]float32
	C.gl3_0_glGetVertexAttribfv(gl.funcs, C.GLuint(index), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params_c[0])))
	copy(params, params_c[:])
}

// GetVertexAttribdv returns in params the value of a generic vertex attribute
// parameter. The generic vertex attribute to be queried is specified by
// index, and the parameter to be queried is specified by pname.
//
// The accepted parameter names are as follows:
//
//   GL.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING
//       params returns a single value, the name of the buffer object
//       currently bound to the binding point corresponding to generic vertex
//       attribute array index. If no buffer object is bound, 0 is returned.
//       The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_ENABLED
//       params returns a single value that is non-zero (true) if the vertex
//       attribute array for index is enabled and 0 (false) if it is
//       disabled. The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_SIZE
//       params returns a single value, the size of the vertex attribute
//       array for index. The size is the number of values for each element
//       of the vertex attribute array, and it will be 1, 2, 3, or 4. The
//       initial value is 4.
//
//   GL.VERTEX_ATTRIB_ARRAY_STRIDE
//       params returns a single value, the array stride for (number of bytes
//       between successive elements in) the vertex attribute array for
//       index. A value of 0 indicates that the array elements are stored
//       sequentially in memory. The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_TYPE
//       params returns a single value, a symbolic constant indicating the
//       array type for the vertex attribute array for index. Possible values
//       are GL.BYTE, GL.UNSIGNED_BYTE, GL.SHORT, GL.UNSIGNED_SHORT, GL.INT,
//       GL.UNSIGNED_INT, GL.FLOAT, and GL.DOUBLE. The initial value is
//       GL.FLOAT.
//
//   GL.VERTEX_ATTRIB_ARRAY_NORMALIZED
//       params returns a single value that is non-zero (true) if fixed-point
//       data types for the vertex attribute array indicated by index are
//       normalized when they are converted to floating point, and 0 (false)
//       otherwise. The initial value is 0.
//
//   GL.CURRENT_VERTEX_ATTRIB
//       params returns four values that represent the current value for the
//       generic vertex attribute specified by index. Generic vertex
//       attribute 0 is unique in that it has no current state, so an error
//       will be generated if index is 0. The initial value for all other
//       generic vertex attributes is (0,0,0,1).
//
// All of the parameters except GL.CURRENT_VERTEX_ATTRIB represent
// client-side state.
//
// Error GL.INVALID_VALUE is generated if index is greater than or equal to
// GL.MAX_VERTEX_ATTRIBS. GL.INVALID_ENUM is generated if pname is not an
// accepted value.  GL.INVALID_OPERATION is generated if index is 0 and pname
// is GL.CURRENT_VERTEX_ATTRIB.
//
// GetVertexAttribdv is available in GL version 2.0 or greater.
func (gl *GL) GetVertexAttribdv(index glbase.Attrib, pname glbase.Enum, params []float64) {
	var params_c [4]float64
	C.gl3_0_glGetVertexAttribdv(gl.funcs, C.GLuint(index), C.GLenum(pname), (*C.GLdouble)(unsafe.Pointer(&params_c[0])))
	copy(params, params_c[:])
}

// GetUniformiv returns in params the value of the specified uniform
// variable. The type of the uniform variable specified by location
// determines the number of values returned. If the uniform variable is
// defined in the shader as a boolean, int, or float, a single value will be
// returned. If it is defined as a vec2, ivec2, or bvec2, two values will be
// returned. If it is defined as a vec3, ivec3, or bvec3, three values will
// be returned, and so on. To query values stored in uniform variables
// declared as arrays, call GetUniformiv for each element of the array. To
// query values stored in uniform variables declared as structures, call
// GetUniformiv for each field in the structure. The values for uniform
// variables declared as a matrix will be returned in column major order.
//
// The locations assigned to uniform variables are not known until the
// program object is linked. After linking has occurred, the command
// GetUniformLocation can be used to obtain the location of a uniform
// variable. This location value can then be passed to GetUniformiv in order
// to query the current value of the uniform variable. After a program object
// has been linked successfully, the index values for uniform variables
// remain fixed until the next link command occurs. The uniform variable
// values can only be queried after a link if the link was successful.
//
// Error GL.INVALID_VALUE is generated if program is not a value generated by
// OpenGL. GL.INVALID_OPERATION is generated if program is not a program
// object. GL.INVALID_OPERATION is generated if program has not been
// successfully linked. GL.INVALID_OPERATION is generated if location does
// not correspond to a valid uniform variable location for the specified
// program object. GL.INVALID_OPERATION is generated if GetUniformiv is
// executed between the execution of Begin and the corresponding execution of
// End.
//
// GetUniformiv is available in GL version 2.0 or greater.
func (gl *GL) GetUniformiv(program glbase.Program, location glbase.Uniform, params []int32) {
	var params_c [4]int32
	C.gl3_0_glGetUniformiv(gl.funcs, C.GLuint(program), C.GLint(location), (*C.GLint)(unsafe.Pointer(&params_c[0])))
	copy(params, params_c[:])
}

// GetUniformfv returns in params the value of the specified uniform
// variable. The type of the uniform variable specified by location
// determines the number of values returned. If the uniform variable is
// defined in the shader as a boolean, int, or float, a single value will be
// returned. If it is defined as a vec2, ivec2, or bvec2, two values will be
// returned. If it is defined as a vec3, ivec3, or bvec3, three values will
// be returned, and so on. To query values stored in uniform variables
// declared as arrays, call GetUniformfv for each element of the array. To
// query values stored in uniform variables declared as structures, call
// GetUniformfv for each field in the structure. The values for uniform
// variables declared as a matrix will be returned in column major order.
//
// The locations assigned to uniform variables are not known until the
// program object is linked. After linking has occurred, the command
// GetUniformLocation can be used to obtain the location of a uniform
// variable. This location value can then be passed to GetUniformfv in order
// to query the current value of the uniform variable. After a program object
// has been linked successfully, the index values for uniform variables
// remain fixed until the next link command occurs. The uniform variable
// values can only be queried after a link if the link was successful.
//
// Error GL.INVALID_VALUE is generated if program is not a value generated by
// OpenGL. GL.INVALID_OPERATION is generated if program is not a program
// object. GL.INVALID_OPERATION is generated if program has not been
// successfully linked. GL.INVALID_OPERATION is generated if location does
// not correspond to a valid uniform variable location for the specified
// program object. GL.INVALID_OPERATION is generated if GetUniformfv is
// executed between the execution of Begin and the corresponding execution of
// End.
//
// GetUniformfv is available in GL version 2.0 or greater.
func (gl *GL) GetUniformfv(program glbase.Program, location glbase.Uniform, params []float32) {
	var params_c [4]float32
	C.gl3_0_glGetUniformfv(gl.funcs, C.GLuint(program), C.GLint(location), (*C.GLfloat)(unsafe.Pointer(&params_c[0])))
	copy(params, params_c[:])
}

// GetUniformLocation returns an integer that represents the location of a
// specific uniform variable within a program object. name must be an active
// uniform variable name in program that is not a structure, an array of
// structures, or a subcomponent of a vector or a matrix. This function
// returns -1 if name does not correspond to an active uniform variable in
// program or if name starts with the reserved prefix "gl_".
//
// Uniform variables that are structures or arrays of structures may be
// queried by calling GetUniformLocation for each field within the
// structure. The array element operator "[]" and the structure field
// operator "." may be used in name in order to select elements within an
// array or fields within a structure. The result of using these operators is
// not allowed to be another structure, an array of structures, or a
// subcomponent of a vector or a matrix. Except if the last part of name
// indicates a uniform variable array, the location of the first element of
// an array can be retrieved by using the name of the array, or by using the
// name appended by "[0]".
//
// The actual locations assigned to uniform variables are not known until the
// program object is linked successfully. After linking has occurred, the
// command GetUniformLocation can be used to obtain the location of a
// uniform variable. This location value can then be passed to Uniform to
// set the value of the uniform variable or to GetUniform in order to query
// the current value of the uniform variable. After a program object has been
// linked successfully, the index values for uniform variables remain fixed
// until the next link command occurs. Uniform variable locations and values
// can only be queried after a link if the link was successful.
//
// Error GL.INVALID_VALUE is generated if program is not a value generated by
// OpenGL. GL.INVALID_OPERATION is generated if program is not a program object.
// GL.INVALID_OPERATION is generated if program has not been successfully
// linked. GL.INVALID_OPERATION is generated if GetUniformLocation is executed
// between the execution of Begin and the corresponding execution of End.
//
// GetUniformLocation is available in GL version 2.0 or greater.
func (gl *GL) GetUniformLocation(program glbase.Program, name string) glbase.Uniform {
	name_cstr := C.CString(name)
	glresult := C.gl3_0_glGetUniformLocation(gl.funcs, C.GLuint(program), (*C.GLchar)(name_cstr))
	C.free(unsafe.Pointer(name_cstr))
	return glbase.Uniform(glresult)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetShaderSource.xml
func (gl *GL) GetShaderSource(shader glbase.Shader, bufSize int32, length []int32, source []byte) {
	C.gl3_0_glGetShaderSource(gl.funcs, C.GLuint(shader), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLchar)(unsafe.Pointer(&source[0])))
}

// GetShaderInfoLog returns the information log for the specified shader
// object. The information log for a shader object is modified when the
// shader is compiled.
//
// The information log for a shader object is a string that may contain
// diagnostic messages, warning messages, and other information about the
// last compile operation. When a shader object is created, its information
// log will be a string of length 0, and the size of the current log can be
// obtained by calling GetShaderiv with the value GL.INFO_LOG_LENGTH.
//
// The information log for a shader object is the OpenGL implementer's
// primary mechanism for conveying information about the compilation process.
// Therefore, the information log can be helpful to application developers
// during the development process, even when compilation is successful.
// Application developers should not expect different OpenGL implementations
// to produce identical information logs.
//
// Error GL.INVALID_VALUE is generated if shader is not a value generated by
// OpenGL. GL.INVALID_OPERATION is generated if shader is not a shader
// object. GL.INVALID_VALUE is generated if maxLength is less than 0.
// GL.INVALID_OPERATION is generated if GetShaderInfoLog is executed
// between the execution of Begin and the corresponding execution of End.
//
// GetShaderInfoLog is available in GL version 2.0 or greater.
func (gl *GL) GetShaderInfoLog(shader glbase.Shader) []byte {
	var params [1]int32
	var length int32
	gl.GetShaderiv(shader, INFO_LOG_LENGTH, params[:])
	bufSize := params[0]
	infoLog := make([]byte, int(bufSize))
	C.gl3_0_glGetShaderInfoLog(gl.funcs, C.GLuint(shader), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length)), (*C.GLchar)(unsafe.Pointer(&infoLog[0])))
	return infoLog
}

// GetShaderiv GetShader returns in params the value of a parameter for a specific
// shader object. The following parameters are defined:
//
//   GL.SHADER_TYPE
//     params returns GL.VERTEX_SHADER if shader is a vertex shader object,
//     and GL.FRAGMENT_SHADER if shader is a fragment shader object.
//
//   GL.DELETE_STATUS
//     params returns GL.TRUE if shader is currently flagged for deletion,
//     and GL.FALSE otherwise.
//
//   GL.COMPILE_STATUS
//     params returns GL.TRUE if the last compile operation on shader was
//     successful, and GL.FALSE otherwise.
//
//   GL.INFO_LOG_LENGTH
//     params returns the number of characters in the information log for
//     shader including the null termination character (the size of the
//     character buffer required to store the information log). If shader has
//     no information log, a value of 0 is returned.
//
//   GL.SHADER_SOURCE_LENGTH
//     params returns the length of the concatenation of the source strings
//     that make up the shader source for the shader, including the null
//     termination character. (the size of the character buffer
//     required to store the shader source). If no source code exists, 0 is
//     returned.
//
// Error GL.INVALID_VALUE is generated if shader is not a value generated by
// OpenGL. GL.INVALID_OPERATION is generated if shader does not refer to a
// shader object. GL.INVALID_ENUM is generated if pname is not an accepted
// value. GL.INVALID_OPERATION is generated if GetShader is executed
// between the execution of Begin and the corresponding execution of End.
//
// GetShaderiv is available in GL version 2.0 or greater.
func (gl *GL) GetShaderiv(shader glbase.Shader, pname glbase.Enum, params []int32) {
	var params_c [4]int32
	C.gl3_0_glGetShaderiv(gl.funcs, C.GLuint(shader), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params_c[0])))
	copy(params, params_c[:])
}

// GetProgramInfoLog returns the information log for the specified program
// object. The information log for a program object is modified when the
// program object is linked or validated.
//
// The information log for a program object is either an empty string, or a
// string containing information about the last link operation, or a string
// containing information about the last validation operation. It may contain
// diagnostic messages, warning messages, and other information. When a
// program object is created, its information log will be a string of length
// 0, and the size of the current log can be obtained by calling GetProgramiv
// with the value GL.INFO_LOG_LENGTH.
//
// Error GL.INVALID_VALUE is generated if program is not a value generated
// by OpenGL. GL.INVALID_OPERATION is generated if program is not a
// program object.
func (gl *GL) GetProgramInfoLog(program glbase.Program) []byte {
	var params [1]int32
	var length int32
	gl.GetProgramiv(program, INFO_LOG_LENGTH, params[:])
	bufSize := params[0]
	infoLog := make([]byte, int(bufSize))
	C.gl3_0_glGetProgramInfoLog(gl.funcs, C.GLuint(program), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length)), (*C.GLchar)(unsafe.Pointer(&infoLog[0])))
	return infoLog
}

// GetProgramiv returns in params the value of a parameter for a specific
// program object. The following parameters are defined:
//
//   GL.DELETE_STATUS
//       params returns GL.TRUE if program is currently flagged for deletion,
//       and GL.FALSE otherwise.
//
//   GL.LINK_STATUS
//       params returns GL.TRUE if the last link operation on program was
//       successful, and GL.FALSE otherwise.
//
//   GL.VALIDATE_STATUS
//       params returns GL.TRUE or if the last validation operation on
//       program was successful, and GL.FALSE otherwise.
//
//   GL.INFO_LOG_LENGTH
//       params returns the number of characters in the information log for
//       program including the null termination character (the size of
//       the character buffer required to store the information log). If
//       program has no information log, a value of 0 is returned.
//
//   GL.ATTACHED_SHADERS
//       params returns the number of shader objects attached to program.
//
//   GL.ACTIVE_ATTRIBUTES
//       params returns the number of active attribute variables for program.
//
//   GL.ACTIVE_ATTRIBUTE_MAX_LENGTH
//       params returns the length of the longest active attribute name for
//       program, including the null termination character (the size of
//       the character buffer required to store the longest attribute name).
//       If no active attributes exist, 0 is returned.
//
//   GL.ACTIVE_UNIFORMS
//       params returns the number of active uniform variables for program.
//
//   GL.ACTIVE_UNIFORM_MAX_LENGTH
//       params returns the length of the longest active uniform variable
//       name for program, including the null termination character (i.e.,
//       the size of the character buffer required to store the longest
//       uniform variable name). If no active uniform variables exist, 0 is
//       returned.
//
//   GL.TRANSFORM_FEEDBACK_BUFFER_MODE
//       params returns a symbolic constant indicating the buffer mode used
//       when transform feedback is active. This may be GL.SEPARATE_ATTRIBS
//       or GL.INTERLEAVED_ATTRIBS.
//
//   GL.TRANSFORM_FEEDBACK_VARYINGS
//       params returns the number of varying variables to capture in transform
//       feedback mode for the program.
//
//   GL.TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH
//       params returns the length of the longest variable name to be used for
//       transform feedback, including the null-terminator.
//
//   GL.GEOMETRY_VERTICES_OUT
//       params returns the maximum number of vertices that the geometry shader in
//       program will output.
//
//   GL.GEOMETRY_INPUT_TYPE
//       params returns a symbolic constant indicating the primitive type accepted
//       as input to the geometry shader contained in program.
//
//   GL.GEOMETRY_OUTPUT_TYPE
//       params returns a symbolic constant indicating the primitive type that will
//       be output by the geometry shader contained in program.
//
// GL.ACTIVE_UNIFORM_BLOCKS and GL.ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH are
// available only if the GL version 3.1 or greater.
//
// GL.GEOMETRY_VERTICES_OUT, GL.GEOMETRY_INPUT_TYPE and
// GL.GEOMETRY_OUTPUT_TYPE are accepted only if the GL version is 3.2 or
// greater.
//
// Error GL.INVALID_VALUE is generated if program is not a value generated by
// OpenGL. GL.INVALID_OPERATION is generated if program does not refer to a
// program object.  GL.INVALID_OPERATION is generated if pname is
// GL.GEOMETRY_VERTICES_OUT, GL.GEOMETRY_INPUT_TYPE, or
// GL.GEOMETRY_OUTPUT_TYPE, and program does not contain a geometry shader.
// GL.INVALID_ENUM is generated if pname is not an accepted value.
func (gl *GL) GetProgramiv(program glbase.Program, pname glbase.Enum, params []int32) {
	var params_c [4]int32
	C.gl3_0_glGetProgramiv(gl.funcs, C.GLuint(program), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params_c[0])))
	copy(params, params_c[:])
}

// GetAttribLocation queries the previously linked program object specified
// by program for the attribute variable specified by name and returns the
// index of the generic vertex attribute that is bound to that attribute
// variable. If name is a matrix attribute variable, the index of the first
// column of the matrix is returned. If the named attribute variable is not
// an active attribute in the specified program object or if name starts with
// the reserved prefix "gl_", a value of -1 is returned.
//
// The association between an attribute variable name and a generic attribute
// index can be specified at any time by calling BindAttribLocation.
// Attribute bindings do not go into effect until LinkProgram is called.
// After a program object has been linked successfully, the index values for
// attribute variables remain fixed until the next link command occurs. The
// attribute values can only be queried after a link if the link was
// successful. GetAttribLocation returns the binding that actually went
// into effect the last time LinkProgram was called for the specified
// program object. Attribute bindings that have been specified since the last
// link operation are not returned by GetAttribLocation.
//
// Error GL_INVALID_OPERATION is generated if program is not a value
// generated by OpenGL. GL_INVALID_OPERATION is generated if program is not
// a program object. GL_INVALID_OPERATION is generated if program has not
// been successfully linked.  GL_INVALID_OPERATION is generated if
// GetAttribLocation is executed between the execution of Begin and the
// corresponding execution of End.
//
// GetAttribLocation is available in GL version 2.0 or greater.
func (gl *GL) GetAttribLocation(program glbase.Program, name string) glbase.Attrib {
	name_cstr := C.CString(name)
	glresult := C.gl3_0_glGetAttribLocation(gl.funcs, C.GLuint(program), (*C.GLchar)(name_cstr))
	C.free(unsafe.Pointer(name_cstr))
	return glbase.Attrib(glresult)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetAttachedShaders.xml
func (gl *GL) GetAttachedShaders(program glbase.Program, maxCount int32, count []int, obj []uint32) {
	C.gl3_0_glGetAttachedShaders(gl.funcs, C.GLuint(program), C.GLsizei(maxCount), (*C.GLsizei)(unsafe.Pointer(&count[0])), (*C.GLuint)(unsafe.Pointer(&obj[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetActiveUniform.xml
func (gl *GL) GetActiveUniform(program glbase.Program, index uint32, bufSize int32, length []int32, size []int, gltype []glbase.Enum, name []byte) {
	C.gl3_0_glGetActiveUniform(gl.funcs, C.GLuint(program), C.GLuint(index), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLint)(unsafe.Pointer(&size[0])), (*C.GLenum)(unsafe.Pointer(&gltype[0])), (*C.GLchar)(unsafe.Pointer(&name[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetActiveAttrib.xml
func (gl *GL) GetActiveAttrib(program glbase.Program, index glbase.Attrib, bufSize int32, length []int32, size []int, gltype []glbase.Enum, name []byte) {
	C.gl3_0_glGetActiveAttrib(gl.funcs, C.GLuint(program), C.GLuint(index), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLint)(unsafe.Pointer(&size[0])), (*C.GLenum)(unsafe.Pointer(&gltype[0])), (*C.GLchar)(unsafe.Pointer(&name[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glEnableVertexAttribArray.xml
func (gl *GL) EnableVertexAttribArray(index glbase.Attrib) {
	C.gl3_0_glEnableVertexAttribArray(gl.funcs, C.GLuint(index))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glDisableVertexAttribArray.xml
func (gl *GL) DisableVertexAttribArray(index glbase.Attrib) {
	C.gl3_0_glDisableVertexAttribArray(gl.funcs, C.GLuint(index))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glDetachShader.xml
func (gl *GL) DetachShader(program glbase.Program, shader glbase.Shader) {
	C.gl3_0_glDetachShader(gl.funcs, C.GLuint(program), C.GLuint(shader))
}

// DeleteShader frees the memory and invalidates the name associated with
// the shader object specified by shader. This command effectively undoes the
// effects of a call to CreateShader.
//
// If a shader object to be deleted is attached to a program object, it will
// be flagged for deletion, but it will not be deleted until it is no longer
// attached to any program object, for any rendering context (it must
// be detached from wherever it was attached before it will be deleted). A
// value of 0 for shader will be silently ignored.
//
// To determine whether an object has been flagged for deletion, call
// GetShader with arguments shader and GL.DELETE_STATUS.
//
// Error GL.INVALID_VALUE is generated if shader is not a value generated by
// OpenGL.
//
// DeleteShader is available in GL version 2.0 or greater.
func (gl *GL) DeleteShader(shader glbase.Shader) {
	C.gl3_0_glDeleteShader(gl.funcs, C.GLuint(shader))
}

// DeleteProgram frees the memory and invalidates the name associated with
// the program object specified by program. This command effectively undoes
// the effects of a call to CreateProgram.
//
// If a program object is in use as part of current rendering state, it will
// be flagged for deletion, but it will not be deleted until it is no longer
// part of current state for any rendering context. If a program object to be
// deleted has shader objects attached to it, those shader objects will be
// automatically detached but not deleted unless they have already been
// flagged for deletion by a previous call to DeleteShader. A value of 0
// for program will be silently ignored.
//
// To determine whether a program object has been flagged for deletion, call
// GetProgram with arguments program and GL.DELETE_STATUS.
//
// Error GL.INVALID_VALUE is generated if program is not a value generated by
// OpenGL.
//
// DeleteProgram is available in GL version 2.0 or greater.
func (gl *GL) DeleteProgram(program glbase.Program) {
	C.gl3_0_glDeleteProgram(gl.funcs, C.GLuint(program))
}

// CreateShader creates an empty shader object and returns a non-zero value
// by which it can be referenced. A shader object is used to maintain the
// source code strings that define a shader. shaderType indicates the type of
// shader to be created.
//
// Two types of shaders are supported. A shader of type GL.VERTEX_SHADER is a
// shader that is intended to run on the programmable vertex processor and
// replace the fixed functionality vertex processing in OpenGL. A shader of
// type GL.FRAGMENT_SHADER is a shader that is intended to run on the
// programmable fragment processor and replace the fixed functionality
// fragment processing in OpenGL.
//
// When created, a shader object's GL.SHADER_TYPE parameter is set to either
// GL.VERTEX_SHADER or GL.FRAGMENT_SHADER, depending on the value of
// shaderType.
//
// Like display lists and texture objects, the name space for shader objects
// may be shared across a set of contexts, as long as the server sides of the
// contexts share the same address space. If the name space is shared across
// contexts, any attached objects and the data associated with those attached
// objects are shared as well.
//
// This function returns 0 if an error occurs creating the shader object.
//
// Error GL.INVALID_ENUM is generated if shaderType is not an accepted value.
// GL.INVALID_OPERATION is generated if CreateShader is executed between the
// execution of Begin and the corresponding execution of End.
//
// CreateShader is available in GL version 2.0 or greater.
func (gl *GL) CreateShader(gltype glbase.Enum) glbase.Shader {
	glresult := C.gl3_0_glCreateShader(gl.funcs, C.GLenum(gltype))
	return glbase.Shader(glresult)
}

// CreateProgram creates an empty program object and returns a non-zero
// value by which it can be referenced. A program object is an object to
// which shader objects can be attached. This provides a mechanism to specify
// the shader objects that will be linked to create a program. It also
// provides a means for checking the compatibility of the shaders that will
// be used to create a program (for instance, checking the compatibility
// between a vertex shader and a fragment shader). When no longer needed as
// part of a program object, shader objects can be detached.
//
// One or more executables are created in a program object by successfully
// attaching shader objects to it with AttachShader, successfully compiling
// the shader objects with CompileShader, and successfully linking the
// program object with LinkProgram. These executables are made part of
// current state when UseProgram is called. Program objects can be deleted
// by calling DeleteProgram. The memory associated with the program object
// will be deleted when it is no longer part of current rendering state for
// any context.
//
// Like display lists and texture objects, the name space for program objects
// may be shared across a set of contexts, as long as the server sides of the
// contexts share the same address space. If the name space is shared across
// contexts, any attached objects and the data associated with those attached
// objects are shared as well.
//
// Applications are responsible for providing the synchronization across API
// calls when objects are accessed from different execution threads.
//
// This function returns 0 if an error occurs creating the program object.
//
// Error GL.INVALID_OPERATION is generated if CreateProgram is executed
// between the execution of Begin and the corresponding execution of End.
//
// CreateProgram is available in GL version 2.0 or greater.
func (gl *GL) CreateProgram() glbase.Program {
	glresult := C.gl3_0_glCreateProgram(gl.funcs)
	return glbase.Program(glresult)
}

// CompileShader compiles the source code strings that have been stored in
// the shader object specified by shader.
//
// The compilation status will be stored as part of the shader object's
// state. This value will be set to GL.TRUE if the shader was compiled without
// errors and is ready for use, and GL.FALSE otherwise. It can be queried by
// calling GetShaderiv with arguments shader and GL.COMPILE_STATUS.
//
// Compilation of a shader can fail for a number of reasons as specified by
// the OpenGL Shading Language Specification. Whether or not the compilation
// was successful, information about the compilation can be obtained from the
// shader object's information log by calling GetShaderInfoLog.
//
// Error GL.INVALID_VALUE is generated if shader is not a value generated by
// OpenGL.  GL.INVALID_OPERATION is generated if shader is not a shader
// object.  GL.INVALID_OPERATION is generated if CompileShader is executed
// between the execution of Begin and the corresponding execution of End.
//
// CompileShader is available in GL version 2.0 or greater.
func (gl *GL) CompileShader(shader glbase.Shader) {
	C.gl3_0_glCompileShader(gl.funcs, C.GLuint(shader))
}

// BindAttribLocation associates a user-defined attribute variable in the program
// object specified by program with a generic vertex attribute index. The name
// parameter specifies the name of the vertex shader attribute variable to
// which index is to be bound. When program is made part of the current state,
// values provided via the generic vertex attribute index will modify the
// value of the user-defined attribute variable specified by name.
//
// If name refers to a matrix attribute variable, index refers to the first
// column of the matrix. Other matrix columns are then automatically bound to
// locations index+1 for a matrix of type mat2; index+1 and index+2 for a
// matrix of type mat3; and index+1, index+2, and index+3 for a matrix of
// type mat4.
//
// This command makes it possible for vertex shaders to use descriptive names
// for attribute variables rather than generic variables that are numbered
// from 0 to GL.MAX_VERTEX_ATTRIBS-1. The values sent to each generic
// attribute index are part of current state, just like standard vertex
// attributes such as color, normal, and vertex position. If a different
// program object is made current by calling UseProgram, the generic vertex
// attributes are tracked in such a way that the same values will be observed
// by attributes in the new program object that are also bound to index.
//
// Attribute variable name-to-generic attribute index bindings for a program
// object can be explicitly assigned at any time by calling
// BindAttribLocation. Attribute bindings do not go into effect until
// LinkProgram is called. After a program object has been linked
// successfully, the index values for generic attributes remain fixed (and
// their values can be queried) until the next link command occurs.
//
// Applications are not allowed to bind any of the standard OpenGL vertex
// attributes using this command, as they are bound automatically when
// needed. Any attribute binding that occurs after the program object has
// been linked will not take effect until the next time the program object is
// linked.
//
// If name was bound previously, that information is lost. Thus you cannot
// bind one user-defined attribute variable to multiple indices, but you can
// bind multiple user-defined attribute variables to the same index.
//
// Applications are allowed to bind more than one user-defined attribute
// variable to the same generic vertex attribute index. This is called
// aliasing, and it is allowed only if just one of the aliased attributes is
// active in the executable program, or if no path through the shader
// consumes more than one attribute of a set of attributes aliased to the
// same location. The compiler and linker are allowed to assume that no
// aliasing is done and are free to employ optimizations that work only in
// the absence of aliasing. OpenGL implementations are not required to do
// error checking to detect aliasing. Because there is no way to bind
// standard attributes, it is not possible to alias generic attributes with
// conventional ones (except for generic attribute 0).
//
// BindAttribLocation can be called before any vertex shader objects are
// bound to the specified program object. It is also permissible to bind a
// generic attribute index to an attribute variable name that is never used
// in a vertex shader.
//
// Active attributes that are not explicitly bound will be bound by the
// linker when LinkProgram is called. The locations assigned can be queried
// by calling GetAttribLocation.
//
// Error GL.INVALID_VALUE is generated if index is greater than or equal to
// GL.MAX_VERTEX_ATTRIBS.
// GL.INVALID_OPERATION is generated if name starts with the reserved prefix "gl_".
// GL.INVALID_VALUE is generated if program is not a value generated by OpenGL.
// GL.INVALID_OPERATION is generated if program is not a program object.
// GL.INVALID_OPERATION is generated if BindAttribLocation is executed
// between the execution of Begin and the corresponding execution of End.
//
// BindAttribLocation is available in GL version 2.0 or greater.
func (gl *GL) BindAttribLocation(program glbase.Program, index glbase.Attrib, name string) {
	name_cstr := C.CString(name)
	C.gl3_0_glBindAttribLocation(gl.funcs, C.GLuint(program), C.GLuint(index), (*C.GLchar)(name_cstr))
	C.free(unsafe.Pointer(name_cstr))
}

// AttachShader attaches a shader object to a program object.
//
// In order to create an executable, there must be a way to specify the list
// of things that will be linked together. Program objects provide this
// mechanism. Shaders that are to be linked together in a program object must
// first be attached to that program object. This indicates that shader will
// be included in link operations that will be performed on program.
//
// All operations that can be performed on a shader object are valid whether
// or not the shader object is attached to a program object. It is
// permissible to attach a shader object to a program object before source
// code has been loaded into the shader object or before the shader object
// has been compiled. It is permissible to attach multiple shader objects of
// the same type because each may contain a portion of the complete shader.
// It is also permissible to attach a shader object to more than one program
// object. If a shader object is deleted while it is attached to a program
// object, it will be flagged for deletion, and deletion will not occur until
// DetachShader is called to detach it from all program objects to which it
// is attached.
//
// Error GL.INVALID_VALUE is generated if either program or shader is not a
// value generated by OpenGL. GL.INVALID_OPERATION is generated if program
// is not a program object. GL.INVALID_OPERATION is generated if shader is
// not a shader object. GL.INVALID_OPERATION is generated if shader is
// already attached to program. GL.INVALID_OPERATION is generated if
// AttachShader is executed between the execution of Begin and the
// corresponding execution of End.
//
// AttachShader is available in GL version 2.0 or greater.
func (gl *GL) AttachShader(program glbase.Program, shader glbase.Shader) {
	C.gl3_0_glAttachShader(gl.funcs, C.GLuint(program), C.GLuint(shader))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glStencilMaskSeparate.xml
func (gl *GL) StencilMaskSeparate(face glbase.Enum, mask uint32) {
	C.gl3_0_glStencilMaskSeparate(gl.funcs, C.GLenum(face), C.GLuint(mask))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glStencilFuncSeparate.xml
func (gl *GL) StencilFuncSeparate(face, glfunc glbase.Enum, ref int32, mask uint32) {
	C.gl3_0_glStencilFuncSeparate(gl.funcs, C.GLenum(face), C.GLenum(glfunc), C.GLint(ref), C.GLuint(mask))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glStencilOpSeparate.xml
func (gl *GL) StencilOpSeparate(face, sfail, dpfail, dppass glbase.Enum) {
	C.gl3_0_glStencilOpSeparate(gl.funcs, C.GLenum(face), C.GLenum(sfail), C.GLenum(dpfail), C.GLenum(dppass))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glDrawBuffers.xml
func (gl *GL) DrawBuffers(n int, bufs []glbase.Enum) {
	C.gl3_0_glDrawBuffers(gl.funcs, C.GLsizei(n), (*C.GLenum)(unsafe.Pointer(&bufs[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glBlendEquationSeparate.xml
func (gl *GL) BlendEquationSeparate(modeRGB, modeAlpha glbase.Enum) {
	C.gl3_0_glBlendEquationSeparate(gl.funcs, C.GLenum(modeRGB), C.GLenum(modeAlpha))
}

// UniformMatrix4x3fv modifies the value of a uniform variable or a uniform
// variable array. The location of the uniform variable to be modified is
// specified by location, which should be a value returned by GetUniformLocation.
// UniformMatrix4x3fv operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions UniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to
// modify a matrix or an array of matrices. The numbers in the function name
// are interpreted as the dimensionality of the matrix. The number 2
// indicates a 2x2 matrix (4 values), the number 3 indicates a 3x3 matrix (9
// values), and the number 4 indicates a 4x4 matrix (16 values). Non-square
// matrix dimensionality is explicit, with the first number representing the
// number of columns and the second number representing the number of rows.
// For example, 2x4 indicates a 2x4 matrix with 2 columns and 4 rows (8
// values). The length of the provided slice must be a multiple of the number
// of values per matrix, to update one or more consecutive matrices.
//
// If transpose is false, each matrix is assumed to be supplied in column
// major order. If transpose is true, each matrix is assumed to be supplied
// in row major order.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) UniformMatrix4x3fv(location glbase.Uniform, transpose bool, value []float32) {
	if len(value) == 0 {
		return
	}
	if len(value)%(4*3) != 0 {
		panic("invalid value length for UniformMatrix4x3fv")
	}
	count := len(value) / (4 * 3)
	C.gl3_0_glUniformMatrix4x3fv(gl.funcs, C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// UniformMatrix3x4fv modifies the value of a uniform variable or a uniform
// variable array. The location of the uniform variable to be modified is
// specified by location, which should be a value returned by GetUniformLocation.
// UniformMatrix3x4fv operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions UniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to
// modify a matrix or an array of matrices. The numbers in the function name
// are interpreted as the dimensionality of the matrix. The number 2
// indicates a 2x2 matrix (4 values), the number 3 indicates a 3x3 matrix (9
// values), and the number 4 indicates a 4x4 matrix (16 values). Non-square
// matrix dimensionality is explicit, with the first number representing the
// number of columns and the second number representing the number of rows.
// For example, 2x4 indicates a 2x4 matrix with 2 columns and 4 rows (8
// values). The length of the provided slice must be a multiple of the number
// of values per matrix, to update one or more consecutive matrices.
//
// If transpose is false, each matrix is assumed to be supplied in column
// major order. If transpose is true, each matrix is assumed to be supplied
// in row major order.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) UniformMatrix3x4fv(location glbase.Uniform, transpose bool, value []float32) {
	if len(value) == 0 {
		return
	}
	if len(value)%(3*4) != 0 {
		panic("invalid value length for UniformMatrix3x4fv")
	}
	count := len(value) / (3 * 4)
	C.gl3_0_glUniformMatrix3x4fv(gl.funcs, C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// UniformMatrix4x2fv modifies the value of a uniform variable or a uniform
// variable array. The location of the uniform variable to be modified is
// specified by location, which should be a value returned by GetUniformLocation.
// UniformMatrix4x2fv operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions UniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to
// modify a matrix or an array of matrices. The numbers in the function name
// are interpreted as the dimensionality of the matrix. The number 2
// indicates a 2x2 matrix (4 values), the number 3 indicates a 3x3 matrix (9
// values), and the number 4 indicates a 4x4 matrix (16 values). Non-square
// matrix dimensionality is explicit, with the first number representing the
// number of columns and the second number representing the number of rows.
// For example, 2x4 indicates a 2x4 matrix with 2 columns and 4 rows (8
// values). The length of the provided slice must be a multiple of the number
// of values per matrix, to update one or more consecutive matrices.
//
// If transpose is false, each matrix is assumed to be supplied in column
// major order. If transpose is true, each matrix is assumed to be supplied
// in row major order.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) UniformMatrix4x2fv(location glbase.Uniform, transpose bool, value []float32) {
	if len(value) == 0 {
		return
	}
	if len(value)%(4*2) != 0 {
		panic("invalid value length for UniformMatrix4x2fv")
	}
	count := len(value) / (4 * 2)
	C.gl3_0_glUniformMatrix4x2fv(gl.funcs, C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// UniformMatrix2x4fv modifies the value of a uniform variable or a uniform
// variable array. The location of the uniform variable to be modified is
// specified by location, which should be a value returned by GetUniformLocation.
// UniformMatrix2x4fv operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions UniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to
// modify a matrix or an array of matrices. The numbers in the function name
// are interpreted as the dimensionality of the matrix. The number 2
// indicates a 2x2 matrix (4 values), the number 3 indicates a 3x3 matrix (9
// values), and the number 4 indicates a 4x4 matrix (16 values). Non-square
// matrix dimensionality is explicit, with the first number representing the
// number of columns and the second number representing the number of rows.
// For example, 2x4 indicates a 2x4 matrix with 2 columns and 4 rows (8
// values). The length of the provided slice must be a multiple of the number
// of values per matrix, to update one or more consecutive matrices.
//
// If transpose is false, each matrix is assumed to be supplied in column
// major order. If transpose is true, each matrix is assumed to be supplied
// in row major order.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) UniformMatrix2x4fv(location glbase.Uniform, transpose bool, value []float32) {
	if len(value) == 0 {
		return
	}
	if len(value)%(2*4) != 0 {
		panic("invalid value length for UniformMatrix2x4fv")
	}
	count := len(value) / (2 * 4)
	C.gl3_0_glUniformMatrix2x4fv(gl.funcs, C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// UniformMatrix3x2fv modifies the value of a uniform variable or a uniform
// variable array. The location of the uniform variable to be modified is
// specified by location, which should be a value returned by GetUniformLocation.
// UniformMatrix3x2fv operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions UniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to
// modify a matrix or an array of matrices. The numbers in the function name
// are interpreted as the dimensionality of the matrix. The number 2
// indicates a 2x2 matrix (4 values), the number 3 indicates a 3x3 matrix (9
// values), and the number 4 indicates a 4x4 matrix (16 values). Non-square
// matrix dimensionality is explicit, with the first number representing the
// number of columns and the second number representing the number of rows.
// For example, 2x4 indicates a 2x4 matrix with 2 columns and 4 rows (8
// values). The length of the provided slice must be a multiple of the number
// of values per matrix, to update one or more consecutive matrices.
//
// If transpose is false, each matrix is assumed to be supplied in column
// major order. If transpose is true, each matrix is assumed to be supplied
// in row major order.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) UniformMatrix3x2fv(location glbase.Uniform, transpose bool, value []float32) {
	if len(value) == 0 {
		return
	}
	if len(value)%(3*2) != 0 {
		panic("invalid value length for UniformMatrix3x2fv")
	}
	count := len(value) / (3 * 2)
	C.gl3_0_glUniformMatrix3x2fv(gl.funcs, C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// UniformMatrix2x3fv modifies the value of a uniform variable or a uniform
// variable array. The location of the uniform variable to be modified is
// specified by location, which should be a value returned by GetUniformLocation.
// UniformMatrix2x3fv operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions UniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv are used to
// modify a matrix or an array of matrices. The numbers in the function name
// are interpreted as the dimensionality of the matrix. The number 2
// indicates a 2x2 matrix (4 values), the number 3 indicates a 3x3 matrix (9
// values), and the number 4 indicates a 4x4 matrix (16 values). Non-square
// matrix dimensionality is explicit, with the first number representing the
// number of columns and the second number representing the number of rows.
// For example, 2x4 indicates a 2x4 matrix with 2 columns and 4 rows (8
// values). The length of the provided slice must be a multiple of the number
// of values per matrix, to update one or more consecutive matrices.
//
// If transpose is false, each matrix is assumed to be supplied in column
// major order. If transpose is true, each matrix is assumed to be supplied
// in row major order.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) UniformMatrix2x3fv(location glbase.Uniform, transpose bool, value []float32) {
	if len(value) == 0 {
		return
	}
	if len(value)%(2*3) != 0 {
		panic("invalid value length for UniformMatrix2x3fv")
	}
	count := len(value) / (2 * 3)
	C.gl3_0_glUniformMatrix2x3fv(gl.funcs, C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glIsVertexArray.xml
func (gl *GL) IsVertexArray(array uint32) bool {
	glresult := C.gl3_0_glIsVertexArray(gl.funcs, C.GLuint(array))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGenVertexArrays.xml
func (gl *GL) GenVertexArrays(n int, arrays []uint32) {
	C.gl3_0_glGenVertexArrays(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&arrays[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glDeleteVertexArrays.xml
func (gl *GL) DeleteVertexArrays(n int, arrays []uint32) {
	C.gl3_0_glDeleteVertexArrays(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&arrays[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glBindVertexArray.xml
func (gl *GL) BindVertexArray(array uint32) {
	C.gl3_0_glBindVertexArray(gl.funcs, C.GLuint(array))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glFlushMappedBufferRange.xml
func (gl *GL) FlushMappedBufferRange(target glbase.Enum, offset, length int) {
	C.gl3_0_glFlushMappedBufferRange(gl.funcs, C.GLenum(target), C.GLintptr(offset), C.GLsizeiptr(length))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glFramebufferTextureLayer.xml
func (gl *GL) FramebufferTextureLayer(target, attachment glbase.Enum, texture glbase.Texture, level int, layer int32) {
	C.gl3_0_glFramebufferTextureLayer(gl.funcs, C.GLenum(target), C.GLenum(attachment), C.GLuint(texture), C.GLint(level), C.GLint(layer))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRenderbufferStorageMultisample.xml
func (gl *GL) RenderbufferStorageMultisample(target glbase.Enum, samples int32, internalFormat glbase.Enum, width, height int) {
	C.gl3_0_glRenderbufferStorageMultisample(gl.funcs, C.GLenum(target), C.GLsizei(samples), C.GLenum(internalFormat), C.GLsizei(width), C.GLsizei(height))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glBlitFramebuffer.xml
func (gl *GL) BlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1 int32, mask glbase.Bitfield, filter glbase.Enum) {
	C.gl3_0_glBlitFramebuffer(gl.funcs, C.GLint(srcX0), C.GLint(srcY0), C.GLint(srcX1), C.GLint(srcY1), C.GLint(dstX0), C.GLint(dstY0), C.GLint(dstX1), C.GLint(dstY1), C.GLbitfield(mask), C.GLenum(filter))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGenerateMipmap.xml
func (gl *GL) GenerateMipmap(target glbase.Enum) {
	C.gl3_0_glGenerateMipmap(gl.funcs, C.GLenum(target))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetFramebufferAttachmentParameteriv.xml
func (gl *GL) GetFramebufferAttachmentParameteriv(target, attachment, pname glbase.Enum, params []int32) {
	C.gl3_0_glGetFramebufferAttachmentParameteriv(gl.funcs, C.GLenum(target), C.GLenum(attachment), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glFramebufferRenderbuffer.xml
func (gl *GL) FramebufferRenderbuffer(target, attachment, renderbuffertarget glbase.Enum, renderbuffer glbase.Renderbuffer) {
	C.gl3_0_glFramebufferRenderbuffer(gl.funcs, C.GLenum(target), C.GLenum(attachment), C.GLenum(renderbuffertarget), C.GLuint(renderbuffer))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glFramebufferTexture3D.xml
func (gl *GL) FramebufferTexture3D(target, attachment, textarget glbase.Enum, texture glbase.Texture, level int, zoffset int32) {
	C.gl3_0_glFramebufferTexture3D(gl.funcs, C.GLenum(target), C.GLenum(attachment), C.GLenum(textarget), C.GLuint(texture), C.GLint(level), C.GLint(zoffset))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glFramebufferTexture2D.xml
func (gl *GL) FramebufferTexture2D(target, attachment, textarget glbase.Enum, texture glbase.Texture, level int) {
	C.gl3_0_glFramebufferTexture2D(gl.funcs, C.GLenum(target), C.GLenum(attachment), C.GLenum(textarget), C.GLuint(texture), C.GLint(level))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glFramebufferTexture1D.xml
func (gl *GL) FramebufferTexture1D(target, attachment, textarget glbase.Enum, texture glbase.Texture, level int) {
	C.gl3_0_glFramebufferTexture1D(gl.funcs, C.GLenum(target), C.GLenum(attachment), C.GLenum(textarget), C.GLuint(texture), C.GLint(level))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glCheckFramebufferStatus.xml
func (gl *GL) CheckFramebufferStatus(target glbase.Enum) glbase.Enum {
	glresult := C.gl3_0_glCheckFramebufferStatus(gl.funcs, C.GLenum(target))
	return glbase.Enum(glresult)
}

// GenFramebuffers returns n framebuffer object names in ids. There is no
// guarantee that the names form a contiguous set of integers; however, it is
// guaranteed that none of the returned names was in use immediately before
// the call to GenFramebuffers.
//
// Framebuffer object names returned by a call to GenFramebuffers are not
// returned by subsequent calls, unless they are first deleted with
// DeleteFramebuffers.
//
// The names returned in ids are marked as used, for the purposes of
// GenFramebuffers only, but they acquire state and type only when they are
// first bound.
//
// Error GL.INVALID_VALUE is generated if n is negative.
func (gl *GL) GenFramebuffers(n int) []glbase.Framebuffer {
	if n == 0 {
		return nil
	}
	framebuffers := make([]glbase.Framebuffer, n)
	C.gl3_0_glGenFramebuffers(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&framebuffers[0])))
	return framebuffers
}

// DeleteFramebuffers deletes the framebuffer objects whose names are
// stored in the framebuffers slice. The name zero is reserved by the GL and
// is silently ignored, should it occur in framebuffers, as are other unused
// names. Once a framebuffer object is deleted, its name is again unused and
// it has no attachments. If a framebuffer that is currently bound to one or
// more of the targets GL.DRAW_FRAMEBUFFER or GL.READ_FRAMEBUFFER is deleted,
// it is as though BindFramebuffer had been executed with the corresponding
// target and framebuffer zero.
//
// Error GL.INVALID_VALUE is generated if n is negative.
//
// DeleteFramebuffers is available in GL version 3.0 or greater.
func (gl *GL) DeleteFramebuffers(framebuffers []glbase.Framebuffer) {
	n := len(framebuffers)
	if n == 0 {
		return
	}
	C.gl3_0_glDeleteFramebuffers(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&framebuffers[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glBindFramebuffer.xml
func (gl *GL) BindFramebuffer(target glbase.Enum, framebuffer glbase.Framebuffer) {
	C.gl3_0_glBindFramebuffer(gl.funcs, C.GLenum(target), C.GLuint(framebuffer))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glIsFramebuffer.xml
func (gl *GL) IsFramebuffer(framebuffer glbase.Framebuffer) bool {
	glresult := C.gl3_0_glIsFramebuffer(gl.funcs, C.GLuint(framebuffer))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetRenderbufferParameteriv.xml
func (gl *GL) GetRenderbufferParameteriv(target, pname glbase.Enum, params []int32) {
	C.gl3_0_glGetRenderbufferParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRenderbufferStorage.xml
func (gl *GL) RenderbufferStorage(target, internalFormat glbase.Enum, width, height int) {
	C.gl3_0_glRenderbufferStorage(gl.funcs, C.GLenum(target), C.GLenum(internalFormat), C.GLsizei(width), C.GLsizei(height))
}

// GenRenderbuffers returns n renderbuffer object names in renderbuffers.
// There is no guarantee that the names form a contiguous set of integers;
// however, it is guaranteed that none of the returned names was in use
// immediately before the call to GenRenderbuffers.
//
// Renderbuffer object names returned by a call to GenRenderbuffers are not
// returned by subsequent calls, unless they are first deleted with
// DeleteRenderbuffers.
//
// The names returned in renderbuffers are marked as used, for the purposes
// of GenRenderbuffers only, but they acquire state and type only when they
// are first bound.
//
// Error GL.INVALID_VALUE is generated if n is negative.
//
// GenRenderbuffers is available in GL version 3.0 or greater.
func (gl *GL) GenRenderbuffers(n int) []glbase.Renderbuffer {
	if n == 0 {
		return nil
	}
	renderbuffers := make([]glbase.Renderbuffer, n)
	C.gl3_0_glGenRenderbuffers(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&renderbuffers[0])))
	return renderbuffers
}

// DeleteRenderbuffers deletes the renderbuffer objects whose names are stored
// in the renderbuffers slice. The name zero is reserved by the GL and
// is silently ignored, should it occur in renderbuffers, as are other unused
// names. Once a renderbuffer object is deleted, its name is again unused and
// it has no contents. If a renderbuffer that is currently bound to the
// target GL.RENDERBUFFER is deleted, it is as though BindRenderbuffer had
// been executed with a target of GL.RENDERBUFFER and a name of zero.
//
// If a renderbuffer object is attached to one or more attachment points in
// the currently bound framebuffer, then it as if FramebufferRenderbuffer
// had been called, with a renderbuffer of zero for each attachment point to
// which this image was attached in the currently bound framebuffer. In other
// words, this renderbuffer object is first detached from all attachment
// ponits in the currently bound framebuffer. Note that the renderbuffer
// image is specifically not detached from any non-bound framebuffers.
//
// Error GL.INVALID_VALUE is generated if n is negative.
//
// DeleteRenderbuffers is available in GL version 3.0 or greater.
func (gl *GL) DeleteRenderbuffers(renderbuffers []glbase.Renderbuffer) {
	n := len(renderbuffers)
	if n == 0 {
		return
	}
	C.gl3_0_glDeleteRenderbuffers(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&renderbuffers[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glBindRenderbuffer.xml
func (gl *GL) BindRenderbuffer(target glbase.Enum, renderbuffer glbase.Renderbuffer) {
	C.gl3_0_glBindRenderbuffer(gl.funcs, C.GLenum(target), C.GLuint(renderbuffer))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glIsRenderbuffer.xml
func (gl *GL) IsRenderbuffer(renderbuffer glbase.Renderbuffer) bool {
	glresult := C.gl3_0_glIsRenderbuffer(gl.funcs, C.GLuint(renderbuffer))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glClearBufferfi.xml
func (gl *GL) ClearBufferfi(buffer glbase.Enum, drawbuffer int32, depth float32, stencil int32) {
	C.gl3_0_glClearBufferfi(gl.funcs, C.GLenum(buffer), C.GLint(drawbuffer), C.GLfloat(depth), C.GLint(stencil))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glClearBufferfv.xml
func (gl *GL) ClearBufferfv(buffer glbase.Enum, drawbuffer int32, value []float32) {
	C.gl3_0_glClearBufferfv(gl.funcs, C.GLenum(buffer), C.GLint(drawbuffer), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glClearBufferuiv.xml
func (gl *GL) ClearBufferuiv(buffer glbase.Enum, drawbuffer int32, value []uint32) {
	C.gl3_0_glClearBufferuiv(gl.funcs, C.GLenum(buffer), C.GLint(drawbuffer), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glClearBufferiv.xml
func (gl *GL) ClearBufferiv(buffer glbase.Enum, drawbuffer int32, value []int32) {
	C.gl3_0_glClearBufferiv(gl.funcs, C.GLenum(buffer), C.GLint(drawbuffer), (*C.GLint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetTexParameterIuiv.xml
func (gl *GL) GetTexParameterIuiv(target, pname glbase.Enum, params []uint32) {
	C.gl3_0_glGetTexParameterIuiv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLuint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetTexParameterIiv.xml
func (gl *GL) GetTexParameterIiv(target, pname glbase.Enum, params []int32) {
	C.gl3_0_glGetTexParameterIiv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexParameterIuiv.xml
func (gl *GL) TexParameterIuiv(target, pname glbase.Enum, params []uint32) {
	C.gl3_0_glTexParameterIuiv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLuint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexParameterIiv.xml
func (gl *GL) TexParameterIiv(target, pname glbase.Enum, params []int32) {
	C.gl3_0_glTexParameterIiv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// Uniform4uiv modifies the value of a uniform variable or a uniform
// variable array. The location of the uniform variable to be modified is
// specified by location, which should be a value returned by GetUniformLocation.
// Uniform4uiv operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions Uniform{1|2|3|4}{f|i|ui}v can be used to modify a single
// uniform variable or a uniform variable array. These functions receive a
// slice with the values to be loaded into a uniform variable or a uniform
// variable array. A slice with length 1 should be used if modifying the value
// of a single uniform variable, and a length of 1 or greater can be used to
// modify an entire array or part of an array. When loading n elements
// starting at an arbitrary position m in a uniform variable array, elements
// m + n - 1 in the array will be replaced with the new values. If m + n - 1
// is larger than the size of the uniform variable array, values for all
// array elements beyond the end of the array will be ignored. The number
// specified in the name of the command indicates the number of components
// for each element in value, and it should match the number of components in
// the data type of the specified uniform variable (1 for float, int, bool;
// 2 for vec2, ivec2, bvec2, etc.). The data type specified in the name
// of the command must match the data type for the specified uniform variable
// as described for Uniform{1|2|3|4}{f|i|ui}.
//
// Uniform1i and Uniform1iv are the only two functions that may be used to
// load uniform variables defined as sampler types. Loading samplers with any
// other function will result in a GL.INVALID_OPERATION error.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) Uniform4uiv(location glbase.Uniform, value []uint32) {
	if len(value) == 0 {
		return
	}
	if len(value)%4 != 0 {
		panic("invalid value length for Uniform4uiv")
	}
	count := len(value) / 4
	C.gl3_0_glUniform4uiv(gl.funcs, C.GLint(location), C.GLsizei(count), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// Uniform3uiv modifies the value of a uniform variable or a uniform
// variable array. The location of the uniform variable to be modified is
// specified by location, which should be a value returned by GetUniformLocation.
// Uniform3uiv operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions Uniform{1|2|3|4}{f|i|ui}v can be used to modify a single
// uniform variable or a uniform variable array. These functions receive a
// slice with the values to be loaded into a uniform variable or a uniform
// variable array. A slice with length 1 should be used if modifying the value
// of a single uniform variable, and a length of 1 or greater can be used to
// modify an entire array or part of an array. When loading n elements
// starting at an arbitrary position m in a uniform variable array, elements
// m + n - 1 in the array will be replaced with the new values. If m + n - 1
// is larger than the size of the uniform variable array, values for all
// array elements beyond the end of the array will be ignored. The number
// specified in the name of the command indicates the number of components
// for each element in value, and it should match the number of components in
// the data type of the specified uniform variable (1 for float, int, bool;
// 2 for vec2, ivec2, bvec2, etc.). The data type specified in the name
// of the command must match the data type for the specified uniform variable
// as described for Uniform{1|2|3|4}{f|i|ui}.
//
// Uniform1i and Uniform1iv are the only two functions that may be used to
// load uniform variables defined as sampler types. Loading samplers with any
// other function will result in a GL.INVALID_OPERATION error.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) Uniform3uiv(location glbase.Uniform, value []uint32) {
	if len(value) == 0 {
		return
	}
	if len(value)%3 != 0 {
		panic("invalid value length for Uniform3uiv")
	}
	count := len(value) / 3
	C.gl3_0_glUniform3uiv(gl.funcs, C.GLint(location), C.GLsizei(count), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// Uniform2uiv modifies the value of a uniform variable or a uniform
// variable array. The location of the uniform variable to be modified is
// specified by location, which should be a value returned by GetUniformLocation.
// Uniform2uiv operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions Uniform{1|2|3|4}{f|i|ui}v can be used to modify a single
// uniform variable or a uniform variable array. These functions receive a
// slice with the values to be loaded into a uniform variable or a uniform
// variable array. A slice with length 1 should be used if modifying the value
// of a single uniform variable, and a length of 1 or greater can be used to
// modify an entire array or part of an array. When loading n elements
// starting at an arbitrary position m in a uniform variable array, elements
// m + n - 1 in the array will be replaced with the new values. If m + n - 1
// is larger than the size of the uniform variable array, values for all
// array elements beyond the end of the array will be ignored. The number
// specified in the name of the command indicates the number of components
// for each element in value, and it should match the number of components in
// the data type of the specified uniform variable (1 for float, int, bool;
// 2 for vec2, ivec2, bvec2, etc.). The data type specified in the name
// of the command must match the data type for the specified uniform variable
// as described for Uniform{1|2|3|4}{f|i|ui}.
//
// Uniform1i and Uniform1iv are the only two functions that may be used to
// load uniform variables defined as sampler types. Loading samplers with any
// other function will result in a GL.INVALID_OPERATION error.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) Uniform2uiv(location glbase.Uniform, value []uint32) {
	if len(value) == 0 {
		return
	}
	if len(value)%2 != 0 {
		panic("invalid value length for Uniform2uiv")
	}
	count := len(value) / 2
	C.gl3_0_glUniform2uiv(gl.funcs, C.GLint(location), C.GLsizei(count), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// Uniform1uiv modifies the value of a uniform variable or a uniform
// variable array. The location of the uniform variable to be modified is
// specified by location, which should be a value returned by GetUniformLocation.
// Uniform1uiv operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions Uniform{1|2|3|4}{f|i|ui}v can be used to modify a single
// uniform variable or a uniform variable array. These functions receive a
// slice with the values to be loaded into a uniform variable or a uniform
// variable array. A slice with length 1 should be used if modifying the value
// of a single uniform variable, and a length of 1 or greater can be used to
// modify an entire array or part of an array. When loading n elements
// starting at an arbitrary position m in a uniform variable array, elements
// m + n - 1 in the array will be replaced with the new values. If m + n - 1
// is larger than the size of the uniform variable array, values for all
// array elements beyond the end of the array will be ignored. The number
// specified in the name of the command indicates the number of components
// for each element in value, and it should match the number of components in
// the data type of the specified uniform variable (1 for float, int, bool;
// 2 for vec2, ivec2, bvec2, etc.). The data type specified in the name
// of the command must match the data type for the specified uniform variable
// as described for Uniform{1|2|3|4}{f|i|ui}.
//
// Uniform1i and Uniform1iv are the only two functions that may be used to
// load uniform variables defined as sampler types. Loading samplers with any
// other function will result in a GL.INVALID_OPERATION error.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) Uniform1uiv(location glbase.Uniform, value []uint32) {
	if len(value) == 0 {
		return
	}
	count := len(value)
	C.gl3_0_glUniform1uiv(gl.funcs, C.GLint(location), C.GLsizei(count), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// Uniform4ui modifies the value of a single uniform variable.
// The location of the uniform variable to be modified is specified by
// location, which should be a value returned by GetUniformLocation.
// Uniform4ui operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions Uniform{1|2|3|4}{f|i|ui} are used to change the value of the
// uniform variable specified by location using the values passed as
// arguments. The number specified in the function should match the number of
// components in the data type of the specified uniform variable (1 for
// float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
// The suffix f indicates that floating-point values are being passed; the
// suffix i indicates that integer values are being passed; the suffix ui
// indicates that unsigned integer values are being passed, and this type
// should also match the data type of the specified uniform variable. The i
// variants of this function should be used to provide values for uniform
// variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui
// variants of this function should be used to provide values for uniform
// variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of
// these. The f variants should be used to provide values for uniform
// variables of type float, vec2, vec3, vec4, or arrays of these. Either the
// i, ui or f variants may be used to provide values for uniform variables of
// type bool, bvec2, bvec3, bvec4, or arrays of these. The uniform variable
// will be set to false if the input value is 0 or 0.0f, and it will be set
// to true otherwise.
//
// Uniform1i and Uniform1iv are the only two functions that may be used to
// load uniform variables defined as sampler types. Loading samplers with any
// other function will result in a GL.INVALID_OPERATION error.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) Uniform4ui(location glbase.Uniform, v0, v1, v2, v3 uint32) {
	C.gl3_0_glUniform4ui(gl.funcs, C.GLint(location), C.GLuint(v0), C.GLuint(v1), C.GLuint(v2), C.GLuint(v3))
}

// Uniform3ui modifies the value of a single uniform variable.
// The location of the uniform variable to be modified is specified by
// location, which should be a value returned by GetUniformLocation.
// Uniform3ui operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions Uniform{1|2|3|4}{f|i|ui} are used to change the value of the
// uniform variable specified by location using the values passed as
// arguments. The number specified in the function should match the number of
// components in the data type of the specified uniform variable (1 for
// float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
// The suffix f indicates that floating-point values are being passed; the
// suffix i indicates that integer values are being passed; the suffix ui
// indicates that unsigned integer values are being passed, and this type
// should also match the data type of the specified uniform variable. The i
// variants of this function should be used to provide values for uniform
// variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui
// variants of this function should be used to provide values for uniform
// variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of
// these. The f variants should be used to provide values for uniform
// variables of type float, vec2, vec3, vec4, or arrays of these. Either the
// i, ui or f variants may be used to provide values for uniform variables of
// type bool, bvec2, bvec3, bvec4, or arrays of these. The uniform variable
// will be set to false if the input value is 0 or 0.0f, and it will be set
// to true otherwise.
//
// Uniform1i and Uniform1iv are the only two functions that may be used to
// load uniform variables defined as sampler types. Loading samplers with any
// other function will result in a GL.INVALID_OPERATION error.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) Uniform3ui(location glbase.Uniform, v0, v1, v2 uint32) {
	C.gl3_0_glUniform3ui(gl.funcs, C.GLint(location), C.GLuint(v0), C.GLuint(v1), C.GLuint(v2))
}

// Uniform2ui modifies the value of a single uniform variable.
// The location of the uniform variable to be modified is specified by
// location, which should be a value returned by GetUniformLocation.
// Uniform2ui operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions Uniform{1|2|3|4}{f|i|ui} are used to change the value of the
// uniform variable specified by location using the values passed as
// arguments. The number specified in the function should match the number of
// components in the data type of the specified uniform variable (1 for
// float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
// The suffix f indicates that floating-point values are being passed; the
// suffix i indicates that integer values are being passed; the suffix ui
// indicates that unsigned integer values are being passed, and this type
// should also match the data type of the specified uniform variable. The i
// variants of this function should be used to provide values for uniform
// variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui
// variants of this function should be used to provide values for uniform
// variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of
// these. The f variants should be used to provide values for uniform
// variables of type float, vec2, vec3, vec4, or arrays of these. Either the
// i, ui or f variants may be used to provide values for uniform variables of
// type bool, bvec2, bvec3, bvec4, or arrays of these. The uniform variable
// will be set to false if the input value is 0 or 0.0f, and it will be set
// to true otherwise.
//
// Uniform1i and Uniform1iv are the only two functions that may be used to
// load uniform variables defined as sampler types. Loading samplers with any
// other function will result in a GL.INVALID_OPERATION error.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) Uniform2ui(location glbase.Uniform, v0, v1 uint32) {
	C.gl3_0_glUniform2ui(gl.funcs, C.GLint(location), C.GLuint(v0), C.GLuint(v1))
}

// Uniform1ui modifies the value of a single uniform variable.
// The location of the uniform variable to be modified is specified by
// location, which should be a value returned by GetUniformLocation.
// Uniform1ui operates on the program object that was made part of
// current state by calling UseProgram.
//
// The functions Uniform{1|2|3|4}{f|i|ui} are used to change the value of the
// uniform variable specified by location using the values passed as
// arguments. The number specified in the function should match the number of
// components in the data type of the specified uniform variable (1 for
// float, int, unsigned int, bool; 2 for vec2, ivec2, uvec2, bvec2, etc.).
// The suffix f indicates that floating-point values are being passed; the
// suffix i indicates that integer values are being passed; the suffix ui
// indicates that unsigned integer values are being passed, and this type
// should also match the data type of the specified uniform variable. The i
// variants of this function should be used to provide values for uniform
// variables defined as int, ivec2, ivec3, ivec4, or arrays of these. The ui
// variants of this function should be used to provide values for uniform
// variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays of
// these. The f variants should be used to provide values for uniform
// variables of type float, vec2, vec3, vec4, or arrays of these. Either the
// i, ui or f variants may be used to provide values for uniform variables of
// type bool, bvec2, bvec3, bvec4, or arrays of these. The uniform variable
// will be set to false if the input value is 0 or 0.0f, and it will be set
// to true otherwise.
//
// Uniform1i and Uniform1iv are the only two functions that may be used to
// load uniform variables defined as sampler types. Loading samplers with any
// other function will result in a GL.INVALID_OPERATION error.
//
// All active uniform variables defined in a program object are initialized
// to 0 when the program object is linked successfully. They retain the
// values assigned to them by a call to Uniform* until the next successful
// link operation occurs on the program object, when they are once again
// initialized to 0.
func (gl *GL) Uniform1ui(location glbase.Uniform, v0 uint32) {
	C.gl3_0_glUniform1ui(gl.funcs, C.GLint(location), C.GLuint(v0))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetFragDataLocation.xml
func (gl *GL) GetFragDataLocation(program glbase.Program, name []byte) int32 {
	glresult := C.gl3_0_glGetFragDataLocation(gl.funcs, C.GLuint(program), (*C.GLchar)(unsafe.Pointer(&name[0])))
	return int32(glresult)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glBindFragDataLocation.xml
func (gl *GL) BindFragDataLocation(program glbase.Program, color uint32, name []byte) {
	C.gl3_0_glBindFragDataLocation(gl.funcs, C.GLuint(program), C.GLuint(color), (*C.GLchar)(unsafe.Pointer(&name[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetUniformuiv.xml
func (gl *GL) GetUniformuiv(program glbase.Program, location glbase.Uniform, params []uint32) {
	C.gl3_0_glGetUniformuiv(gl.funcs, C.GLuint(program), C.GLint(location), (*C.GLuint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetVertexAttribIuiv.xml
func (gl *GL) GetVertexAttribIuiv(index glbase.Attrib, pname glbase.Enum, params []uint32) {
	C.gl3_0_glGetVertexAttribIuiv(gl.funcs, C.GLuint(index), C.GLenum(pname), (*C.GLuint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetVertexAttribIiv.xml
func (gl *GL) GetVertexAttribIiv(index glbase.Attrib, pname glbase.Enum, params []int32) {
	C.gl3_0_glGetVertexAttribIiv(gl.funcs, C.GLuint(index), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttribIPointer.xml
func (gl *GL) VertexAttribIPointer(index glbase.Attrib, size int, gltype glbase.Enum, stride int, pointer interface{}) {
	var pointer_ptr unsafe.Pointer
	var pointer_v = reflect.ValueOf(pointer)
	if pointer != nil && pointer_v.Kind() != reflect.Slice {
		panic("parameter pointer must be a slice")
	}
	if pointer != nil {
		pointer_ptr = unsafe.Pointer(pointer_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glVertexAttribIPointer(gl.funcs, C.GLuint(index), C.GLint(size), C.GLenum(gltype), C.GLsizei(stride), pointer_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glEndConditionalRender.xml
func (gl *GL) EndConditionalRender() {
	C.gl3_0_glEndConditionalRender(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glBeginConditionalRender.xml
func (gl *GL) BeginConditionalRender(id uint32, mode glbase.Enum) {
	C.gl3_0_glBeginConditionalRender(gl.funcs, C.GLuint(id), C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glClampColor.xml
func (gl *GL) ClampColor(target, clamp glbase.Enum) {
	C.gl3_0_glClampColor(gl.funcs, C.GLenum(target), C.GLenum(clamp))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetTransformFeedbackVarying.xml
func (gl *GL) GetTransformFeedbackVarying(program glbase.Program, index uint32, bufSize int32, length []int32, size []int, gltype []glbase.Enum, name []byte) {
	C.gl3_0_glGetTransformFeedbackVarying(gl.funcs, C.GLuint(program), C.GLuint(index), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLsizei)(unsafe.Pointer(&size[0])), (*C.GLenum)(unsafe.Pointer(&gltype[0])), (*C.GLchar)(unsafe.Pointer(&name[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glBindBufferBase.xml
func (gl *GL) BindBufferBase(target glbase.Enum, index uint32, buffer glbase.Buffer) {
	C.gl3_0_glBindBufferBase(gl.funcs, C.GLenum(target), C.GLuint(index), C.GLuint(buffer))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glBindBufferRange.xml
func (gl *GL) BindBufferRange(target glbase.Enum, index uint32, buffer glbase.Buffer, offset, size int) {
	C.gl3_0_glBindBufferRange(gl.funcs, C.GLenum(target), C.GLuint(index), C.GLuint(buffer), C.GLintptr(offset), C.GLsizeiptr(size))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glEndTransformFeedback.xml
func (gl *GL) EndTransformFeedback() {
	C.gl3_0_glEndTransformFeedback(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glBeginTransformFeedback.xml
func (gl *GL) BeginTransformFeedback(primitiveMode glbase.Enum) {
	C.gl3_0_glBeginTransformFeedback(gl.funcs, C.GLenum(primitiveMode))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glIsEnabledi.xml
func (gl *GL) IsEnabledi(target glbase.Enum, index uint32) bool {
	glresult := C.gl3_0_glIsEnabledi(gl.funcs, C.GLenum(target), C.GLuint(index))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glDisablei.xml
func (gl *GL) Disablei(target glbase.Enum, index uint32) {
	C.gl3_0_glDisablei(gl.funcs, C.GLenum(target), C.GLuint(index))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glEnablei.xml
func (gl *GL) Enablei(target glbase.Enum, index uint32) {
	C.gl3_0_glEnablei(gl.funcs, C.GLenum(target), C.GLuint(index))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetIntegeri_v.xml
func (gl *GL) GetIntegeri_v(target glbase.Enum, index uint32, data []int32) {
	C.gl3_0_glGetIntegeri_v(gl.funcs, C.GLenum(target), C.GLuint(index), (*C.GLint)(unsafe.Pointer(&data[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetBooleani_v.xml
func (gl *GL) GetBooleani_v(target glbase.Enum, index uint32, data []bool) {
	C.gl3_0_glGetBooleani_v(gl.funcs, C.GLenum(target), C.GLuint(index), (*C.GLboolean)(unsafe.Pointer(&data[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColorMaski.xml
func (gl *GL) ColorMaski(index uint32, r, g, b, a bool) {
	C.gl3_0_glColorMaski(gl.funcs, C.GLuint(index), *(*C.GLboolean)(unsafe.Pointer(&r)), *(*C.GLboolean)(unsafe.Pointer(&g)), *(*C.GLboolean)(unsafe.Pointer(&b)), *(*C.GLboolean)(unsafe.Pointer(&a)))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTranslatef.xml
func (gl *GL) Translatef(x, y, z float32) {
	C.gl3_0_glTranslatef(gl.funcs, C.GLfloat(x), C.GLfloat(y), C.GLfloat(z))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTranslated.xml
func (gl *GL) Translated(x, y, z float64) {
	C.gl3_0_glTranslated(gl.funcs, C.GLdouble(x), C.GLdouble(y), C.GLdouble(z))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glScalef.xml
func (gl *GL) Scalef(x, y, z float32) {
	C.gl3_0_glScalef(gl.funcs, C.GLfloat(x), C.GLfloat(y), C.GLfloat(z))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glScaled.xml
func (gl *GL) Scaled(x, y, z float64) {
	C.gl3_0_glScaled(gl.funcs, C.GLdouble(x), C.GLdouble(y), C.GLdouble(z))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRotatef.xml
func (gl *GL) Rotatef(angle, x, y, z float32) {
	C.gl3_0_glRotatef(gl.funcs, C.GLfloat(angle), C.GLfloat(x), C.GLfloat(y), C.GLfloat(z))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRotated.xml
func (gl *GL) Rotated(angle, x, y, z float64) {
	C.gl3_0_glRotated(gl.funcs, C.GLdouble(angle), C.GLdouble(x), C.GLdouble(y), C.GLdouble(z))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glPushMatrix.xml
func (gl *GL) PushMatrix() {
	C.gl3_0_glPushMatrix(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glPopMatrix.xml
func (gl *GL) PopMatrix() {
	C.gl3_0_glPopMatrix(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glOrtho.xml
func (gl *GL) Ortho(left, right, bottom, top, zNear, zFar float64) {
	C.gl3_0_glOrtho(gl.funcs, C.GLdouble(left), C.GLdouble(right), C.GLdouble(bottom), C.GLdouble(top), C.GLdouble(zNear), C.GLdouble(zFar))
}

// MultMatrixd multiplies the current matrix with the provided matrix.
//
// The m parameter must hold 16 consecutive elements of a 4x4 column-major matrix.
//
// The current matrix is determined by the current matrix mode (see
// MatrixMode). It is either the projection matrix, modelview matrix, or the
// texture matrix.
//
// For example, if the current matrix is C and the coordinates to be transformed
// are v = (v[0], v[1], v[2], v[3]), then the current transformation is C × v, or
//
//     c[0]  c[4]  c[8]  c[12]     v[0]
//     c[1]  c[5]  c[9]  c[13]     v[1]
//     c[2]  c[6]  c[10] c[14]  X  v[2]
//     c[3]  c[7]  c[11] c[15]     v[3]
//
// Calling MultMatrix with an argument of m = m[0], m[1], ..., m[15]
// replaces the current transformation with (C X M) x v, or
//
//     c[0]  c[4]  c[8]  c[12]   m[0]  m[4]  m[8]  m[12]   v[0]
//     c[1]  c[5]  c[9]  c[13]   m[1]  m[5]  m[9]  m[13]   v[1]
//     c[2]  c[6]  c[10] c[14] X m[2]  m[6]  m[10] m[14] X v[2]
//     c[3]  c[7]  c[11] c[15]   m[3]  m[7]  m[11] m[15]   v[3]
//
// Where 'X' denotes matrix multiplication, and v is represented as a 4x1 matrix.
//
// While the elements of the matrix may be specified with single or double
// precision, the GL may store or operate on these values in less-than-single
// precision.
//
// In many computer languages, 4×4 arrays are represented in row-major
// order. The transformations just described represent these matrices in
// column-major order. The order of the multiplication is important. For
// example, if the current transformation is a rotation, and MultMatrix is
// called with a translation matrix, the translation is done directly on the
// coordinates to be transformed, while the rotation is done on the results
// of that translation.
//
// GL.INVALID_OPERATION is generated if MultMatrix is executed between the
// execution of Begin and the corresponding execution of End.
func (gl *GL) MultMatrixd(m []float64) {
	if len(m) != 16 {
		panic("parameter m must have length 16 for the 4x4 matrix")
	}
	C.gl3_0_glMultMatrixd(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&m[0])))
}

// MultMatrixf multiplies the current matrix with the provided matrix.
//
// The m parameter must hold 16 consecutive elements of a 4x4 column-major matrix.
//
// The current matrix is determined by the current matrix mode (see
// MatrixMode). It is either the projection matrix, modelview matrix, or the
// texture matrix.
//
// For example, if the current matrix is C and the coordinates to be transformed
// are v = (v[0], v[1], v[2], v[3]), then the current transformation is C × v, or
//
//     c[0]  c[4]  c[8]  c[12]     v[0]
//     c[1]  c[5]  c[9]  c[13]     v[1]
//     c[2]  c[6]  c[10] c[14]  X  v[2]
//     c[3]  c[7]  c[11] c[15]     v[3]
//
// Calling MultMatrix with an argument of m = m[0], m[1], ..., m[15]
// replaces the current transformation with (C X M) x v, or
//
//     c[0]  c[4]  c[8]  c[12]   m[0]  m[4]  m[8]  m[12]   v[0]
//     c[1]  c[5]  c[9]  c[13]   m[1]  m[5]  m[9]  m[13]   v[1]
//     c[2]  c[6]  c[10] c[14] X m[2]  m[6]  m[10] m[14] X v[2]
//     c[3]  c[7]  c[11] c[15]   m[3]  m[7]  m[11] m[15]   v[3]
//
// Where 'X' denotes matrix multiplication, and v is represented as a 4x1 matrix.
//
// While the elements of the matrix may be specified with single or double
// precision, the GL may store or operate on these values in less-than-single
// precision.
//
// In many computer languages, 4×4 arrays are represented in row-major
// order. The transformations just described represent these matrices in
// column-major order. The order of the multiplication is important. For
// example, if the current transformation is a rotation, and MultMatrix is
// called with a translation matrix, the translation is done directly on the
// coordinates to be transformed, while the rotation is done on the results
// of that translation.
//
// GL.INVALID_OPERATION is generated if MultMatrix is executed between the
// execution of Begin and the corresponding execution of End.
func (gl *GL) MultMatrixf(m []float32) {
	if len(m) != 16 {
		panic("parameter m must have length 16 for the 4x4 matrix")
	}
	C.gl3_0_glMultMatrixf(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&m[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMatrixMode.xml
func (gl *GL) MatrixMode(mode glbase.Enum) {
	C.gl3_0_glMatrixMode(gl.funcs, C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glLoadMatrixd.xml
func (gl *GL) LoadMatrixd(m []float64) {
	C.gl3_0_glLoadMatrixd(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&m[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glLoadMatrixf.xml
func (gl *GL) LoadMatrixf(m []float32) {
	C.gl3_0_glLoadMatrixf(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&m[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glLoadIdentity.xml
func (gl *GL) LoadIdentity() {
	C.gl3_0_glLoadIdentity(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glFrustum.xml
func (gl *GL) Frustum(left, right, bottom, top, zNear, zFar float64) {
	C.gl3_0_glFrustum(gl.funcs, C.GLdouble(left), C.GLdouble(right), C.GLdouble(bottom), C.GLdouble(top), C.GLdouble(zNear), C.GLdouble(zFar))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glIsList.xml
func (gl *GL) IsList(list uint32) bool {
	glresult := C.gl3_0_glIsList(gl.funcs, C.GLuint(list))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetTexGeniv.xml
func (gl *GL) GetTexGeniv(coord, pname glbase.Enum, params []int32) {
	C.gl3_0_glGetTexGeniv(gl.funcs, C.GLenum(coord), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetTexGenfv.xml
func (gl *GL) GetTexGenfv(coord, pname glbase.Enum, params []float32) {
	C.gl3_0_glGetTexGenfv(gl.funcs, C.GLenum(coord), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetTexGendv.xml
func (gl *GL) GetTexGendv(coord, pname glbase.Enum, params []float64) {
	C.gl3_0_glGetTexGendv(gl.funcs, C.GLenum(coord), C.GLenum(pname), (*C.GLdouble)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetTexEnviv.xml
func (gl *GL) GetTexEnviv(target, pname glbase.Enum, params []int32) {
	C.gl3_0_glGetTexEnviv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetTexEnvfv.xml
func (gl *GL) GetTexEnvfv(target, pname glbase.Enum, params []float32) {
	C.gl3_0_glGetTexEnvfv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetPolygonStipple.xml
func (gl *GL) GetPolygonStipple(mask []uint8) {
	C.gl3_0_glGetPolygonStipple(gl.funcs, (*C.GLubyte)(unsafe.Pointer(&mask[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetPixelMapusv.xml
func (gl *GL) GetPixelMapusv(glmap glbase.Enum, values []uint16) {
	C.gl3_0_glGetPixelMapusv(gl.funcs, C.GLenum(glmap), (*C.GLushort)(unsafe.Pointer(&values[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetPixelMapuiv.xml
func (gl *GL) GetPixelMapuiv(glmap glbase.Enum, values []uint32) {
	C.gl3_0_glGetPixelMapuiv(gl.funcs, C.GLenum(glmap), (*C.GLuint)(unsafe.Pointer(&values[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetPixelMapfv.xml
func (gl *GL) GetPixelMapfv(glmap glbase.Enum, values []float32) {
	C.gl3_0_glGetPixelMapfv(gl.funcs, C.GLenum(glmap), (*C.GLfloat)(unsafe.Pointer(&values[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetMaterialiv.xml
func (gl *GL) GetMaterialiv(face, pname glbase.Enum, params []int32) {
	C.gl3_0_glGetMaterialiv(gl.funcs, C.GLenum(face), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetMaterialfv.xml
func (gl *GL) GetMaterialfv(face, pname glbase.Enum, params []float32) {
	C.gl3_0_glGetMaterialfv(gl.funcs, C.GLenum(face), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetMapiv.xml
func (gl *GL) GetMapiv(target, query glbase.Enum, v []int32) {
	C.gl3_0_glGetMapiv(gl.funcs, C.GLenum(target), C.GLenum(query), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetMapfv.xml
func (gl *GL) GetMapfv(target, query glbase.Enum, v []float32) {
	C.gl3_0_glGetMapfv(gl.funcs, C.GLenum(target), C.GLenum(query), (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetMapdv.xml
func (gl *GL) GetMapdv(target, query glbase.Enum, v []float64) {
	C.gl3_0_glGetMapdv(gl.funcs, C.GLenum(target), C.GLenum(query), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetLightiv.xml
func (gl *GL) GetLightiv(light, pname glbase.Enum, params []int32) {
	C.gl3_0_glGetLightiv(gl.funcs, C.GLenum(light), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetLightfv.xml
func (gl *GL) GetLightfv(light, pname glbase.Enum, params []float32) {
	C.gl3_0_glGetLightfv(gl.funcs, C.GLenum(light), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetClipPlane.xml
func (gl *GL) GetClipPlane(plane glbase.Enum, equation []float64) {
	C.gl3_0_glGetClipPlane(gl.funcs, C.GLenum(plane), (*C.GLdouble)(unsafe.Pointer(&equation[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glDrawPixels.xml
func (gl *GL) DrawPixels(width, height int, format, gltype glbase.Enum, pixels interface{}) {
	var pixels_ptr unsafe.Pointer
	var pixels_v = reflect.ValueOf(pixels)
	if pixels != nil && pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	if pixels != nil {
		pixels_ptr = unsafe.Pointer(pixels_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glDrawPixels(gl.funcs, C.GLsizei(width), C.GLsizei(height), C.GLenum(format), C.GLenum(gltype), pixels_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glCopyPixels.xml
func (gl *GL) CopyPixels(x, y, width, height int, gltype glbase.Enum) {
	C.gl3_0_glCopyPixels(gl.funcs, C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height), C.GLenum(gltype))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glPixelMapusv.xml
func (gl *GL) PixelMapusv(glmap glbase.Enum, mapsize int32, values []uint16) {
	C.gl3_0_glPixelMapusv(gl.funcs, C.GLenum(glmap), C.GLint(mapsize), (*C.GLushort)(unsafe.Pointer(&values[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glPixelMapuiv.xml
func (gl *GL) PixelMapuiv(glmap glbase.Enum, mapsize int32, values []uint32) {
	C.gl3_0_glPixelMapuiv(gl.funcs, C.GLenum(glmap), C.GLint(mapsize), (*C.GLuint)(unsafe.Pointer(&values[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glPixelMapfv.xml
func (gl *GL) PixelMapfv(glmap glbase.Enum, mapsize int32, values []float32) {
	C.gl3_0_glPixelMapfv(gl.funcs, C.GLenum(glmap), C.GLint(mapsize), (*C.GLfloat)(unsafe.Pointer(&values[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glPixelTransferi.xml
func (gl *GL) PixelTransferi(pname glbase.Enum, param int32) {
	C.gl3_0_glPixelTransferi(gl.funcs, C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glPixelTransferf.xml
func (gl *GL) PixelTransferf(pname glbase.Enum, param float32) {
	C.gl3_0_glPixelTransferf(gl.funcs, C.GLenum(pname), C.GLfloat(param))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glPixelZoom.xml
func (gl *GL) PixelZoom(xfactor, yfactor float32) {
	C.gl3_0_glPixelZoom(gl.funcs, C.GLfloat(xfactor), C.GLfloat(yfactor))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glAlphaFunc.xml
func (gl *GL) AlphaFunc(glfunc glbase.Enum, ref float32) {
	C.gl3_0_glAlphaFunc(gl.funcs, C.GLenum(glfunc), C.GLfloat(ref))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glEvalPoint2.xml
func (gl *GL) EvalPoint2(i, j int32) {
	C.gl3_0_glEvalPoint2(gl.funcs, C.GLint(i), C.GLint(j))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glEvalMesh2.xml
func (gl *GL) EvalMesh2(mode glbase.Enum, i1, i2, j1, j2 int32) {
	C.gl3_0_glEvalMesh2(gl.funcs, C.GLenum(mode), C.GLint(i1), C.GLint(i2), C.GLint(j1), C.GLint(j2))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glEvalPoint1.xml
func (gl *GL) EvalPoint1(i int32) {
	C.gl3_0_glEvalPoint1(gl.funcs, C.GLint(i))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glEvalMesh1.xml
func (gl *GL) EvalMesh1(mode glbase.Enum, i1, i2 int32) {
	C.gl3_0_glEvalMesh1(gl.funcs, C.GLenum(mode), C.GLint(i1), C.GLint(i2))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glEvalCoord2fv.xml
func (gl *GL) EvalCoord2fv(u []float32) {
	if len(u) != 2 {
		panic("parameter u has incorrect length")
	}
	C.gl3_0_glEvalCoord2fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&u[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glEvalCoord2f.xml
func (gl *GL) EvalCoord2f(u, v float32) {
	C.gl3_0_glEvalCoord2f(gl.funcs, C.GLfloat(u), C.GLfloat(v))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glEvalCoord2dv.xml
func (gl *GL) EvalCoord2dv(u []float64) {
	if len(u) != 2 {
		panic("parameter u has incorrect length")
	}
	C.gl3_0_glEvalCoord2dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&u[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glEvalCoord2d.xml
func (gl *GL) EvalCoord2d(u, v float64) {
	C.gl3_0_glEvalCoord2d(gl.funcs, C.GLdouble(u), C.GLdouble(v))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glEvalCoord1fv.xml
func (gl *GL) EvalCoord1fv(u []float32) {
	C.gl3_0_glEvalCoord1fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&u[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glEvalCoord1f.xml
func (gl *GL) EvalCoord1f(u float32) {
	C.gl3_0_glEvalCoord1f(gl.funcs, C.GLfloat(u))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glEvalCoord1dv.xml
func (gl *GL) EvalCoord1dv(u []float64) {
	C.gl3_0_glEvalCoord1dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&u[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glEvalCoord1d.xml
func (gl *GL) EvalCoord1d(u float64) {
	C.gl3_0_glEvalCoord1d(gl.funcs, C.GLdouble(u))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMapGrid2f.xml
func (gl *GL) MapGrid2f(un int32, u1, u2 float32, vn int32, v1, v2 float32) {
	C.gl3_0_glMapGrid2f(gl.funcs, C.GLint(un), C.GLfloat(u1), C.GLfloat(u2), C.GLint(vn), C.GLfloat(v1), C.GLfloat(v2))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMapGrid2d.xml
func (gl *GL) MapGrid2d(un int32, u1, u2 float64, vn int32, v1, v2 float64) {
	C.gl3_0_glMapGrid2d(gl.funcs, C.GLint(un), C.GLdouble(u1), C.GLdouble(u2), C.GLint(vn), C.GLdouble(v1), C.GLdouble(v2))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMapGrid1f.xml
func (gl *GL) MapGrid1f(un int32, u1, u2 float32) {
	C.gl3_0_glMapGrid1f(gl.funcs, C.GLint(un), C.GLfloat(u1), C.GLfloat(u2))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMapGrid1d.xml
func (gl *GL) MapGrid1d(un int32, u1, u2 float64) {
	C.gl3_0_glMapGrid1d(gl.funcs, C.GLint(un), C.GLdouble(u1), C.GLdouble(u2))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMap2f.xml
func (gl *GL) Map2f(target glbase.Enum, u1, u2 float32, ustride, uorder int32, v1, v2 float32, vstride, vorder int32, points []float32) {
	C.gl3_0_glMap2f(gl.funcs, C.GLenum(target), C.GLfloat(u1), C.GLfloat(u2), C.GLint(ustride), C.GLint(uorder), C.GLfloat(v1), C.GLfloat(v2), C.GLint(vstride), C.GLint(vorder), (*C.GLfloat)(unsafe.Pointer(&points[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMap2d.xml
func (gl *GL) Map2d(target glbase.Enum, u1, u2 float64, ustride, uorder int32, v1, v2 float64, vstride, vorder int32, points []float64) {
	C.gl3_0_glMap2d(gl.funcs, C.GLenum(target), C.GLdouble(u1), C.GLdouble(u2), C.GLint(ustride), C.GLint(uorder), C.GLdouble(v1), C.GLdouble(v2), C.GLint(vstride), C.GLint(vorder), (*C.GLdouble)(unsafe.Pointer(&points[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMap1f.xml
func (gl *GL) Map1f(target glbase.Enum, u1, u2 float32, stride, order int, points []float32) {
	C.gl3_0_glMap1f(gl.funcs, C.GLenum(target), C.GLfloat(u1), C.GLfloat(u2), C.GLint(stride), C.GLint(order), (*C.GLfloat)(unsafe.Pointer(&points[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMap1d.xml
func (gl *GL) Map1d(target glbase.Enum, u1, u2 float64, stride, order int, points []float64) {
	C.gl3_0_glMap1d(gl.funcs, C.GLenum(target), C.GLdouble(u1), C.GLdouble(u2), C.GLint(stride), C.GLint(order), (*C.GLdouble)(unsafe.Pointer(&points[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glPushAttrib.xml
func (gl *GL) PushAttrib(mask glbase.Bitfield) {
	C.gl3_0_glPushAttrib(gl.funcs, C.GLbitfield(mask))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glPopAttrib.xml
func (gl *GL) PopAttrib() {
	C.gl3_0_glPopAttrib(gl.funcs)
}

// Accum executes an operation on the accumulation buffer.
//
// Parameter op defines the accumulation buffer operation (GL.ACCUM, GL.LOAD,
// GL.ADD, GL.MULT, or GL.RETURN) and specifies how the value parameter is
// used.
//
// The accumulation buffer is an extended-range color buffer. Images are not
// rendered into it. Rather, images rendered into one of the color buffers
// are added to the contents of the accumulation buffer after rendering.
// Effects such as antialiasing (of points, lines, and polygons), motion
// blur, and depth of field can be created by accumulating images generated
// with different transformation matrices.
//
// Each pixel in the accumulation buffer consists of red, green, blue, and
// alpha values. The number of bits per component in the accumulation buffer
// depends on the implementation. You can examine this number by calling
// GetIntegerv four times, with arguments GL.ACCUM_RED_BITS,
// GL.ACCUM_GREEN_BITS, GL.ACCUM_BLUE_BITS, and GL.ACCUM_ALPHA_BITS.
// Regardless of the number of bits per component, the range of values stored
// by each component is (-1, 1). The accumulation buffer pixels are mapped
// one-to-one with frame buffer pixels.
//
// All accumulation buffer operations are limited to the area of the current
// scissor box and applied identically to the red, green, blue, and alpha
// components of each pixel. If a Accum operation results in a value outside
// the range (-1, 1), the contents of an accumulation buffer pixel component
// are undefined.
//
// The operations are as follows:
//
//   GL.ACCUM
//       Obtains R, G, B, and A values from the buffer currently selected for
//       reading (see ReadBuffer). Each component value is divided by 2 n -
//       1 , where n is the number of bits allocated to each color component
//       in the currently selected buffer. The result is a floating-point
//       value in the range 0 1 , which is multiplied by value and added to
//       the corresponding pixel component in the accumulation buffer,
//       thereby updating the accumulation buffer.
//
//   GL.LOAD
//       Similar to GL.ACCUM, except that the current value in the
//       accumulation buffer is not used in the calculation of the new value.
//       That is, the R, G, B, and A values from the currently selected
//       buffer are divided by 2 n - 1 , multiplied by value, and then stored
//       in the corresponding accumulation buffer cell, overwriting the
//       current value.
//
//   GL.ADD
//       Adds value to each R, G, B, and A in the accumulation buffer.
//
//   GL.MULT
//       Multiplies each R, G, B, and A in the accumulation buffer by value
//       and returns the scaled component to its corresponding accumulation
//       buffer location.
//
//   GL.RETURN
//       Transfers accumulation buffer values to the color buffer or buffers
//       currently selected for writing. Each R, G, B, and A component is
//       multiplied by value, then multiplied by 2 n - 1 , clamped to the
//       range 0 2 n - 1 , and stored in the corresponding display buffer
//       cell. The only fragment operations that are applied to this transfer
//       are pixel ownership, scissor, dithering, and color writemasks.
//
// To clear the accumulation buffer, call ClearAccum with R, G, B, and A
// values to set it to, then call Clear with the accumulation buffer
// enabled.
//
// Error GL.INVALID_ENUM is generated if op is not an accepted value.
// GL.INVALID_OPERATION is generated if there is no accumulation buffer.
// GL.INVALID_OPERATION is generated if Accum is executed between the
// execution of Begin and the corresponding execution of End.
func (gl *GL) Accum(op glbase.Enum, value float32) {
	C.gl3_0_glAccum(gl.funcs, C.GLenum(op), C.GLfloat(value))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glIndexMask.xml
func (gl *GL) IndexMask(mask uint32) {
	C.gl3_0_glIndexMask(gl.funcs, C.GLuint(mask))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glClearIndex.xml
func (gl *GL) ClearIndex(c float32) {
	C.gl3_0_glClearIndex(gl.funcs, C.GLfloat(c))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glClearAccum.xml
func (gl *GL) ClearAccum(red, green, blue, alpha float32) {
	C.gl3_0_glClearAccum(gl.funcs, C.GLfloat(red), C.GLfloat(green), C.GLfloat(blue), C.GLfloat(alpha))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glPushName.xml
func (gl *GL) PushName(name uint32) {
	C.gl3_0_glPushName(gl.funcs, C.GLuint(name))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glPopName.xml
func (gl *GL) PopName() {
	C.gl3_0_glPopName(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glPassThrough.xml
func (gl *GL) PassThrough(token float32) {
	C.gl3_0_glPassThrough(gl.funcs, C.GLfloat(token))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glLoadName.xml
func (gl *GL) LoadName(name uint32) {
	C.gl3_0_glLoadName(gl.funcs, C.GLuint(name))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glInitNames.xml
func (gl *GL) InitNames() {
	C.gl3_0_glInitNames(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRenderMode.xml
func (gl *GL) RenderMode(mode glbase.Enum) int32 {
	glresult := C.gl3_0_glRenderMode(gl.funcs, C.GLenum(mode))
	return int32(glresult)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glSelectBuffer.xml
func (gl *GL) SelectBuffer(size int, buffer []glbase.Buffer) {
	C.gl3_0_glSelectBuffer(gl.funcs, C.GLsizei(size), (*C.GLuint)(unsafe.Pointer(&buffer[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glFeedbackBuffer.xml
func (gl *GL) FeedbackBuffer(size int, gltype glbase.Enum, buffer []float32) {
	C.gl3_0_glFeedbackBuffer(gl.funcs, C.GLsizei(size), C.GLenum(gltype), (*C.GLfloat)(unsafe.Pointer(&buffer[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexGeniv.xml
func (gl *GL) TexGeniv(coord, pname glbase.Enum, params []int32) {
	C.gl3_0_glTexGeniv(gl.funcs, C.GLenum(coord), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexGeni.xml
func (gl *GL) TexGeni(coord, pname glbase.Enum, param int32) {
	C.gl3_0_glTexGeni(gl.funcs, C.GLenum(coord), C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexGenfv.xml
func (gl *GL) TexGenfv(coord, pname glbase.Enum, params []float32) {
	C.gl3_0_glTexGenfv(gl.funcs, C.GLenum(coord), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexGenf.xml
func (gl *GL) TexGenf(coord, pname glbase.Enum, param float32) {
	C.gl3_0_glTexGenf(gl.funcs, C.GLenum(coord), C.GLenum(pname), C.GLfloat(param))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexGendv.xml
func (gl *GL) TexGendv(coord, pname glbase.Enum, params []float64) {
	C.gl3_0_glTexGendv(gl.funcs, C.GLenum(coord), C.GLenum(pname), (*C.GLdouble)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexGend.xml
func (gl *GL) TexGend(coord, pname glbase.Enum, param float64) {
	C.gl3_0_glTexGend(gl.funcs, C.GLenum(coord), C.GLenum(pname), C.GLdouble(param))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexEnviv.xml
func (gl *GL) TexEnviv(target, pname glbase.Enum, params []int32) {
	C.gl3_0_glTexEnviv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexEnvi.xml
func (gl *GL) TexEnvi(target, pname glbase.Enum, param int32) {
	C.gl3_0_glTexEnvi(gl.funcs, C.GLenum(target), C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexEnvfv.xml
func (gl *GL) TexEnvfv(target, pname glbase.Enum, params []float32) {
	C.gl3_0_glTexEnvfv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexEnvf.xml
func (gl *GL) TexEnvf(target, pname glbase.Enum, param float32) {
	C.gl3_0_glTexEnvf(gl.funcs, C.GLenum(target), C.GLenum(pname), C.GLfloat(param))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glShadeModel.xml
func (gl *GL) ShadeModel(mode glbase.Enum) {
	C.gl3_0_glShadeModel(gl.funcs, C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glPolygonStipple.xml
func (gl *GL) PolygonStipple(mask []uint8) {
	C.gl3_0_glPolygonStipple(gl.funcs, (*C.GLubyte)(unsafe.Pointer(&mask[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMaterialiv.xml
func (gl *GL) Materialiv(face, pname glbase.Enum, params []int32) {
	C.gl3_0_glMaterialiv(gl.funcs, C.GLenum(face), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMateriali.xml
func (gl *GL) Materiali(face, pname glbase.Enum, param int32) {
	C.gl3_0_glMateriali(gl.funcs, C.GLenum(face), C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMaterialfv.xml
func (gl *GL) Materialfv(face, pname glbase.Enum, params []float32) {
	C.gl3_0_glMaterialfv(gl.funcs, C.GLenum(face), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMaterialf.xml
func (gl *GL) Materialf(face, pname glbase.Enum, param float32) {
	C.gl3_0_glMaterialf(gl.funcs, C.GLenum(face), C.GLenum(pname), C.GLfloat(param))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glLineStipple.xml
func (gl *GL) LineStipple(factor int32, pattern uint16) {
	C.gl3_0_glLineStipple(gl.funcs, C.GLint(factor), C.GLushort(pattern))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glLightModeliv.xml
func (gl *GL) LightModeliv(pname glbase.Enum, params []int32) {
	C.gl3_0_glLightModeliv(gl.funcs, C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glLightModeli.xml
func (gl *GL) LightModeli(pname glbase.Enum, param int32) {
	C.gl3_0_glLightModeli(gl.funcs, C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glLightModelfv.xml
func (gl *GL) LightModelfv(pname glbase.Enum, params []float32) {
	C.gl3_0_glLightModelfv(gl.funcs, C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glLightModelf.xml
func (gl *GL) LightModelf(pname glbase.Enum, param float32) {
	C.gl3_0_glLightModelf(gl.funcs, C.GLenum(pname), C.GLfloat(param))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glLightiv.xml
func (gl *GL) Lightiv(light, pname glbase.Enum, params []int32) {
	C.gl3_0_glLightiv(gl.funcs, C.GLenum(light), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glLighti.xml
func (gl *GL) Lighti(light, pname glbase.Enum, param int32) {
	C.gl3_0_glLighti(gl.funcs, C.GLenum(light), C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glLightfv.xml
func (gl *GL) Lightfv(light, pname glbase.Enum, params []float32) {
	C.gl3_0_glLightfv(gl.funcs, C.GLenum(light), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glLightf.xml
func (gl *GL) Lightf(light, pname glbase.Enum, param float32) {
	C.gl3_0_glLightf(gl.funcs, C.GLenum(light), C.GLenum(pname), C.GLfloat(param))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glFogiv.xml
func (gl *GL) Fogiv(pname glbase.Enum, params []int32) {
	C.gl3_0_glFogiv(gl.funcs, C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glFogi.xml
func (gl *GL) Fogi(pname glbase.Enum, param int32) {
	C.gl3_0_glFogi(gl.funcs, C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glFogfv.xml
func (gl *GL) Fogfv(pname glbase.Enum, params []float32) {
	C.gl3_0_glFogfv(gl.funcs, C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glFogf.xml
func (gl *GL) Fogf(pname glbase.Enum, param float32) {
	C.gl3_0_glFogf(gl.funcs, C.GLenum(pname), C.GLfloat(param))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColorMaterial.xml
func (gl *GL) ColorMaterial(face, mode glbase.Enum) {
	C.gl3_0_glColorMaterial(gl.funcs, C.GLenum(face), C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glClipPlane.xml
func (gl *GL) ClipPlane(plane glbase.Enum, equation []float64) {
	C.gl3_0_glClipPlane(gl.funcs, C.GLenum(plane), (*C.GLdouble)(unsafe.Pointer(&equation[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertex4sv.xml
func (gl *GL) Vertex4sv(v []int16) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glVertex4sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertex4s.xml
func (gl *GL) Vertex4s(x, y, z, w int16) {
	C.gl3_0_glVertex4s(gl.funcs, C.GLshort(x), C.GLshort(y), C.GLshort(z), C.GLshort(w))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertex4iv.xml
func (gl *GL) Vertex4iv(v []int32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glVertex4iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertex4i.xml
func (gl *GL) Vertex4i(x, y, z, w int) {
	C.gl3_0_glVertex4i(gl.funcs, C.GLint(x), C.GLint(y), C.GLint(z), C.GLint(w))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertex4fv.xml
func (gl *GL) Vertex4fv(v []float32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glVertex4fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertex4f.xml
func (gl *GL) Vertex4f(x, y, z, w float32) {
	C.gl3_0_glVertex4f(gl.funcs, C.GLfloat(x), C.GLfloat(y), C.GLfloat(z), C.GLfloat(w))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertex4dv.xml
func (gl *GL) Vertex4dv(v []float64) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glVertex4dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertex4d.xml
func (gl *GL) Vertex4d(x, y, z, w float64) {
	C.gl3_0_glVertex4d(gl.funcs, C.GLdouble(x), C.GLdouble(y), C.GLdouble(z), C.GLdouble(w))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertex3sv.xml
func (gl *GL) Vertex3sv(v []int16) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glVertex3sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertex3s.xml
func (gl *GL) Vertex3s(x, y, z int16) {
	C.gl3_0_glVertex3s(gl.funcs, C.GLshort(x), C.GLshort(y), C.GLshort(z))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertex3iv.xml
func (gl *GL) Vertex3iv(v []int32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glVertex3iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertex3i.xml
func (gl *GL) Vertex3i(x, y, z int) {
	C.gl3_0_glVertex3i(gl.funcs, C.GLint(x), C.GLint(y), C.GLint(z))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertex3fv.xml
func (gl *GL) Vertex3fv(v []float32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glVertex3fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertex3f.xml
func (gl *GL) Vertex3f(x, y, z float32) {
	C.gl3_0_glVertex3f(gl.funcs, C.GLfloat(x), C.GLfloat(y), C.GLfloat(z))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertex3dv.xml
func (gl *GL) Vertex3dv(v []float64) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glVertex3dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertex3d.xml
func (gl *GL) Vertex3d(x, y, z float64) {
	C.gl3_0_glVertex3d(gl.funcs, C.GLdouble(x), C.GLdouble(y), C.GLdouble(z))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertex2sv.xml
func (gl *GL) Vertex2sv(v []int16) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glVertex2sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertex2s.xml
func (gl *GL) Vertex2s(x, y int16) {
	C.gl3_0_glVertex2s(gl.funcs, C.GLshort(x), C.GLshort(y))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertex2iv.xml
func (gl *GL) Vertex2iv(v []int32) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glVertex2iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertex2i.xml
func (gl *GL) Vertex2i(x, y int) {
	C.gl3_0_glVertex2i(gl.funcs, C.GLint(x), C.GLint(y))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertex2fv.xml
func (gl *GL) Vertex2fv(v []float32) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glVertex2fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertex2f.xml
func (gl *GL) Vertex2f(x, y float32) {
	C.gl3_0_glVertex2f(gl.funcs, C.GLfloat(x), C.GLfloat(y))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertex2dv.xml
func (gl *GL) Vertex2dv(v []float64) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glVertex2dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertex2d.xml
func (gl *GL) Vertex2d(x, y float64) {
	C.gl3_0_glVertex2d(gl.funcs, C.GLdouble(x), C.GLdouble(y))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord4sv.xml
func (gl *GL) TexCoord4sv(v []int16) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glTexCoord4sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord4s.xml
func (gl *GL) TexCoord4s(s, t, r, q int16) {
	C.gl3_0_glTexCoord4s(gl.funcs, C.GLshort(s), C.GLshort(t), C.GLshort(r), C.GLshort(q))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord4iv.xml
func (gl *GL) TexCoord4iv(v []int32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glTexCoord4iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord4i.xml
func (gl *GL) TexCoord4i(s, t, r, q int32) {
	C.gl3_0_glTexCoord4i(gl.funcs, C.GLint(s), C.GLint(t), C.GLint(r), C.GLint(q))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord4fv.xml
func (gl *GL) TexCoord4fv(v []float32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glTexCoord4fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord4f.xml
func (gl *GL) TexCoord4f(s, t, r, q float32) {
	C.gl3_0_glTexCoord4f(gl.funcs, C.GLfloat(s), C.GLfloat(t), C.GLfloat(r), C.GLfloat(q))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord4dv.xml
func (gl *GL) TexCoord4dv(v []float64) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glTexCoord4dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord4d.xml
func (gl *GL) TexCoord4d(s, t, r, q float64) {
	C.gl3_0_glTexCoord4d(gl.funcs, C.GLdouble(s), C.GLdouble(t), C.GLdouble(r), C.GLdouble(q))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord3sv.xml
func (gl *GL) TexCoord3sv(v []int16) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glTexCoord3sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord3s.xml
func (gl *GL) TexCoord3s(s, t, r int16) {
	C.gl3_0_glTexCoord3s(gl.funcs, C.GLshort(s), C.GLshort(t), C.GLshort(r))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord3iv.xml
func (gl *GL) TexCoord3iv(v []int32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glTexCoord3iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord3i.xml
func (gl *GL) TexCoord3i(s, t, r int32) {
	C.gl3_0_glTexCoord3i(gl.funcs, C.GLint(s), C.GLint(t), C.GLint(r))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord3fv.xml
func (gl *GL) TexCoord3fv(v []float32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glTexCoord3fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord3f.xml
func (gl *GL) TexCoord3f(s, t, r float32) {
	C.gl3_0_glTexCoord3f(gl.funcs, C.GLfloat(s), C.GLfloat(t), C.GLfloat(r))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord3dv.xml
func (gl *GL) TexCoord3dv(v []float64) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glTexCoord3dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord3d.xml
func (gl *GL) TexCoord3d(s, t, r float64) {
	C.gl3_0_glTexCoord3d(gl.funcs, C.GLdouble(s), C.GLdouble(t), C.GLdouble(r))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord2sv.xml
func (gl *GL) TexCoord2sv(v []int16) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glTexCoord2sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord2s.xml
func (gl *GL) TexCoord2s(s, t int16) {
	C.gl3_0_glTexCoord2s(gl.funcs, C.GLshort(s), C.GLshort(t))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord2iv.xml
func (gl *GL) TexCoord2iv(v []int32) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glTexCoord2iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord2i.xml
func (gl *GL) TexCoord2i(s, t int32) {
	C.gl3_0_glTexCoord2i(gl.funcs, C.GLint(s), C.GLint(t))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord2fv.xml
func (gl *GL) TexCoord2fv(v []float32) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glTexCoord2fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord2f.xml
func (gl *GL) TexCoord2f(s, t float32) {
	C.gl3_0_glTexCoord2f(gl.funcs, C.GLfloat(s), C.GLfloat(t))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord2dv.xml
func (gl *GL) TexCoord2dv(v []float64) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glTexCoord2dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord2d.xml
func (gl *GL) TexCoord2d(s, t float64) {
	C.gl3_0_glTexCoord2d(gl.funcs, C.GLdouble(s), C.GLdouble(t))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord1sv.xml
func (gl *GL) TexCoord1sv(v []int16) {
	C.gl3_0_glTexCoord1sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord1s.xml
func (gl *GL) TexCoord1s(s int16) {
	C.gl3_0_glTexCoord1s(gl.funcs, C.GLshort(s))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord1iv.xml
func (gl *GL) TexCoord1iv(v []int32) {
	C.gl3_0_glTexCoord1iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord1i.xml
func (gl *GL) TexCoord1i(s int32) {
	C.gl3_0_glTexCoord1i(gl.funcs, C.GLint(s))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord1fv.xml
func (gl *GL) TexCoord1fv(v []float32) {
	C.gl3_0_glTexCoord1fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord1f.xml
func (gl *GL) TexCoord1f(s float32) {
	C.gl3_0_glTexCoord1f(gl.funcs, C.GLfloat(s))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord1dv.xml
func (gl *GL) TexCoord1dv(v []float64) {
	C.gl3_0_glTexCoord1dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoord1d.xml
func (gl *GL) TexCoord1d(s float64) {
	C.gl3_0_glTexCoord1d(gl.funcs, C.GLdouble(s))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRectsv.xml
func (gl *GL) Rectsv(v1, v2 []int16) {
	C.gl3_0_glRectsv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v1[0])), (*C.GLshort)(unsafe.Pointer(&v2[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRects.xml
func (gl *GL) Rects(x1, y1, x2, y2 int16) {
	C.gl3_0_glRects(gl.funcs, C.GLshort(x1), C.GLshort(y1), C.GLshort(x2), C.GLshort(y2))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRectiv.xml
func (gl *GL) Rectiv(v1, v2 []int32) {
	C.gl3_0_glRectiv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v1[0])), (*C.GLint)(unsafe.Pointer(&v2[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRecti.xml
func (gl *GL) Recti(x1, y1, x2, y2 int32) {
	C.gl3_0_glRecti(gl.funcs, C.GLint(x1), C.GLint(y1), C.GLint(x2), C.GLint(y2))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRectfv.xml
func (gl *GL) Rectfv(v1, v2 []float32) {
	C.gl3_0_glRectfv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v1[0])), (*C.GLfloat)(unsafe.Pointer(&v2[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRectf.xml
func (gl *GL) Rectf(x1, y1, x2, y2 float32) {
	C.gl3_0_glRectf(gl.funcs, C.GLfloat(x1), C.GLfloat(y1), C.GLfloat(x2), C.GLfloat(y2))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRectdv.xml
func (gl *GL) Rectdv(v1, v2 []float64) {
	C.gl3_0_glRectdv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v1[0])), (*C.GLdouble)(unsafe.Pointer(&v2[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRectd.xml
func (gl *GL) Rectd(x1, y1, x2, y2 float64) {
	C.gl3_0_glRectd(gl.funcs, C.GLdouble(x1), C.GLdouble(y1), C.GLdouble(x2), C.GLdouble(y2))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRasterPos4sv.xml
func (gl *GL) RasterPos4sv(v []int16) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glRasterPos4sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRasterPos4s.xml
func (gl *GL) RasterPos4s(x, y, z, w int16) {
	C.gl3_0_glRasterPos4s(gl.funcs, C.GLshort(x), C.GLshort(y), C.GLshort(z), C.GLshort(w))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRasterPos4iv.xml
func (gl *GL) RasterPos4iv(v []int32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glRasterPos4iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRasterPos4i.xml
func (gl *GL) RasterPos4i(x, y, z, w int) {
	C.gl3_0_glRasterPos4i(gl.funcs, C.GLint(x), C.GLint(y), C.GLint(z), C.GLint(w))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRasterPos4fv.xml
func (gl *GL) RasterPos4fv(v []float32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glRasterPos4fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRasterPos4f.xml
func (gl *GL) RasterPos4f(x, y, z, w float32) {
	C.gl3_0_glRasterPos4f(gl.funcs, C.GLfloat(x), C.GLfloat(y), C.GLfloat(z), C.GLfloat(w))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRasterPos4dv.xml
func (gl *GL) RasterPos4dv(v []float64) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glRasterPos4dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRasterPos4d.xml
func (gl *GL) RasterPos4d(x, y, z, w float64) {
	C.gl3_0_glRasterPos4d(gl.funcs, C.GLdouble(x), C.GLdouble(y), C.GLdouble(z), C.GLdouble(w))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRasterPos3sv.xml
func (gl *GL) RasterPos3sv(v []int16) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glRasterPos3sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRasterPos3s.xml
func (gl *GL) RasterPos3s(x, y, z int16) {
	C.gl3_0_glRasterPos3s(gl.funcs, C.GLshort(x), C.GLshort(y), C.GLshort(z))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRasterPos3iv.xml
func (gl *GL) RasterPos3iv(v []int32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glRasterPos3iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRasterPos3i.xml
func (gl *GL) RasterPos3i(x, y, z int) {
	C.gl3_0_glRasterPos3i(gl.funcs, C.GLint(x), C.GLint(y), C.GLint(z))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRasterPos3fv.xml
func (gl *GL) RasterPos3fv(v []float32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glRasterPos3fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRasterPos3f.xml
func (gl *GL) RasterPos3f(x, y, z float32) {
	C.gl3_0_glRasterPos3f(gl.funcs, C.GLfloat(x), C.GLfloat(y), C.GLfloat(z))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRasterPos3dv.xml
func (gl *GL) RasterPos3dv(v []float64) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glRasterPos3dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRasterPos3d.xml
func (gl *GL) RasterPos3d(x, y, z float64) {
	C.gl3_0_glRasterPos3d(gl.funcs, C.GLdouble(x), C.GLdouble(y), C.GLdouble(z))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRasterPos2sv.xml
func (gl *GL) RasterPos2sv(v []int16) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glRasterPos2sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRasterPos2s.xml
func (gl *GL) RasterPos2s(x, y int16) {
	C.gl3_0_glRasterPos2s(gl.funcs, C.GLshort(x), C.GLshort(y))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRasterPos2iv.xml
func (gl *GL) RasterPos2iv(v []int32) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glRasterPos2iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRasterPos2i.xml
func (gl *GL) RasterPos2i(x, y int) {
	C.gl3_0_glRasterPos2i(gl.funcs, C.GLint(x), C.GLint(y))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRasterPos2fv.xml
func (gl *GL) RasterPos2fv(v []float32) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glRasterPos2fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRasterPos2f.xml
func (gl *GL) RasterPos2f(x, y float32) {
	C.gl3_0_glRasterPos2f(gl.funcs, C.GLfloat(x), C.GLfloat(y))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRasterPos2dv.xml
func (gl *GL) RasterPos2dv(v []float64) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glRasterPos2dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glRasterPos2d.xml
func (gl *GL) RasterPos2d(x, y float64) {
	C.gl3_0_glRasterPos2d(gl.funcs, C.GLdouble(x), C.GLdouble(y))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glNormal3sv.xml
func (gl *GL) Normal3sv(v []int16) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glNormal3sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glNormal3s.xml
func (gl *GL) Normal3s(nx, ny, nz int16) {
	C.gl3_0_glNormal3s(gl.funcs, C.GLshort(nx), C.GLshort(ny), C.GLshort(nz))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glNormal3iv.xml
func (gl *GL) Normal3iv(v []int32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glNormal3iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glNormal3i.xml
func (gl *GL) Normal3i(nx, ny, nz int32) {
	C.gl3_0_glNormal3i(gl.funcs, C.GLint(nx), C.GLint(ny), C.GLint(nz))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glNormal3fv.xml
func (gl *GL) Normal3fv(v []float32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glNormal3fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glNormal3f.xml
func (gl *GL) Normal3f(nx, ny, nz float32) {
	C.gl3_0_glNormal3f(gl.funcs, C.GLfloat(nx), C.GLfloat(ny), C.GLfloat(nz))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glNormal3dv.xml
func (gl *GL) Normal3dv(v []float64) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glNormal3dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glNormal3d.xml
func (gl *GL) Normal3d(nx, ny, nz float64) {
	C.gl3_0_glNormal3d(gl.funcs, C.GLdouble(nx), C.GLdouble(ny), C.GLdouble(nz))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glNormal3bv.xml
func (gl *GL) Normal3bv(v []byte) {
	C.gl3_0_glNormal3bv(gl.funcs, (*C.GLbyte)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glNormal3b.xml
func (gl *GL) Normal3b(nx, ny, nz byte) {
	C.gl3_0_glNormal3b(gl.funcs, C.GLbyte(nx), C.GLbyte(ny), C.GLbyte(nz))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glIndexsv.xml
func (gl *GL) Indexsv(c []int16) {
	C.gl3_0_glIndexsv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&c[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glIndexs.xml
func (gl *GL) Indexs(c int16) {
	C.gl3_0_glIndexs(gl.funcs, C.GLshort(c))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glIndexiv.xml
func (gl *GL) Indexiv(c []int32) {
	C.gl3_0_glIndexiv(gl.funcs, (*C.GLint)(unsafe.Pointer(&c[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glIndexi.xml
func (gl *GL) Indexi(c int32) {
	C.gl3_0_glIndexi(gl.funcs, C.GLint(c))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glIndexfv.xml
func (gl *GL) Indexfv(c []float32) {
	C.gl3_0_glIndexfv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&c[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glIndexf.xml
func (gl *GL) Indexf(c float32) {
	C.gl3_0_glIndexf(gl.funcs, C.GLfloat(c))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glIndexdv.xml
func (gl *GL) Indexdv(c []float64) {
	C.gl3_0_glIndexdv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&c[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glIndexd.xml
func (gl *GL) Indexd(c float64) {
	C.gl3_0_glIndexd(gl.funcs, C.GLdouble(c))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glEnd.xml
func (gl *GL) End() {
	C.gl3_0_glEnd(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glEdgeFlagv.xml
func (gl *GL) EdgeFlagv(flag []bool) {
	C.gl3_0_glEdgeFlagv(gl.funcs, (*C.GLboolean)(unsafe.Pointer(&flag[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glEdgeFlag.xml
func (gl *GL) EdgeFlag(flag bool) {
	C.gl3_0_glEdgeFlag(gl.funcs, *(*C.GLboolean)(unsafe.Pointer(&flag)))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor4usv.xml
func (gl *GL) Color4usv(v []uint16) {
	C.gl3_0_glColor4usv(gl.funcs, (*C.GLushort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor4us.xml
func (gl *GL) Color4us(red, green, blue, alpha uint16) {
	C.gl3_0_glColor4us(gl.funcs, C.GLushort(red), C.GLushort(green), C.GLushort(blue), C.GLushort(alpha))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor4uiv.xml
func (gl *GL) Color4uiv(v []uint32) {
	C.gl3_0_glColor4uiv(gl.funcs, (*C.GLuint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor4ui.xml
func (gl *GL) Color4ui(red, green, blue, alpha uint32) {
	C.gl3_0_glColor4ui(gl.funcs, C.GLuint(red), C.GLuint(green), C.GLuint(blue), C.GLuint(alpha))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor4ubv.xml
func (gl *GL) Color4ubv(v []uint8) {
	C.gl3_0_glColor4ubv(gl.funcs, (*C.GLubyte)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor4ub.xml
func (gl *GL) Color4ub(red, green, blue, alpha uint8) {
	C.gl3_0_glColor4ub(gl.funcs, C.GLubyte(red), C.GLubyte(green), C.GLubyte(blue), C.GLubyte(alpha))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor4sv.xml
func (gl *GL) Color4sv(v []int16) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glColor4sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor4s.xml
func (gl *GL) Color4s(red, green, blue, alpha int16) {
	C.gl3_0_glColor4s(gl.funcs, C.GLshort(red), C.GLshort(green), C.GLshort(blue), C.GLshort(alpha))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor4iv.xml
func (gl *GL) Color4iv(v []int32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glColor4iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor4i.xml
func (gl *GL) Color4i(red, green, blue, alpha int32) {
	C.gl3_0_glColor4i(gl.funcs, C.GLint(red), C.GLint(green), C.GLint(blue), C.GLint(alpha))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor4fv.xml
func (gl *GL) Color4fv(v []float32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glColor4fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor4f.xml
func (gl *GL) Color4f(red, green, blue, alpha float32) {
	C.gl3_0_glColor4f(gl.funcs, C.GLfloat(red), C.GLfloat(green), C.GLfloat(blue), C.GLfloat(alpha))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor4dv.xml
func (gl *GL) Color4dv(v []float64) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glColor4dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor4d.xml
func (gl *GL) Color4d(red, green, blue, alpha float64) {
	C.gl3_0_glColor4d(gl.funcs, C.GLdouble(red), C.GLdouble(green), C.GLdouble(blue), C.GLdouble(alpha))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor4bv.xml
func (gl *GL) Color4bv(v []byte) {
	C.gl3_0_glColor4bv(gl.funcs, (*C.GLbyte)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor4b.xml
func (gl *GL) Color4b(red, green, blue, alpha byte) {
	C.gl3_0_glColor4b(gl.funcs, C.GLbyte(red), C.GLbyte(green), C.GLbyte(blue), C.GLbyte(alpha))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor3usv.xml
func (gl *GL) Color3usv(v []uint16) {
	C.gl3_0_glColor3usv(gl.funcs, (*C.GLushort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor3us.xml
func (gl *GL) Color3us(red, green, blue uint16) {
	C.gl3_0_glColor3us(gl.funcs, C.GLushort(red), C.GLushort(green), C.GLushort(blue))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor3uiv.xml
func (gl *GL) Color3uiv(v []uint32) {
	C.gl3_0_glColor3uiv(gl.funcs, (*C.GLuint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor3ui.xml
func (gl *GL) Color3ui(red, green, blue uint32) {
	C.gl3_0_glColor3ui(gl.funcs, C.GLuint(red), C.GLuint(green), C.GLuint(blue))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor3ubv.xml
func (gl *GL) Color3ubv(v []uint8) {
	C.gl3_0_glColor3ubv(gl.funcs, (*C.GLubyte)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor3ub.xml
func (gl *GL) Color3ub(red, green, blue uint8) {
	C.gl3_0_glColor3ub(gl.funcs, C.GLubyte(red), C.GLubyte(green), C.GLubyte(blue))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor3sv.xml
func (gl *GL) Color3sv(v []int16) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glColor3sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor3s.xml
func (gl *GL) Color3s(red, green, blue int16) {
	C.gl3_0_glColor3s(gl.funcs, C.GLshort(red), C.GLshort(green), C.GLshort(blue))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor3iv.xml
func (gl *GL) Color3iv(v []int32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glColor3iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor3i.xml
func (gl *GL) Color3i(red, green, blue int32) {
	C.gl3_0_glColor3i(gl.funcs, C.GLint(red), C.GLint(green), C.GLint(blue))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor3fv.xml
func (gl *GL) Color3fv(v []float32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glColor3fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor3f.xml
func (gl *GL) Color3f(red, green, blue float32) {
	C.gl3_0_glColor3f(gl.funcs, C.GLfloat(red), C.GLfloat(green), C.GLfloat(blue))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor3dv.xml
func (gl *GL) Color3dv(v []float64) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glColor3dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor3d.xml
func (gl *GL) Color3d(red, green, blue float64) {
	C.gl3_0_glColor3d(gl.funcs, C.GLdouble(red), C.GLdouble(green), C.GLdouble(blue))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor3bv.xml
func (gl *GL) Color3bv(v []byte) {
	C.gl3_0_glColor3bv(gl.funcs, (*C.GLbyte)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColor3b.xml
func (gl *GL) Color3b(red, green, blue byte) {
	C.gl3_0_glColor3b(gl.funcs, C.GLbyte(red), C.GLbyte(green), C.GLbyte(blue))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glBitmap.xml
func (gl *GL) Bitmap(width, height int, xorig, yorig, xmove, ymove float32, bitmap []uint8) {
	C.gl3_0_glBitmap(gl.funcs, C.GLsizei(width), C.GLsizei(height), C.GLfloat(xorig), C.GLfloat(yorig), C.GLfloat(xmove), C.GLfloat(ymove), (*C.GLubyte)(unsafe.Pointer(&bitmap[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glBegin.xml
func (gl *GL) Begin(mode glbase.Enum) {
	C.gl3_0_glBegin(gl.funcs, C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glListBase.xml
func (gl *GL) ListBase(base uint32) {
	C.gl3_0_glListBase(gl.funcs, C.GLuint(base))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGenLists.xml
func (gl *GL) GenLists(range_ int32) uint32 {
	glresult := C.gl3_0_glGenLists(gl.funcs, C.GLsizei(range_))
	return uint32(glresult)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glDeleteLists.xml
func (gl *GL) DeleteLists(list uint32, range_ int32) {
	C.gl3_0_glDeleteLists(gl.funcs, C.GLuint(list), C.GLsizei(range_))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glCallLists.xml
func (gl *GL) CallLists(n int, gltype glbase.Enum, lists interface{}) {
	var lists_ptr unsafe.Pointer
	var lists_v = reflect.ValueOf(lists)
	if lists != nil && lists_v.Kind() != reflect.Slice {
		panic("parameter lists must be a slice")
	}
	if lists != nil {
		lists_ptr = unsafe.Pointer(lists_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glCallLists(gl.funcs, C.GLsizei(n), C.GLenum(gltype), lists_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glCallList.xml
func (gl *GL) CallList(list uint32) {
	C.gl3_0_glCallList(gl.funcs, C.GLuint(list))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glEndList.xml
func (gl *GL) EndList() {
	C.gl3_0_glEndList(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glNewList.xml
func (gl *GL) NewList(list uint32, mode glbase.Enum) {
	C.gl3_0_glNewList(gl.funcs, C.GLuint(list), C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glPushClientAttrib.xml
func (gl *GL) PushClientAttrib(mask glbase.Bitfield) {
	C.gl3_0_glPushClientAttrib(gl.funcs, C.GLbitfield(mask))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glPopClientAttrib.xml
func (gl *GL) PopClientAttrib() {
	C.gl3_0_glPopClientAttrib(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glPrioritizeTextures.xml
func (gl *GL) PrioritizeTextures(n int, textures []glbase.Texture, priorities []float32) {
	C.gl3_0_glPrioritizeTextures(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&textures[0])), (*C.GLfloat)(unsafe.Pointer(&priorities[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glAreTexturesResident.xml
func (gl *GL) AreTexturesResident(n int, textures []glbase.Texture, residences []bool) bool {
	glresult := C.gl3_0_glAreTexturesResident(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&textures[0])), (*C.GLboolean)(unsafe.Pointer(&residences[0])))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexPointer.xml
func (gl *GL) VertexPointer(size int, gltype glbase.Enum, stride int, pointer interface{}) {
	var pointer_ptr unsafe.Pointer
	var pointer_v = reflect.ValueOf(pointer)
	if pointer != nil && pointer_v.Kind() != reflect.Slice {
		panic("parameter pointer must be a slice")
	}
	if pointer != nil {
		pointer_ptr = unsafe.Pointer(pointer_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glVertexPointer(gl.funcs, C.GLint(size), C.GLenum(gltype), C.GLsizei(stride), pointer_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glTexCoordPointer.xml
func (gl *GL) TexCoordPointer(size int, gltype glbase.Enum, stride int, pointer interface{}) {
	var pointer_ptr unsafe.Pointer
	var pointer_v = reflect.ValueOf(pointer)
	if pointer != nil && pointer_v.Kind() != reflect.Slice {
		panic("parameter pointer must be a slice")
	}
	if pointer != nil {
		pointer_ptr = unsafe.Pointer(pointer_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glTexCoordPointer(gl.funcs, C.GLint(size), C.GLenum(gltype), C.GLsizei(stride), pointer_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glNormalPointer.xml
func (gl *GL) NormalPointer(gltype glbase.Enum, stride int, pointer interface{}) {
	var pointer_ptr unsafe.Pointer
	var pointer_v = reflect.ValueOf(pointer)
	if pointer != nil && pointer_v.Kind() != reflect.Slice {
		panic("parameter pointer must be a slice")
	}
	if pointer != nil {
		pointer_ptr = unsafe.Pointer(pointer_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glNormalPointer(gl.funcs, C.GLenum(gltype), C.GLsizei(stride), pointer_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glInterleavedArrays.xml
func (gl *GL) InterleavedArrays(format glbase.Enum, stride int, pointer interface{}) {
	var pointer_ptr unsafe.Pointer
	var pointer_v = reflect.ValueOf(pointer)
	if pointer != nil && pointer_v.Kind() != reflect.Slice {
		panic("parameter pointer must be a slice")
	}
	if pointer != nil {
		pointer_ptr = unsafe.Pointer(pointer_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glInterleavedArrays(gl.funcs, C.GLenum(format), C.GLsizei(stride), pointer_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glIndexPointer.xml
func (gl *GL) IndexPointer(gltype glbase.Enum, stride int, pointer interface{}) {
	var pointer_ptr unsafe.Pointer
	var pointer_v = reflect.ValueOf(pointer)
	if pointer != nil && pointer_v.Kind() != reflect.Slice {
		panic("parameter pointer must be a slice")
	}
	if pointer != nil {
		pointer_ptr = unsafe.Pointer(pointer_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glIndexPointer(gl.funcs, C.GLenum(gltype), C.GLsizei(stride), pointer_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glEnableClientState.xml
func (gl *GL) EnableClientState(array glbase.Enum) {
	C.gl3_0_glEnableClientState(gl.funcs, C.GLenum(array))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glEdgeFlagPointer.xml
func (gl *GL) EdgeFlagPointer(stride int, pointer interface{}) {
	var pointer_ptr unsafe.Pointer
	var pointer_v = reflect.ValueOf(pointer)
	if pointer != nil && pointer_v.Kind() != reflect.Slice {
		panic("parameter pointer must be a slice")
	}
	if pointer != nil {
		pointer_ptr = unsafe.Pointer(pointer_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glEdgeFlagPointer(gl.funcs, C.GLsizei(stride), pointer_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glDisableClientState.xml
func (gl *GL) DisableClientState(array glbase.Enum) {
	C.gl3_0_glDisableClientState(gl.funcs, C.GLenum(array))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColorPointer.xml
func (gl *GL) ColorPointer(size int, gltype glbase.Enum, stride int, pointer interface{}) {
	var pointer_ptr unsafe.Pointer
	var pointer_v = reflect.ValueOf(pointer)
	if pointer != nil && pointer_v.Kind() != reflect.Slice {
		panic("parameter pointer must be a slice")
	}
	if pointer != nil {
		pointer_ptr = unsafe.Pointer(pointer_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glColorPointer(gl.funcs, C.GLint(size), C.GLenum(gltype), C.GLsizei(stride), pointer_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glArrayElement.xml
func (gl *GL) ArrayElement(i int32) {
	C.gl3_0_glArrayElement(gl.funcs, C.GLint(i))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glResetMinmax.xml
func (gl *GL) ResetMinmax(target glbase.Enum) {
	C.gl3_0_glResetMinmax(gl.funcs, C.GLenum(target))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glResetHistogram.xml
func (gl *GL) ResetHistogram(target glbase.Enum) {
	C.gl3_0_glResetHistogram(gl.funcs, C.GLenum(target))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMinmax.xml
func (gl *GL) Minmax(target, internalFormat glbase.Enum, sink bool) {
	C.gl3_0_glMinmax(gl.funcs, C.GLenum(target), C.GLenum(internalFormat), *(*C.GLboolean)(unsafe.Pointer(&sink)))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glHistogram.xml
func (gl *GL) Histogram(target glbase.Enum, width int, internalFormat glbase.Enum, sink bool) {
	C.gl3_0_glHistogram(gl.funcs, C.GLenum(target), C.GLsizei(width), C.GLenum(internalFormat), *(*C.GLboolean)(unsafe.Pointer(&sink)))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetMinmaxParameteriv.xml
func (gl *GL) GetMinmaxParameteriv(target, pname glbase.Enum, params []int32) {
	C.gl3_0_glGetMinmaxParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetMinmaxParameterfv.xml
func (gl *GL) GetMinmaxParameterfv(target, pname glbase.Enum, params []float32) {
	C.gl3_0_glGetMinmaxParameterfv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetMinmax.xml
func (gl *GL) GetMinmax(target glbase.Enum, reset bool, format, gltype glbase.Enum, values interface{}) {
	var values_ptr unsafe.Pointer
	var values_v = reflect.ValueOf(values)
	if values != nil && values_v.Kind() != reflect.Slice {
		panic("parameter values must be a slice")
	}
	if values != nil {
		values_ptr = unsafe.Pointer(values_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glGetMinmax(gl.funcs, C.GLenum(target), *(*C.GLboolean)(unsafe.Pointer(&reset)), C.GLenum(format), C.GLenum(gltype), values_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetHistogramParameteriv.xml
func (gl *GL) GetHistogramParameteriv(target, pname glbase.Enum, params []int32) {
	C.gl3_0_glGetHistogramParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetHistogramParameterfv.xml
func (gl *GL) GetHistogramParameterfv(target, pname glbase.Enum, params []float32) {
	C.gl3_0_glGetHistogramParameterfv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetHistogram.xml
func (gl *GL) GetHistogram(target glbase.Enum, reset bool, format, gltype glbase.Enum, values interface{}) {
	var values_ptr unsafe.Pointer
	var values_v = reflect.ValueOf(values)
	if values != nil && values_v.Kind() != reflect.Slice {
		panic("parameter values must be a slice")
	}
	if values != nil {
		values_ptr = unsafe.Pointer(values_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glGetHistogram(gl.funcs, C.GLenum(target), *(*C.GLboolean)(unsafe.Pointer(&reset)), C.GLenum(format), C.GLenum(gltype), values_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glSeparableFilter2D.xml
func (gl *GL) SeparableFilter2D(target, internalFormat glbase.Enum, width, height int, format, gltype glbase.Enum, row, column interface{}) {
	var row_ptr unsafe.Pointer
	var row_v = reflect.ValueOf(row)
	if row != nil && row_v.Kind() != reflect.Slice {
		panic("parameter row must be a slice")
	}
	if row != nil {
		row_ptr = unsafe.Pointer(row_v.Index(0).Addr().Pointer())
	}
	var column_ptr unsafe.Pointer
	var column_v = reflect.ValueOf(column)
	if column != nil && column_v.Kind() != reflect.Slice {
		panic("parameter column must be a slice")
	}
	if column != nil {
		column_ptr = unsafe.Pointer(column_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glSeparableFilter2D(gl.funcs, C.GLenum(target), C.GLenum(internalFormat), C.GLsizei(width), C.GLsizei(height), C.GLenum(format), C.GLenum(gltype), row_ptr, column_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetSeparableFilter.xml
func (gl *GL) GetSeparableFilter(target, format, gltype glbase.Enum, row, column, span interface{}) {
	var row_ptr unsafe.Pointer
	var row_v = reflect.ValueOf(row)
	if row != nil && row_v.Kind() != reflect.Slice {
		panic("parameter row must be a slice")
	}
	if row != nil {
		row_ptr = unsafe.Pointer(row_v.Index(0).Addr().Pointer())
	}
	var column_ptr unsafe.Pointer
	var column_v = reflect.ValueOf(column)
	if column != nil && column_v.Kind() != reflect.Slice {
		panic("parameter column must be a slice")
	}
	if column != nil {
		column_ptr = unsafe.Pointer(column_v.Index(0).Addr().Pointer())
	}
	var span_ptr unsafe.Pointer
	var span_v = reflect.ValueOf(span)
	if span != nil && span_v.Kind() != reflect.Slice {
		panic("parameter span must be a slice")
	}
	if span != nil {
		span_ptr = unsafe.Pointer(span_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glGetSeparableFilter(gl.funcs, C.GLenum(target), C.GLenum(format), C.GLenum(gltype), row_ptr, column_ptr, span_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetConvolutionParameteriv.xml
func (gl *GL) GetConvolutionParameteriv(target, pname glbase.Enum, params []int32) {
	C.gl3_0_glGetConvolutionParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetConvolutionParameterfv.xml
func (gl *GL) GetConvolutionParameterfv(target, pname glbase.Enum, params []float32) {
	C.gl3_0_glGetConvolutionParameterfv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetConvolutionFilter.xml
func (gl *GL) GetConvolutionFilter(target, format, gltype glbase.Enum, image interface{}) {
	var image_ptr unsafe.Pointer
	var image_v = reflect.ValueOf(image)
	if image != nil && image_v.Kind() != reflect.Slice {
		panic("parameter image must be a slice")
	}
	if image != nil {
		image_ptr = unsafe.Pointer(image_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glGetConvolutionFilter(gl.funcs, C.GLenum(target), C.GLenum(format), C.GLenum(gltype), image_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glCopyConvolutionFilter2D.xml
func (gl *GL) CopyConvolutionFilter2D(target, internalFormat glbase.Enum, x, y, width, height int) {
	C.gl3_0_glCopyConvolutionFilter2D(gl.funcs, C.GLenum(target), C.GLenum(internalFormat), C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glCopyConvolutionFilter1D.xml
func (gl *GL) CopyConvolutionFilter1D(target, internalFormat glbase.Enum, x, y, width int) {
	C.gl3_0_glCopyConvolutionFilter1D(gl.funcs, C.GLenum(target), C.GLenum(internalFormat), C.GLint(x), C.GLint(y), C.GLsizei(width))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glConvolutionParameteriv.xml
func (gl *GL) ConvolutionParameteriv(target, pname glbase.Enum, params []int32) {
	C.gl3_0_glConvolutionParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glConvolutionParameteri.xml
func (gl *GL) ConvolutionParameteri(target, pname glbase.Enum, params int32) {
	C.gl3_0_glConvolutionParameteri(gl.funcs, C.GLenum(target), C.GLenum(pname), C.GLint(params))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glConvolutionParameterfv.xml
func (gl *GL) ConvolutionParameterfv(target, pname glbase.Enum, params []float32) {
	C.gl3_0_glConvolutionParameterfv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glConvolutionParameterf.xml
func (gl *GL) ConvolutionParameterf(target, pname glbase.Enum, params float32) {
	C.gl3_0_glConvolutionParameterf(gl.funcs, C.GLenum(target), C.GLenum(pname), C.GLfloat(params))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glConvolutionFilter2D.xml
func (gl *GL) ConvolutionFilter2D(target, internalFormat glbase.Enum, width, height int, format, gltype glbase.Enum, image interface{}) {
	var image_ptr unsafe.Pointer
	var image_v = reflect.ValueOf(image)
	if image != nil && image_v.Kind() != reflect.Slice {
		panic("parameter image must be a slice")
	}
	if image != nil {
		image_ptr = unsafe.Pointer(image_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glConvolutionFilter2D(gl.funcs, C.GLenum(target), C.GLenum(internalFormat), C.GLsizei(width), C.GLsizei(height), C.GLenum(format), C.GLenum(gltype), image_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glConvolutionFilter1D.xml
func (gl *GL) ConvolutionFilter1D(target, internalFormat glbase.Enum, width int, format, gltype glbase.Enum, image interface{}) {
	var image_ptr unsafe.Pointer
	var image_v = reflect.ValueOf(image)
	if image != nil && image_v.Kind() != reflect.Slice {
		panic("parameter image must be a slice")
	}
	if image != nil {
		image_ptr = unsafe.Pointer(image_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glConvolutionFilter1D(gl.funcs, C.GLenum(target), C.GLenum(internalFormat), C.GLsizei(width), C.GLenum(format), C.GLenum(gltype), image_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glCopyColorSubTable.xml
func (gl *GL) CopyColorSubTable(target glbase.Enum, start int32, x, y, width int) {
	C.gl3_0_glCopyColorSubTable(gl.funcs, C.GLenum(target), C.GLsizei(start), C.GLint(x), C.GLint(y), C.GLsizei(width))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColorSubTable.xml
func (gl *GL) ColorSubTable(target glbase.Enum, start int32, count int, format, gltype glbase.Enum, data interface{}) {
	var data_ptr unsafe.Pointer
	var data_v = reflect.ValueOf(data)
	if data != nil && data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	if data != nil {
		data_ptr = unsafe.Pointer(data_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glColorSubTable(gl.funcs, C.GLenum(target), C.GLsizei(start), C.GLsizei(count), C.GLenum(format), C.GLenum(gltype), data_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetColorTableParameteriv.xml
func (gl *GL) GetColorTableParameteriv(target, pname glbase.Enum, params []int32) {
	C.gl3_0_glGetColorTableParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetColorTableParameterfv.xml
func (gl *GL) GetColorTableParameterfv(target, pname glbase.Enum, params []float32) {
	C.gl3_0_glGetColorTableParameterfv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glGetColorTable.xml
func (gl *GL) GetColorTable(target, format, gltype glbase.Enum, table interface{}) {
	var table_ptr unsafe.Pointer
	var table_v = reflect.ValueOf(table)
	if table != nil && table_v.Kind() != reflect.Slice {
		panic("parameter table must be a slice")
	}
	if table != nil {
		table_ptr = unsafe.Pointer(table_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glGetColorTable(gl.funcs, C.GLenum(target), C.GLenum(format), C.GLenum(gltype), table_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glCopyColorTable.xml
func (gl *GL) CopyColorTable(target, internalFormat glbase.Enum, x, y, width int) {
	C.gl3_0_glCopyColorTable(gl.funcs, C.GLenum(target), C.GLenum(internalFormat), C.GLint(x), C.GLint(y), C.GLsizei(width))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColorTableParameteriv.xml
func (gl *GL) ColorTableParameteriv(target, pname glbase.Enum, params []int32) {
	C.gl3_0_glColorTableParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColorTableParameterfv.xml
func (gl *GL) ColorTableParameterfv(target, pname glbase.Enum, params []float32) {
	C.gl3_0_glColorTableParameterfv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glColorTable.xml
func (gl *GL) ColorTable(target, internalFormat glbase.Enum, width int, format, gltype glbase.Enum, table interface{}) {
	var table_ptr unsafe.Pointer
	var table_v = reflect.ValueOf(table)
	if table != nil && table_v.Kind() != reflect.Slice {
		panic("parameter table must be a slice")
	}
	if table != nil {
		table_ptr = unsafe.Pointer(table_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glColorTable(gl.funcs, C.GLenum(target), C.GLenum(internalFormat), C.GLsizei(width), C.GLenum(format), C.GLenum(gltype), table_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultTransposeMatrixd.xml
func (gl *GL) MultTransposeMatrixd(m []float64) {
	C.gl3_0_glMultTransposeMatrixd(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&m[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultTransposeMatrixf.xml
func (gl *GL) MultTransposeMatrixf(m []float32) {
	C.gl3_0_glMultTransposeMatrixf(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&m[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glLoadTransposeMatrixd.xml
func (gl *GL) LoadTransposeMatrixd(m []float64) {
	C.gl3_0_glLoadTransposeMatrixd(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&m[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glLoadTransposeMatrixf.xml
func (gl *GL) LoadTransposeMatrixf(m []float32) {
	C.gl3_0_glLoadTransposeMatrixf(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&m[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord4sv.xml
func (gl *GL) MultiTexCoord4sv(target glbase.Enum, v []int16) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glMultiTexCoord4sv(gl.funcs, C.GLenum(target), (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord4s.xml
func (gl *GL) MultiTexCoord4s(target glbase.Enum, s, t, r, q int16) {
	C.gl3_0_glMultiTexCoord4s(gl.funcs, C.GLenum(target), C.GLshort(s), C.GLshort(t), C.GLshort(r), C.GLshort(q))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord4iv.xml
func (gl *GL) MultiTexCoord4iv(target glbase.Enum, v []int32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glMultiTexCoord4iv(gl.funcs, C.GLenum(target), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord4i.xml
func (gl *GL) MultiTexCoord4i(target glbase.Enum, s, t, r, q int32) {
	C.gl3_0_glMultiTexCoord4i(gl.funcs, C.GLenum(target), C.GLint(s), C.GLint(t), C.GLint(r), C.GLint(q))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord4fv.xml
func (gl *GL) MultiTexCoord4fv(target glbase.Enum, v []float32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glMultiTexCoord4fv(gl.funcs, C.GLenum(target), (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord4f.xml
func (gl *GL) MultiTexCoord4f(target glbase.Enum, s, t, r, q float32) {
	C.gl3_0_glMultiTexCoord4f(gl.funcs, C.GLenum(target), C.GLfloat(s), C.GLfloat(t), C.GLfloat(r), C.GLfloat(q))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord4dv.xml
func (gl *GL) MultiTexCoord4dv(target glbase.Enum, v []float64) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glMultiTexCoord4dv(gl.funcs, C.GLenum(target), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord4d.xml
func (gl *GL) MultiTexCoord4d(target glbase.Enum, s, t, r, q float64) {
	C.gl3_0_glMultiTexCoord4d(gl.funcs, C.GLenum(target), C.GLdouble(s), C.GLdouble(t), C.GLdouble(r), C.GLdouble(q))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord3sv.xml
func (gl *GL) MultiTexCoord3sv(target glbase.Enum, v []int16) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glMultiTexCoord3sv(gl.funcs, C.GLenum(target), (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord3s.xml
func (gl *GL) MultiTexCoord3s(target glbase.Enum, s, t, r int16) {
	C.gl3_0_glMultiTexCoord3s(gl.funcs, C.GLenum(target), C.GLshort(s), C.GLshort(t), C.GLshort(r))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord3iv.xml
func (gl *GL) MultiTexCoord3iv(target glbase.Enum, v []int32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glMultiTexCoord3iv(gl.funcs, C.GLenum(target), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord3i.xml
func (gl *GL) MultiTexCoord3i(target glbase.Enum, s, t, r int32) {
	C.gl3_0_glMultiTexCoord3i(gl.funcs, C.GLenum(target), C.GLint(s), C.GLint(t), C.GLint(r))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord3fv.xml
func (gl *GL) MultiTexCoord3fv(target glbase.Enum, v []float32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glMultiTexCoord3fv(gl.funcs, C.GLenum(target), (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord3f.xml
func (gl *GL) MultiTexCoord3f(target glbase.Enum, s, t, r float32) {
	C.gl3_0_glMultiTexCoord3f(gl.funcs, C.GLenum(target), C.GLfloat(s), C.GLfloat(t), C.GLfloat(r))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord3dv.xml
func (gl *GL) MultiTexCoord3dv(target glbase.Enum, v []float64) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glMultiTexCoord3dv(gl.funcs, C.GLenum(target), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord3d.xml
func (gl *GL) MultiTexCoord3d(target glbase.Enum, s, t, r float64) {
	C.gl3_0_glMultiTexCoord3d(gl.funcs, C.GLenum(target), C.GLdouble(s), C.GLdouble(t), C.GLdouble(r))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord2sv.xml
func (gl *GL) MultiTexCoord2sv(target glbase.Enum, v []int16) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glMultiTexCoord2sv(gl.funcs, C.GLenum(target), (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord2s.xml
func (gl *GL) MultiTexCoord2s(target glbase.Enum, s, t int16) {
	C.gl3_0_glMultiTexCoord2s(gl.funcs, C.GLenum(target), C.GLshort(s), C.GLshort(t))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord2iv.xml
func (gl *GL) MultiTexCoord2iv(target glbase.Enum, v []int32) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glMultiTexCoord2iv(gl.funcs, C.GLenum(target), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord2i.xml
func (gl *GL) MultiTexCoord2i(target glbase.Enum, s, t int32) {
	C.gl3_0_glMultiTexCoord2i(gl.funcs, C.GLenum(target), C.GLint(s), C.GLint(t))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord2fv.xml
func (gl *GL) MultiTexCoord2fv(target glbase.Enum, v []float32) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glMultiTexCoord2fv(gl.funcs, C.GLenum(target), (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord2f.xml
func (gl *GL) MultiTexCoord2f(target glbase.Enum, s, t float32) {
	C.gl3_0_glMultiTexCoord2f(gl.funcs, C.GLenum(target), C.GLfloat(s), C.GLfloat(t))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord2dv.xml
func (gl *GL) MultiTexCoord2dv(target glbase.Enum, v []float64) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glMultiTexCoord2dv(gl.funcs, C.GLenum(target), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord2d.xml
func (gl *GL) MultiTexCoord2d(target glbase.Enum, s, t float64) {
	C.gl3_0_glMultiTexCoord2d(gl.funcs, C.GLenum(target), C.GLdouble(s), C.GLdouble(t))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord1sv.xml
func (gl *GL) MultiTexCoord1sv(target glbase.Enum, v []int16) {
	C.gl3_0_glMultiTexCoord1sv(gl.funcs, C.GLenum(target), (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord1s.xml
func (gl *GL) MultiTexCoord1s(target glbase.Enum, s int16) {
	C.gl3_0_glMultiTexCoord1s(gl.funcs, C.GLenum(target), C.GLshort(s))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord1iv.xml
func (gl *GL) MultiTexCoord1iv(target glbase.Enum, v []int32) {
	C.gl3_0_glMultiTexCoord1iv(gl.funcs, C.GLenum(target), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord1i.xml
func (gl *GL) MultiTexCoord1i(target glbase.Enum, s int32) {
	C.gl3_0_glMultiTexCoord1i(gl.funcs, C.GLenum(target), C.GLint(s))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord1fv.xml
func (gl *GL) MultiTexCoord1fv(target glbase.Enum, v []float32) {
	C.gl3_0_glMultiTexCoord1fv(gl.funcs, C.GLenum(target), (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord1f.xml
func (gl *GL) MultiTexCoord1f(target glbase.Enum, s float32) {
	C.gl3_0_glMultiTexCoord1f(gl.funcs, C.GLenum(target), C.GLfloat(s))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord1dv.xml
func (gl *GL) MultiTexCoord1dv(target glbase.Enum, v []float64) {
	C.gl3_0_glMultiTexCoord1dv(gl.funcs, C.GLenum(target), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glMultiTexCoord1d.xml
func (gl *GL) MultiTexCoord1d(target glbase.Enum, s float64) {
	C.gl3_0_glMultiTexCoord1d(gl.funcs, C.GLenum(target), C.GLdouble(s))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glClientActiveTexture.xml
func (gl *GL) ClientActiveTexture(texture glbase.Enum) {
	C.gl3_0_glClientActiveTexture(gl.funcs, C.GLenum(texture))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glWindowPos3sv.xml
func (gl *GL) WindowPos3sv(v []int16) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glWindowPos3sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glWindowPos3s.xml
func (gl *GL) WindowPos3s(x, y, z int16) {
	C.gl3_0_glWindowPos3s(gl.funcs, C.GLshort(x), C.GLshort(y), C.GLshort(z))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glWindowPos3iv.xml
func (gl *GL) WindowPos3iv(v []int32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glWindowPos3iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glWindowPos3i.xml
func (gl *GL) WindowPos3i(x, y, z int) {
	C.gl3_0_glWindowPos3i(gl.funcs, C.GLint(x), C.GLint(y), C.GLint(z))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glWindowPos3fv.xml
func (gl *GL) WindowPos3fv(v []float32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glWindowPos3fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glWindowPos3f.xml
func (gl *GL) WindowPos3f(x, y, z float32) {
	C.gl3_0_glWindowPos3f(gl.funcs, C.GLfloat(x), C.GLfloat(y), C.GLfloat(z))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glWindowPos3dv.xml
func (gl *GL) WindowPos3dv(v []float64) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glWindowPos3dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glWindowPos3d.xml
func (gl *GL) WindowPos3d(x, y, z float64) {
	C.gl3_0_glWindowPos3d(gl.funcs, C.GLdouble(x), C.GLdouble(y), C.GLdouble(z))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glWindowPos2sv.xml
func (gl *GL) WindowPos2sv(v []int16) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glWindowPos2sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glWindowPos2s.xml
func (gl *GL) WindowPos2s(x, y int16) {
	C.gl3_0_glWindowPos2s(gl.funcs, C.GLshort(x), C.GLshort(y))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glWindowPos2iv.xml
func (gl *GL) WindowPos2iv(v []int32) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glWindowPos2iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glWindowPos2i.xml
func (gl *GL) WindowPos2i(x, y int) {
	C.gl3_0_glWindowPos2i(gl.funcs, C.GLint(x), C.GLint(y))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glWindowPos2fv.xml
func (gl *GL) WindowPos2fv(v []float32) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glWindowPos2fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glWindowPos2f.xml
func (gl *GL) WindowPos2f(x, y float32) {
	C.gl3_0_glWindowPos2f(gl.funcs, C.GLfloat(x), C.GLfloat(y))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glWindowPos2dv.xml
func (gl *GL) WindowPos2dv(v []float64) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glWindowPos2dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glWindowPos2d.xml
func (gl *GL) WindowPos2d(x, y float64) {
	C.gl3_0_glWindowPos2d(gl.funcs, C.GLdouble(x), C.GLdouble(y))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glSecondaryColorPointer.xml
func (gl *GL) SecondaryColorPointer(size int, gltype glbase.Enum, stride int, pointer interface{}) {
	var pointer_ptr unsafe.Pointer
	var pointer_v = reflect.ValueOf(pointer)
	if pointer != nil && pointer_v.Kind() != reflect.Slice {
		panic("parameter pointer must be a slice")
	}
	if pointer != nil {
		pointer_ptr = unsafe.Pointer(pointer_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glSecondaryColorPointer(gl.funcs, C.GLint(size), C.GLenum(gltype), C.GLsizei(stride), pointer_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glSecondaryColor3usv.xml
func (gl *GL) SecondaryColor3usv(v []uint16) {
	C.gl3_0_glSecondaryColor3usv(gl.funcs, (*C.GLushort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glSecondaryColor3us.xml
func (gl *GL) SecondaryColor3us(red, green, blue uint16) {
	C.gl3_0_glSecondaryColor3us(gl.funcs, C.GLushort(red), C.GLushort(green), C.GLushort(blue))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glSecondaryColor3uiv.xml
func (gl *GL) SecondaryColor3uiv(v []uint32) {
	C.gl3_0_glSecondaryColor3uiv(gl.funcs, (*C.GLuint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glSecondaryColor3ui.xml
func (gl *GL) SecondaryColor3ui(red, green, blue uint32) {
	C.gl3_0_glSecondaryColor3ui(gl.funcs, C.GLuint(red), C.GLuint(green), C.GLuint(blue))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glSecondaryColor3ubv.xml
func (gl *GL) SecondaryColor3ubv(v []uint8) {
	C.gl3_0_glSecondaryColor3ubv(gl.funcs, (*C.GLubyte)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glSecondaryColor3ub.xml
func (gl *GL) SecondaryColor3ub(red, green, blue uint8) {
	C.gl3_0_glSecondaryColor3ub(gl.funcs, C.GLubyte(red), C.GLubyte(green), C.GLubyte(blue))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glSecondaryColor3sv.xml
func (gl *GL) SecondaryColor3sv(v []int16) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glSecondaryColor3sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glSecondaryColor3s.xml
func (gl *GL) SecondaryColor3s(red, green, blue int16) {
	C.gl3_0_glSecondaryColor3s(gl.funcs, C.GLshort(red), C.GLshort(green), C.GLshort(blue))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glSecondaryColor3iv.xml
func (gl *GL) SecondaryColor3iv(v []int32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glSecondaryColor3iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glSecondaryColor3i.xml
func (gl *GL) SecondaryColor3i(red, green, blue int32) {
	C.gl3_0_glSecondaryColor3i(gl.funcs, C.GLint(red), C.GLint(green), C.GLint(blue))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glSecondaryColor3fv.xml
func (gl *GL) SecondaryColor3fv(v []float32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glSecondaryColor3fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glSecondaryColor3f.xml
func (gl *GL) SecondaryColor3f(red, green, blue float32) {
	C.gl3_0_glSecondaryColor3f(gl.funcs, C.GLfloat(red), C.GLfloat(green), C.GLfloat(blue))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glSecondaryColor3dv.xml
func (gl *GL) SecondaryColor3dv(v []float64) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glSecondaryColor3dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glSecondaryColor3d.xml
func (gl *GL) SecondaryColor3d(red, green, blue float64) {
	C.gl3_0_glSecondaryColor3d(gl.funcs, C.GLdouble(red), C.GLdouble(green), C.GLdouble(blue))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glSecondaryColor3bv.xml
func (gl *GL) SecondaryColor3bv(v []byte) {
	C.gl3_0_glSecondaryColor3bv(gl.funcs, (*C.GLbyte)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glSecondaryColor3b.xml
func (gl *GL) SecondaryColor3b(red, green, blue byte) {
	C.gl3_0_glSecondaryColor3b(gl.funcs, C.GLbyte(red), C.GLbyte(green), C.GLbyte(blue))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glFogCoordPointer.xml
func (gl *GL) FogCoordPointer(gltype glbase.Enum, stride int, pointer interface{}) {
	var pointer_ptr unsafe.Pointer
	var pointer_v = reflect.ValueOf(pointer)
	if pointer != nil && pointer_v.Kind() != reflect.Slice {
		panic("parameter pointer must be a slice")
	}
	if pointer != nil {
		pointer_ptr = unsafe.Pointer(pointer_v.Index(0).Addr().Pointer())
	}
	C.gl3_0_glFogCoordPointer(gl.funcs, C.GLenum(gltype), C.GLsizei(stride), pointer_ptr)
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glFogCoorddv.xml
func (gl *GL) FogCoorddv(coord []float64) {
	C.gl3_0_glFogCoorddv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&coord[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glFogCoordd.xml
func (gl *GL) FogCoordd(coord float64) {
	C.gl3_0_glFogCoordd(gl.funcs, C.GLdouble(coord))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glFogCoordfv.xml
func (gl *GL) FogCoordfv(coord []float32) {
	C.gl3_0_glFogCoordfv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&coord[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glFogCoordf.xml
func (gl *GL) FogCoordf(coord float32) {
	C.gl3_0_glFogCoordf(gl.funcs, C.GLfloat(coord))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib4usv.xml
func (gl *GL) VertexAttrib4usv(index glbase.Attrib, v []uint16) {
	C.gl3_0_glVertexAttrib4usv(gl.funcs, C.GLuint(index), (*C.GLushort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib4uiv.xml
func (gl *GL) VertexAttrib4uiv(index glbase.Attrib, v []uint32) {
	C.gl3_0_glVertexAttrib4uiv(gl.funcs, C.GLuint(index), (*C.GLuint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib4ubv.xml
func (gl *GL) VertexAttrib4ubv(index glbase.Attrib, v []uint8) {
	C.gl3_0_glVertexAttrib4ubv(gl.funcs, C.GLuint(index), (*C.GLubyte)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib4sv.xml
func (gl *GL) VertexAttrib4sv(index glbase.Attrib, v []int16) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glVertexAttrib4sv(gl.funcs, C.GLuint(index), (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib4s.xml
func (gl *GL) VertexAttrib4s(index glbase.Attrib, x, y, z, w int16) {
	C.gl3_0_glVertexAttrib4s(gl.funcs, C.GLuint(index), C.GLshort(x), C.GLshort(y), C.GLshort(z), C.GLshort(w))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib4iv.xml
func (gl *GL) VertexAttrib4iv(index glbase.Attrib, v []int32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glVertexAttrib4iv(gl.funcs, C.GLuint(index), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib4fv.xml
func (gl *GL) VertexAttrib4fv(index glbase.Attrib, v []float32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glVertexAttrib4fv(gl.funcs, C.GLuint(index), (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib4f.xml
func (gl *GL) VertexAttrib4f(index glbase.Attrib, x, y, z, w float32) {
	C.gl3_0_glVertexAttrib4f(gl.funcs, C.GLuint(index), C.GLfloat(x), C.GLfloat(y), C.GLfloat(z), C.GLfloat(w))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib4dv.xml
func (gl *GL) VertexAttrib4dv(index glbase.Attrib, v []float64) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glVertexAttrib4dv(gl.funcs, C.GLuint(index), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib4d.xml
func (gl *GL) VertexAttrib4d(index glbase.Attrib, x, y, z, w float64) {
	C.gl3_0_glVertexAttrib4d(gl.funcs, C.GLuint(index), C.GLdouble(x), C.GLdouble(y), C.GLdouble(z), C.GLdouble(w))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib4bv.xml
func (gl *GL) VertexAttrib4bv(index glbase.Attrib, v []byte) {
	C.gl3_0_glVertexAttrib4bv(gl.funcs, C.GLuint(index), (*C.GLbyte)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib4Nusv.xml
func (gl *GL) VertexAttrib4Nusv(index glbase.Attrib, v []uint16) {
	C.gl3_0_glVertexAttrib4Nusv(gl.funcs, C.GLuint(index), (*C.GLushort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib4Nuiv.xml
func (gl *GL) VertexAttrib4Nuiv(index glbase.Attrib, v []uint32) {
	C.gl3_0_glVertexAttrib4Nuiv(gl.funcs, C.GLuint(index), (*C.GLuint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib4Nubv.xml
func (gl *GL) VertexAttrib4Nubv(index glbase.Attrib, v []uint8) {
	C.gl3_0_glVertexAttrib4Nubv(gl.funcs, C.GLuint(index), (*C.GLubyte)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib4Nub.xml
func (gl *GL) VertexAttrib4Nub(index glbase.Attrib, x, y, z, w uint8) {
	C.gl3_0_glVertexAttrib4Nub(gl.funcs, C.GLuint(index), C.GLubyte(x), C.GLubyte(y), C.GLubyte(z), C.GLubyte(w))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib4Nsv.xml
func (gl *GL) VertexAttrib4Nsv(index glbase.Attrib, v []int16) {
	C.gl3_0_glVertexAttrib4Nsv(gl.funcs, C.GLuint(index), (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib4Niv.xml
func (gl *GL) VertexAttrib4Niv(index glbase.Attrib, v []int32) {
	C.gl3_0_glVertexAttrib4Niv(gl.funcs, C.GLuint(index), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib4Nbv.xml
func (gl *GL) VertexAttrib4Nbv(index glbase.Attrib, v []byte) {
	C.gl3_0_glVertexAttrib4Nbv(gl.funcs, C.GLuint(index), (*C.GLbyte)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib3sv.xml
func (gl *GL) VertexAttrib3sv(index glbase.Attrib, v []int16) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glVertexAttrib3sv(gl.funcs, C.GLuint(index), (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib3s.xml
func (gl *GL) VertexAttrib3s(index glbase.Attrib, x, y, z int16) {
	C.gl3_0_glVertexAttrib3s(gl.funcs, C.GLuint(index), C.GLshort(x), C.GLshort(y), C.GLshort(z))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib3fv.xml
func (gl *GL) VertexAttrib3fv(index glbase.Attrib, v []float32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glVertexAttrib3fv(gl.funcs, C.GLuint(index), (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib3f.xml
func (gl *GL) VertexAttrib3f(index glbase.Attrib, x, y, z float32) {
	C.gl3_0_glVertexAttrib3f(gl.funcs, C.GLuint(index), C.GLfloat(x), C.GLfloat(y), C.GLfloat(z))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib3dv.xml
func (gl *GL) VertexAttrib3dv(index glbase.Attrib, v []float64) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glVertexAttrib3dv(gl.funcs, C.GLuint(index), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib3d.xml
func (gl *GL) VertexAttrib3d(index glbase.Attrib, x, y, z float64) {
	C.gl3_0_glVertexAttrib3d(gl.funcs, C.GLuint(index), C.GLdouble(x), C.GLdouble(y), C.GLdouble(z))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib2sv.xml
func (gl *GL) VertexAttrib2sv(index glbase.Attrib, v []int16) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glVertexAttrib2sv(gl.funcs, C.GLuint(index), (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib2s.xml
func (gl *GL) VertexAttrib2s(index glbase.Attrib, x, y int16) {
	C.gl3_0_glVertexAttrib2s(gl.funcs, C.GLuint(index), C.GLshort(x), C.GLshort(y))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib2fv.xml
func (gl *GL) VertexAttrib2fv(index glbase.Attrib, v []float32) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glVertexAttrib2fv(gl.funcs, C.GLuint(index), (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib2f.xml
func (gl *GL) VertexAttrib2f(index glbase.Attrib, x, y float32) {
	C.gl3_0_glVertexAttrib2f(gl.funcs, C.GLuint(index), C.GLfloat(x), C.GLfloat(y))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib2dv.xml
func (gl *GL) VertexAttrib2dv(index glbase.Attrib, v []float64) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glVertexAttrib2dv(gl.funcs, C.GLuint(index), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib2d.xml
func (gl *GL) VertexAttrib2d(index glbase.Attrib, x, y float64) {
	C.gl3_0_glVertexAttrib2d(gl.funcs, C.GLuint(index), C.GLdouble(x), C.GLdouble(y))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib1sv.xml
func (gl *GL) VertexAttrib1sv(index glbase.Attrib, v []int16) {
	C.gl3_0_glVertexAttrib1sv(gl.funcs, C.GLuint(index), (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib1s.xml
func (gl *GL) VertexAttrib1s(index glbase.Attrib, x int16) {
	C.gl3_0_glVertexAttrib1s(gl.funcs, C.GLuint(index), C.GLshort(x))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib1fv.xml
func (gl *GL) VertexAttrib1fv(index glbase.Attrib, v []float32) {
	C.gl3_0_glVertexAttrib1fv(gl.funcs, C.GLuint(index), (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib1f.xml
func (gl *GL) VertexAttrib1f(index glbase.Attrib, x float32) {
	C.gl3_0_glVertexAttrib1f(gl.funcs, C.GLuint(index), C.GLfloat(x))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib1dv.xml
func (gl *GL) VertexAttrib1dv(index glbase.Attrib, v []float64) {
	C.gl3_0_glVertexAttrib1dv(gl.funcs, C.GLuint(index), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttrib1d.xml
func (gl *GL) VertexAttrib1d(index glbase.Attrib, x float64) {
	C.gl3_0_glVertexAttrib1d(gl.funcs, C.GLuint(index), C.GLdouble(x))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttribI4usv.xml
func (gl *GL) VertexAttribI4usv(index glbase.Attrib, v []uint16) {
	C.gl3_0_glVertexAttribI4usv(gl.funcs, C.GLuint(index), (*C.GLushort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttribI4ubv.xml
func (gl *GL) VertexAttribI4ubv(index glbase.Attrib, v []uint8) {
	C.gl3_0_glVertexAttribI4ubv(gl.funcs, C.GLuint(index), (*C.GLubyte)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttribI4sv.xml
func (gl *GL) VertexAttribI4sv(index glbase.Attrib, v []int16) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glVertexAttribI4sv(gl.funcs, C.GLuint(index), (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttribI4bv.xml
func (gl *GL) VertexAttribI4bv(index glbase.Attrib, v []byte) {
	C.gl3_0_glVertexAttribI4bv(gl.funcs, C.GLuint(index), (*C.GLbyte)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttribI4uiv.xml
func (gl *GL) VertexAttribI4uiv(index glbase.Attrib, v []uint32) {
	C.gl3_0_glVertexAttribI4uiv(gl.funcs, C.GLuint(index), (*C.GLuint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttribI3uiv.xml
func (gl *GL) VertexAttribI3uiv(index glbase.Attrib, v []uint32) {
	C.gl3_0_glVertexAttribI3uiv(gl.funcs, C.GLuint(index), (*C.GLuint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttribI2uiv.xml
func (gl *GL) VertexAttribI2uiv(index glbase.Attrib, v []uint32) {
	C.gl3_0_glVertexAttribI2uiv(gl.funcs, C.GLuint(index), (*C.GLuint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttribI1uiv.xml
func (gl *GL) VertexAttribI1uiv(index glbase.Attrib, v []uint32) {
	C.gl3_0_glVertexAttribI1uiv(gl.funcs, C.GLuint(index), (*C.GLuint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttribI4iv.xml
func (gl *GL) VertexAttribI4iv(index glbase.Attrib, v []int32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glVertexAttribI4iv(gl.funcs, C.GLuint(index), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttribI3iv.xml
func (gl *GL) VertexAttribI3iv(index glbase.Attrib, v []int32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glVertexAttribI3iv(gl.funcs, C.GLuint(index), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttribI2iv.xml
func (gl *GL) VertexAttribI2iv(index glbase.Attrib, v []int32) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl3_0_glVertexAttribI2iv(gl.funcs, C.GLuint(index), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttribI1iv.xml
func (gl *GL) VertexAttribI1iv(index glbase.Attrib, v []int32) {
	C.gl3_0_glVertexAttribI1iv(gl.funcs, C.GLuint(index), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttribI4ui.xml
func (gl *GL) VertexAttribI4ui(index glbase.Attrib, x, y, z, w uint32) {
	C.gl3_0_glVertexAttribI4ui(gl.funcs, C.GLuint(index), C.GLuint(x), C.GLuint(y), C.GLuint(z), C.GLuint(w))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttribI3ui.xml
func (gl *GL) VertexAttribI3ui(index glbase.Attrib, x, y, z uint32) {
	C.gl3_0_glVertexAttribI3ui(gl.funcs, C.GLuint(index), C.GLuint(x), C.GLuint(y), C.GLuint(z))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttribI2ui.xml
func (gl *GL) VertexAttribI2ui(index glbase.Attrib, x, y uint32) {
	C.gl3_0_glVertexAttribI2ui(gl.funcs, C.GLuint(index), C.GLuint(x), C.GLuint(y))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttribI1ui.xml
func (gl *GL) VertexAttribI1ui(index glbase.Attrib, x uint32) {
	C.gl3_0_glVertexAttribI1ui(gl.funcs, C.GLuint(index), C.GLuint(x))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttribI4i.xml
func (gl *GL) VertexAttribI4i(index glbase.Attrib, x, y, z, w int) {
	C.gl3_0_glVertexAttribI4i(gl.funcs, C.GLuint(index), C.GLint(x), C.GLint(y), C.GLint(z), C.GLint(w))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttribI3i.xml
func (gl *GL) VertexAttribI3i(index glbase.Attrib, x, y, z int) {
	C.gl3_0_glVertexAttribI3i(gl.funcs, C.GLuint(index), C.GLint(x), C.GLint(y), C.GLint(z))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttribI2i.xml
func (gl *GL) VertexAttribI2i(index glbase.Attrib, x, y int) {
	C.gl3_0_glVertexAttribI2i(gl.funcs, C.GLuint(index), C.GLint(x), C.GLint(y))
}

// https://www.opengl.org/sdk/docs/man3/xhtml/glVertexAttribI1i.xml
func (gl *GL) VertexAttribI1i(index glbase.Attrib, x int) {
	C.gl3_0_glVertexAttribI1i(gl.funcs, C.GLuint(index), C.GLint(x))
}
